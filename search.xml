<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang学习_Map</title>
    <url>/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-Map/</url>
    <content><![CDATA[<h1 id="Go语言基础之-map"><a href="#Go语言基础之-map" class="headerlink" title="Go语言基础之 map"></a>Go语言基础之 map</h1><p>Go 语言中提供的映射关系容器为 <code>map</code>，其内部使用 <code>散列表(hash)</code> 实现。</p>
<span id="more"></span>
<h2 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. map</h2><p>map 是一种无序的 <code>key-value</code> 的数据结构，Go 语言中的 map 是引用类型，必须初始化才能使用</p>
<h3 id="1-1-map定义"><a href="#1-1-map定义" class="headerlink" title="1.1 map定义"></a>1.1 map定义</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]ValueType</span><br><span class="line"><span class="comment">// KeyType: 表示键的类型</span></span><br><span class="line"><span class="comment">// ValueType: 表示值的类型</span></span><br></pre></td></tr></table></figure>

<p>map 类型的变量默认初始值为 nil ，需要使用 <code>make()</code>函数来分配内存</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[keyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>

<h3 id="1-2-map基本使用"><a href="#1-2-map基本使用" class="headerlink" title="1.2 map基本使用"></a>1.2 map基本使用</h3><p>map的数据都是成对出现的，基本使用如下</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">20</span></span><br><span class="line">    scoreMap[<span class="string">&quot;李四&quot;</span>] = <span class="number">22</span></span><br><span class="line">    fmt.Println(scoreMap)</span><br><span class="line">    fmt.Println(scoreMap[<span class="string">&quot;张三&quot;</span>])</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[小明:<span class="number">20</span> 张三:<span class="number">22</span>]</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="keyword">type</span> of a:<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>map 支持在声明的时候填充元素</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    userInfo := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;琉心&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-判断某个值是否存在"><a href="#1-3-判断某个值是否存在" class="headerlink" title="1.3 判断某个值是否存在"></a>1.3 判断某个值是否存在</h3><p>Go 语言中有个判断 map 中键是否存在的特殊写法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure>

<h3 id="1-4-map的遍历"><a href="#1-4-map的遍历" class="headerlink" title="1.4 map的遍历"></a>1.4 map的遍历</h3><p>Go 语言中使用 <code>for range</code> 遍历 map</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> scroeMap &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但当我们只想着遍历 key 的时候，可以采用</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">        fmt.Println(k)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-使用-delete-函数删除键值对"><a href="#1-5-使用-delete-函数删除键值对" class="headerlink" title="1.5 使用 delete() 函数删除键值对"></a>1.5 使用 delete() 函数删除键值对</h3><p>使用<code>delete()</code> 函数从 map中删除一组键值对。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map：表示要删除键值对的 map</span></span><br><span class="line"><span class="comment">// key：表示要删除键值对的键</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-按照指定顺序遍历-map"><a href="#1-6-按照指定顺序遍历-map" class="headerlink" title="1.6 按照指定顺序遍历 map"></a>1.6 按照指定顺序遍历 map</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> scoreMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		key := fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i)</span><br><span class="line">		value := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		scoreMap[key] = value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for k, v := range scoreMap &#123;</span></span><br><span class="line">	<span class="comment">// 	fmt.Println(k, v)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// 取出所有的 key 存放到切片中</span></span><br><span class="line">	keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对key做排序</span></span><br><span class="line">	sort.Strings(keys)</span><br><span class="line">	<span class="comment">// 按照排序后的 key 对 scoreMap 排序</span></span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		fmt.Println(key,scoreMap[key])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-元素为-map-类型的切片"><a href="#1-7-元素为-map-类型的切片" class="headerlink" title="1.7 元素为 map 类型的切片"></a>1.7 元素为 map 类型的切片</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">3</span>) <span class="comment">// 只完成了切片的初始化</span></span><br><span class="line">    <span class="keyword">for</span> index, key := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对切片中的 map元素进行初始化</span></span><br><span class="line">    mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>) <span class="comment">// 完成了 map 的初始化</span></span><br><span class="line">    mapSlice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">    mapSlice[<span class="number">0</span>][<span class="string">&quot;password&quot;</span>] = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    mapSlice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;沙河&quot;</span></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-值为切片类型的-map"><a href="#1-8-值为切片类型的-map" class="headerlink" title="1.8 值为切片类型的 map"></a>1.8 值为切片类型的 map</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>, <span class="number">8</span>) <span class="comment">//只完成了map的初始化</span></span><br><span class="line">	v, ok := sliceMap[<span class="string">&quot;中国&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        sliceMap[<span class="string">&quot;中国&quot;</span>] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">8</span>) <span class="comment">// 完成了对切片的初始化</span></span><br><span class="line">        sliceMap[<span class="string">&quot;中国&quot;</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">        sliceMap[<span class="string">&quot;中国&quot;</span>][<span class="number">1</span>] = <span class="number">200</span></span><br><span class="line">        sliceMap[<span class="string">&quot;中国&quot;</span>][<span class="number">2</span>] = <span class="number">300</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 sliceMap</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> sliceMap &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how&#x3D;1 do&#x3D;2 you&#x3D;1。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个 map[string]int</span></span><br><span class="line">	<span class="keyword">var</span> s = <span class="string">&quot;how do you do&quot;</span></span><br><span class="line">	<span class="keyword">var</span> wordCount = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 字符串中有哪些单词</span></span><br><span class="line">	words := strings.Split(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="comment">// 遍历单词做统计</span></span><br><span class="line">	<span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">		v, ok := wordCount[word]</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="comment">// map中有这个单词的统计记录</span></span><br><span class="line">			wordCount[word] = v + <span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// map 中没有这个单词的记录</span></span><br><span class="line">			wordCount[word] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> wordCount &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span></span><br><span class="line">	m := <span class="built_in">make</span>(Map)</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">	m[<span class="string">&quot;q1mi&quot;</span>] = s</span><br><span class="line">	s = <span class="built_in">append</span>(s[:<span class="number">1</span>], s[<span class="number">2</span>:]...)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line">查看上述代码的输出结果</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习_包</title>
    <url>/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%8C%85/</url>
    <content><![CDATA[<h1 id="Go语言基础之包"><a href="#Go语言基础之包" class="headerlink" title="Go语言基础之包"></a>Go语言基础之包</h1><h2 id="一、包与依赖管理"><a href="#一、包与依赖管理" class="headerlink" title="一、包与依赖管理"></a>一、包与依赖管理</h2><h3 id="1-1-包-package"><a href="#1-1-包-package" class="headerlink" title="1.1 包(package)"></a>1.1 包(package)</h3><h4 id="1）包介绍"><a href="#1）包介绍" class="headerlink" title="1）包介绍"></a>1）包介绍</h4><p>Go语言中支持模块化的开发理念，在Go语言中 <code>包 package</code>来支持代码模块化和代码复用。Go语言为我们提供了很多内置包，如<code>fmt</code>、<code>os</code>、<code>io</code>等。</p>
<span id="more"></span>

<h4 id="2）定义包"><a href="#2）定义包" class="headerlink" title="2）定义包"></a>2）定义包</h4><p>我们可以根据自己的需要创建定义包。一个包可以简单理解成一个存放<code>.go</code>文件的文件夹。该文件夹下的所有文件都需要在非注释的第一行进行声明，声明该文件所属的包</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> packagename</span><br></pre></td></tr></table></figure>

<ul>
<li><p>package: 声明包的关键字</p>
</li>
<li><p>pakagename: 包名，可以不与文件夹的名称一致，不能包含<code>-</code>符号，最好与其实现的功能相互对应</p>
</li>
</ul>
<p>一个文件夹下面直接包含的文件只能归属一个包，同一个包的文件不能在多个文件夹下。</p>
<h4 id="3）标识符可见性"><a href="#3）标识符可见性" class="headerlink" title="3）标识符可见性"></a>3）标识符可见性</h4><p>在同一个包内部声明的标识符都位于同一个命名空间下，在不同的包内部声明的标识符就属于不同的命名空间。想要在包的外部使用包内部的标识符就需要添加包名前缀，例如<code>fmt.Println(&quot;Hello world!&quot;)</code>，就是指调用<code>fmt</code>包中的<code>Println</code>函数。</p>
<p>Go语言中通过标识符的首字母大&#x2F;小写来控制标识符的对外可见(public)&#x2F;不可见(private)的。在一个包内部只有首字母大写的标识符才是对外可见的。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// num定义一个全局整型变量</span></span><br><span class="line"><span class="comment">// 首字母小写，对外不可见</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mode 定义一个常量</span></span><br><span class="line"><span class="comment">// 首字母大写，对外可见</span></span><br><span class="line"><span class="keyword">const</span> Mode = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person定义一个代表人的结构体</span></span><br><span class="line"><span class="comment">// 首字母小写，对外不可见</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add 返回两个整数和的函数</span></span><br><span class="line"><span class="comment">// 首字母大写，对外可见</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sayHi 打招呼的函数</span></span><br><span class="line"><span class="comment">// 首字母小写，对外不可见</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot;七米&quot;</span></span><br><span class="line">    fmt.Println(myName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体中可导出字段的字段名称必须首字母大写</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="comment">//可在包外访问</span></span><br><span class="line">    class <span class="type">string</span> <span class="comment">//仅在包内访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）包的引入"><a href="#4）包的引入" class="headerlink" title="4）包的引入"></a>4）包的引入</h4><p>要在当前包中使用另外一个包的内容就需要使用import关键字引入这个包，并且import语句通常放在文件的开头，package声明语句的下方。完整的引入声明语句格式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importname <span class="string">&quot;path/to/package&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>importname: 引入的包名，通常都省略。默认值为引入包的包名。</p>
</li>
<li><p>path&#x2F;to&#x2F;package: 引入包的路径名称，必须使用双引号包裹起来。</p>
</li>
<li><p>Go语言中禁止循环导入包</p>
</li>
</ul>
<p>一个Go源码文件可以同时引入多个包</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br></pre></td></tr></table></figure>
<p>当然也可以采用批量引入的方式</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当引入的多个包中存在相同的包名或者想自行为某个引入的包设置一个新包名时，都需要通过importname指定一个在当前文件中使用的新包名。例如，在引入fmt包时为其指定一个新包名f。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> f <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果引入一个包的时候为其设置了一个特殊_作为包名，那么这个包的引入方式就称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的init函数将被执行并且仅执行一遍。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="5）init初始化函数"><a href="#5）init初始化函数" class="headerlink" title="5）init初始化函数"></a>5）init初始化函数</h4><p>在每一个Go源文件中，都可以定义任意个如下格式的特殊函数:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种特殊的函数不接收任何参数也没有任何返回值，我们也不能在代码中主动调用它。当程序启动的时候，init函数会按照它们声明的顺序自动执行。</p>
<p>一个包的初始化过程是按照代码中引入的顺序来进行的，所有在该包中声明的init函数都将被串行调用并且仅调用执行一次。每一个包初始化的时候都是先执行依赖的包中声明的init函数再执行当前包中声明的init函数。</p>
<h3 id="1-2-go-module"><a href="#1-2-go-module" class="headerlink" title="1.2 go module"></a>1.2 go module</h3><h4 id="1）go-module介绍"><a href="#1）go-module介绍" class="headerlink" title="1）go module介绍"></a>1）go module介绍</h4><p>go module相关指令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>go mod init</td>
<td>初始化项目依赖，生成go.mod文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>根据go.mod文件下载依赖</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>对比项目文件中引入的依赖与go.mod进行对比</td>
</tr>
<tr>
<td>go mod graph</td>
<td>输出依赖关系图</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑go.mod文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>将项目的所有依赖导出至vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>检验一个依赖包是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>解释为什么需要这个依赖</td>
</tr>
</tbody></table>
<h6 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h6><p>这个环境变量主要是用于设置Go模块代理(Go module proxy)，其作用是用于使Go在后续拉取模块版本时能够脱离传统的VCS方式，直接通过镜像站点来快速拉取。</p>
<p>设置GOPROXY的命令如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">go env -v GOPROXY=https://goproxy.cn,dirct</span><br></pre></td></tr></table></figure>

<h6 id="GOPRIVATE"><a href="#GOPRIVATE" class="headerlink" title="GOPRIVATE"></a>GOPRIVATE</h6><p>设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">go env -w GOPRIVATE=&quot;git.mycompany.com&quot;</span><br></pre></td></tr></table></figure>
<p>这样在拉取以git.mycompany.com为路径前缀的依赖包时就能正常拉取了。</p>
<p>此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 GONOPROXY&#x3D;none，允许通内部代理拉取私有仓库的包。</p>
<h4 id="2）使用go-module引入包"><a href="#2）使用go-module引入包" class="headerlink" title="2）使用go module引入包"></a>2）使用go module引入包</h4><p>初始化项目：我们在本地新建一个名为 <code>holiday</code> 项目，按如下方式创建一个名为 <code>holiday</code> 的文件夹并切换到该目录下;</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> holiday</span><br><span class="line">$ <span class="built_in">cd</span> holiday</span><br></pre></td></tr></table></figure>

<p>接下来初始化项目</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">mod</span> init holiday</span><br><span class="line"><span class="built_in">go</span>: creating <span class="built_in">new</span> <span class="built_in">go</span>.<span class="built_in">mod</span>: module holiday</span><br></pre></td></tr></table></figure>
<p>该命令会自动在项目目录下创建一个 <code>go.mod</code> 文件，其内容如下:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">module</span> holiday</span><br><span class="line"></span><br><span class="line"><span class="attribute">go</span> <span class="number">1</span>.<span class="number">16</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>module holiday: 定义当前项目的导入路径</p>
</li>
<li><p>go 1.16: 标识当前项目使用的Go版本</p>
</li>
</ul>
<p>下载依赖包的两种方法<br>一: 在项目目录下执行 <code>go get</code> 命令手动下载依赖的包，默认下载最新的发布版本。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/q1mi/hello</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span>: added github.<span class="keyword">com</span>/q1mi/hello v0.<span class="number">1.1</span></span><br></pre></td></tr></table></figure>

<p>也可以指定想要下载指定的版本号。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">go</span> get -u github.com/q1mi/hello@v0.<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">go</span>: downloading github.com/q1mi/hello v0.<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">go</span> get: downgraded github.com/q1mi/hello v0.<span class="number">1</span>.<span class="number">1</span> =&gt; v0.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果想指定下载某个 commit 对应的代码，可以直接指定commit hash，一般写出前7位即可。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">go</span> get github.com/q1mi/hello@<span class="number">2</span>ccfadd</span><br><span class="line"><span class="attribute">go</span>: downloading github.com/q1mi/hello v0.<span class="number">1</span>.<span class="number">2</span>-<span class="number">0</span>.<span class="number">20210219092711</span>-<span class="number">2</span>ccfaddad6a3</span><br><span class="line"><span class="attribute">go</span> get: added github.com/q1mi/hello v0.<span class="number">1</span>.<span class="number">2</span>-<span class="number">0</span>.<span class="number">20210219092711</span>-<span class="number">2</span>ccfaddad6a3</span><br></pre></td></tr></table></figure>

<p>二: 直接编辑<code>go.mod</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module holiday</span><br><span class="line"></span><br><span class="line">go 1.16</span><br><span class="line"></span><br><span class="line">require github.com/q1mi/hello latest</span><br></pre></td></tr></table></figure>

<p>表示当前项目需要使用 <code>github.com/q1mi/hello</code> 库的最新版本，然后在项目目录下执行 <code>go mod download</code> 下载依赖包</p>
<p>可以在 <code>go.mod</code> 文件中指定需要的版本进行下载，只用指定<code>commit hash</code>的前7位就好了。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">require github.com<span class="regexp">/q1mi/</span>hello <span class="number">2</span>ccfadda</span><br></pre></td></tr></table></figure>

<p>Go语言支持在一个项目（project）下定义多个包（package）。</p>
<p>例如，我们在<code>holiday</code>项目内部创建一个新的package-<code>summer</code>，此时新的项目目录结构如下:</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">holidy</span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">mod</span></span><br><span class="line">├── <span class="built_in">go</span>.<span class="built_in">sum</span></span><br><span class="line">├── main.<span class="built_in">go</span></span><br><span class="line">└── summer</span><br><span class="line">    └── summer.<span class="built_in">go</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>holiday/summer/summer.go</code> 文件内容如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> summer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Diving潜水</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Diving</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;夏天去诗巴丹潜水...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要调用的时候</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;holiday/summer&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    summer.Diving()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在holidy&#x2F;go.mod文件中正常引入liwenzhou.com&#x2F;overtime包，然后像下面的示例那样使用replace语句将这个依赖替换为使用相对路径表示的本地包。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">module holiday</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require github.com/q1mi/hello v0<span class="number">.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">replace liwenzhou.com/overtime =&gt; ../overtime</span><br></pre></td></tr></table></figure>

<p><strong>go.mod文件</strong></p>
<p><code>go.mod</code>文件中记录了当前项目中所有依赖包的相关信息，声明依赖的格式如下:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="built_in">module</span>/<span class="built_in">path</span> v1<span class="number">.2</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>

<p>其中:</p>
<ul>
<li><p>require: 声明依赖的关键字</p>
</li>
<li><p>module&#x2F;path: 依赖包的引入路径</p>
</li>
<li><p>v1.2.3: 依赖包的版本号。支持以下几种格式:</p>
<ul>
<li>latest: 最新版本</li>
<li>v1.0.0: 详细版本号</li>
<li>commit hash: 指定某次commit hash</li>
</ul>
</li>
</ul>
<p><strong>go.sum文件</strong></p>
<p><code>go.sum</code>这个文件中详细记录了当前项目中引入的依赖包的信息及其hash 值。文件内容通常是以类似下面的格式出现。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;module&gt;</span><span class="symbol">&lt;version&gt;</span>/<span class="keyword">go</span>.<span class="keyword">mod</span> <span class="symbol">&lt;hash&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;module&gt;</span> <span class="symbol">&lt;version&gt;</span> <span class="symbol">&lt;hash&gt;</span></span><br><span class="line"><span class="symbol">&lt;module&gt;</span> <span class="symbol">&lt;version&gt;</span>/<span class="keyword">go</span>.<span class="keyword">mod</span> <span class="symbol">&lt;hash&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>依赖保存位置</strong></p>
<p>Go module 会把下载到本地的依赖包会以类似下面的形式保存在 <code>$GOPATH/pkg/mod</code> 目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">mod</span><br><span class="line">├── <span class="keyword">cache</span></span><br><span class="line"><span class="keyword"></span>├── <span class="keyword">cloud.google.com</span></span><br><span class="line"><span class="keyword"></span>├── github.com</span><br><span class="line">    	└──q1mi</span><br><span class="line">          ├── hello@<span class="built_in">v0</span>.<span class="number">0</span>.<span class="number">0</span><span class="number">-20210218074646</span><span class="number">-139</span>b<span class="symbol">0b</span>cd549d</span><br><span class="line">          ├── hello@<span class="built_in">v0</span>.<span class="number">1</span>.<span class="number">1</span></span><br><span class="line">          └── hello@<span class="built_in">v0</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果想清除所有本地已缓存的依赖包数据，可以执行<code>go clean -modcache</code>命令。</p>
<h4 id="3）使用go-module发布包"><a href="#3）使用go-module发布包" class="headerlink" title="3）使用go module发布包"></a>3）使用go module发布包</h4><p>我们首先在自己的 github 账号下新建一个项目，并把它下载到本地。我这里就以创建和发布一个名为hello的项目为例进行演示。这个hello包将对外提供一个名为SayHi的函数，它的作用非常简单就是向调用者发去问候。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/q1mi/hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> hello</span></span><br></pre></td></tr></table></figure>

<p>我们当前位于<code>hello</code>项目目录下，执行下面的命令初始化项目，创建<code>go.mod</code>文件。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> <span class="keyword">mod</span> init github.<span class="keyword">com</span>/q1mi/hello</span><br><span class="line"><span class="keyword">go</span>: creating <span class="keyword">new</span> <span class="keyword">go</span>.<span class="keyword">mod</span>: module github.<span class="keyword">com</span>/q1mi/hello</span><br></pre></td></tr></table></figure>

<p>接下来在该项目根目录下创建<code>hello.go</code>文件，添加下面的内容:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;你好，我是七米。很高兴认识你。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将该项目的代码push到仓库的远端分支，这样就对外发布了一个Go包。</p>
<p>一个设计完善的包应该包含开源许可证及文档等内容，并且我们还应该尽心维护并适时发布适当的版本。github 上发布版本号使用git tag为代码包打上标签即可。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v0.<span class="number">1.0</span> -m <span class="string">&quot;release version v0.1.0&quot;</span></span><br><span class="line">$ git push origin v0.<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">v1</span>.<span class="number">2</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>主版本号：发布了不兼容的版本迭代时递增(brakinng changes)。</li>
<li>次版本号：发布了功能性更新时递增。</li>
<li>修订号: 发布了bug修复类更新时递增。</li>
</ul>
<p><strong>发布新的主版本</strong></p>
<p>现在我们的<code>hello</code>项目要进行与之前版本不兼容的更新，我们计划让<code>SayHi</code>函数支持向指定人发出问候。更新后的<code>SayHi</code>函数内容以下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHi 向指定人打招呼的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;你好%s，我是七米。我很高兴认识你。\n&quot;</span>,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这次改动巨大（修改了函数之前的调用规则），对之前使用该包作为依赖的用户影响巨大。因此我们需要发布一个主版本号递增的v2版本。在这种情况下，我们通常会修改当前包的引入路径，像下面的示例一样为引入路径添加版本后缀。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">module</span> github.com/q1mi/hello/v2</span><br><span class="line"></span><br><span class="line"><span class="attribute">go</span> <span class="number">1</span>.<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>把修改后的代码提交:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">&quot;feat: sayHi现在支持给指定人打招呼&quot;</span></span><br><span class="line"><span class="variable">$ </span>git push</span><br></pre></td></tr></table></figure>

<p>打好tag推送到远程仓库。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git tag -a <span class="built_in">v2</span>.<span class="number">0</span>.<span class="number">0</span> -m <span class="string">&quot;release version v2.0.0&quot;</span></span><br><span class="line">$ git <span class="keyword">push</span> origin <span class="built_in">v2</span>.<span class="number">0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这样在不影响使用旧版本的用户的前提下，我们新的版本也发布出去了。想要使用v2版本的代码包的用户只需按修改后的引入路径下载即可。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">go</span> get github.com/q1mi/hello/v2@<span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在代码中使用的过程与之前类似，只是需要注意引入路径要添加 v2 版本后缀。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/q1mi/hello/v2&quot;</span> <span class="comment">// 引入v2版本</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;现在是假期时间...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	hello.SayHi(<span class="string">&quot;张三&quot;</span>) <span class="comment">// v2版本的SayHi函数需要传入字符串参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color=#FF000>废弃已发布的版本</font></strong></p>
<p>如果某个发布的版本存在致命缺陷不再想让用户使用时，我们可以使用retract声明废弃的版本。例如我们在hello&#x2F;go.mod文件中按如下方式声明即可对外废弃v0.1.2版本。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">module</span> github.com/q1mi/hello</span><br><span class="line"></span><br><span class="line"><span class="attribute">go</span> <span class="number">1</span>.<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">retract</span> v0.<span class="number">1</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>用户使用go get下载 <code>v0.1.2</code> 版本时就会收到提示，催促其升级到其他版本。</p>
]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>包</tag>
        <tag>package</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习_函数</title>
    <url>/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="GO语言基础之函数"><a href="#GO语言基础之函数" class="headerlink" title="GO语言基础之函数"></a>GO语言基础之函数</h1><h2 id="一、-函数"><a href="#一、-函数" class="headerlink" title="一、 函数"></a>一、 函数</h2><h3 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h3><p>Go语言中定义函数使用 <code>func</code> 关键字。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数<span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名称不能同名。</span></span><br><span class="line"><span class="comment">// 参数：参数由参数变量和参数变量的类型组成，多个参数之间用，分隔。</span></span><br><span class="line"><span class="comment">// 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用（）包裹，并用，分隔。</span></span><br><span class="line"><span class="comment">// 函数体：实现指定功能的代码块。</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>求两个数之和的函数:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数和返回值都是可选的，所以我们可以实现一个不需要参数也没有返回值的函数：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-函数的调用"><a href="#1-2-函数的调用" class="headerlink" title="1.2 函数的调用"></a>1.2 函数的调用</h3><p>定义了函数之后，通过<code>函数名()</code>方法来进行调用函数。比如:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-参数"><a href="#1-3-参数" class="headerlink" title="1.3 参数"></a>1.3 参数</h3><h4 id="1-类型简写"><a href="#1-类型简写" class="headerlink" title="1) 类型简写"></a>1) 类型简写</h4><p>函数的参数中如果相邻变量的类型相同，则可以省略类型:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-可变参数"><a href="#2-可变参数" class="headerlink" title="2) 可变参数"></a>2) 可变参数</h4><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加 <code>...</code> 来标识。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum2</span><span class="params">(x ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(x) <span class="comment">//x是一个切片</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>固定参数搭配可变参数的时候，可变参数要放在固定参数的后面。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum3</span><span class="params">(x <span class="type">int</span>, y ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">    sum := x</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> y &#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-返回值"><a href="#1-3-返回值" class="headerlink" title="1.3 返回值"></a>1.3 返回值</h3><p>函数采取 <code>return</code> 关键字向外输出返回值。</p>
<h4 id="1-多返回值"><a href="#1-多返回值" class="headerlink" title="1) 多返回值"></a>1) 多返回值</h4><p>如果采取多个返回值的时候，必须使用 <code>()</code> 将返回值包裹起来。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    sum := x + y</span><br><span class="line">    sub := x - y</span><br><span class="line">    <span class="keyword">return</span> sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-返回值命名"><a href="#2-返回值命名" class="headerlink" title="2) 返回值命名"></a>2) 返回值命名</h4><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量。最后通过 <code>return</code> 关键字返回。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum, sub <span class="type">int</span>)&#123;</span><br><span class="line">    sum := x + y</span><br><span class="line">    sub := x - y</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-返回值补充"><a href="#3-返回值补充" class="headerlink" title="3) 返回值补充"></a>3) 返回值补充</h4><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunc</span><span class="params">(x <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 没必要返回[]int&#123;&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、函数进阶"><a href="#二、函数进阶" class="headerlink" title="二、函数进阶"></a>二、函数进阶</h2><h3 id="2-1-变量作用域"><a href="#2-1-变量作用域" class="headerlink" title="2.1 变量作用域"></a>2.1 变量作用域</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1) 全局变量"></a>1) 全局变量</h4><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。在函数中可以访问到全局变量。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sag <span class="type">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGlobalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;num=%d\n&quot;</span>, sag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testGlobalVar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2) 局部变量"></a>2) 局部变量</h4><p>函数内定义的变量无法在函数外进行访问。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 访问不到在 testLocalVar() 函数中定义的代码 x</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果局部变量和全局变量重名，优先访问局部变量。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">100</span></span><br><span class="line">    fmt.Println(num) <span class="comment">//优先使用局部变量 num的值为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在if条件循环、for循环、switch语句上使用这种定义变量的方式。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar2</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(x, y) <span class="comment">// 函数的参数只会在本函数内生效</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">        z := <span class="number">100</span> <span class="comment">//变量z只在if语句块中生效</span></span><br><span class="line">        fmt.Println(z)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i) <span class="comment">//变量i只在当前for语句块中生效</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(i) //此处无法使用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-函数类型与变量"><a href="#2-2-函数类型与变量" class="headerlink" title="2.2 函数类型与变量"></a>2.2 函数类型与变量</h3><h4 id="1-定义函数类型"><a href="#1-定义函数类型" class="headerlink" title="1) 定义函数类型"></a>1) 定义函数类型</h4><p>我们可以使用 <code>type</code> 关键字来定义一个函数类型。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>上面语句定义了一个 <code>calculation</code> 类型，他是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<p>简单来说，凡是满足这个条件的函数都是 calculation 类型的函数</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add和sub都可以赋值给calculation类型的变量</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure>

<h4 id="2-函数类型变量"><a href="#2-函数类型变量" class="headerlink" title="2) 函数类型变量"></a>2) 函数类型变量</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c calculation               <span class="comment">// 声明一个calculation类型的变量c</span></span><br><span class="line">	c = add                         <span class="comment">// 把add赋值给c</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of c:%T\n&quot;</span>, c) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">	fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br><span class="line"></span><br><span class="line">	f := add                        <span class="comment">// 将函数add赋值给变量f</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of f:%T\n&quot;</span>, f) <span class="comment">// type of f:func(int, int) int</span></span><br><span class="line">	fmt.Println(f(<span class="number">10</span>, <span class="number">20</span>))          <span class="comment">// 像调用add一样调用f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-高阶函数"><a href="#2-3-高阶函数" class="headerlink" title="2.3 高阶函数"></a>2.3 高阶函数</h3><h4 id="1-函数作为参数"><a href="#1-函数作为参数" class="headerlink" title="1)函数作为参数"></a>1)函数作为参数</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">	fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-函数作为返回值"><a href="#2-函数作为返回值" class="headerlink" title="2)函数作为返回值"></a>2)函数作为返回值</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> s &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err := errors.New(<span class="string">&quot;无法识别的操作符&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-匿名函数和闭包"><a href="#2-4-匿名函数和闭包" class="headerlink" title="2.4 匿名函数和闭包"></a>2.4 匿名函数和闭包</h3><h4 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1) 匿名函数"></a>1) 匿名函数</h4><p>函数可以作为返回值。但是在Go语言中函数内部不能像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span>(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//将匿名函数保存到变量</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(x + y)</span><br><span class="line">    &#125;</span><br><span class="line">    add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自执行函数: 匿名函数定义完成后加()直接执行</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(x + y)</span><br><span class="line">    &#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2)闭包"></a>2)闭包</h4><p><code>闭包=函数+引用环境</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x += y</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = adder()</span><br><span class="line">    fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">    fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line"></span><br><span class="line">    f1 := adder()</span><br><span class="line">    fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//40</span></span><br><span class="line">    fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 </p>
<h3 id="2-5-defer语句"><a href="#2-5-defer语句" class="headerlink" title="2.5 defer语句"></a>2.5 defer语句</h3><p>Go 语言中的 <code>defer</code> 语句会将其后面跟随的语句进行延时处理。先被 <code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p>
<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table>
<thead>
<tr>
<th>内置函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>主要用来关闭channel</td>
</tr>
<tr>
<td>len</td>
<td>用来求长度，比如string、array、slice、map、channel</td>
</tr>
<tr>
<td>new</td>
<td>用来分配内存，主要用来分配类型，比如int、struct。返回的是指针</td>
</tr>
<tr>
<td>make</td>
<td>用来分配内存，主要用来分配引用类型,比如chan、map、slice</td>
</tr>
<tr>
<td>append</td>
<td>用来追加元素到数组、slice中</td>
</tr>
<tr>
<td>panic和recover</td>
<td>用来做错误处理</td>
</tr>
</tbody></table>
<h3 id="3-1-panic-x2F-recover"><a href="#3-1-panic-x2F-recover" class="headerlink" title="3.1 panic&#x2F;recover"></a>3.1 panic&#x2F;recover</h3><p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>reover()必须搭配<span class="keyword">defer</span>使用</span><br><span class="line"><span class="number">2.</span><span class="keyword">defer</span>一定要在可能引发<span class="built_in">panic</span>的语句之前定义。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>函数</tag>
        <tag>func</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习_指针</title>
    <url>/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="Go语言基础之指针"><a href="#Go语言基础之指针" class="headerlink" title="Go语言基础之指针"></a>Go语言基础之指针</h1><h2 id="一、Go语言中的指针"><a href="#一、Go语言中的指针" class="headerlink" title="一、Go语言中的指针"></a>一、Go语言中的指针</h2><p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
<p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;（取地址）</code>和<code>*（根据地址取值）</code>。</p>
<span id="more"></span>

<h3 id="1-1-指针地址和指针类型"><a href="#1-1-指针地址和指针类型" class="headerlink" title="1.1 指针地址和指针类型"></a>1.1 指针地址和指针类型</h3><p>个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如:<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p>
<p>取变量指针的语法如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">ptr := &amp;v</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li>v: 代表被取地址的变量，类型为 T</li>
<li>ptr: 用于接收地址的变量，ptr的类型为 <code>*T</code>，称作T的指针类型。*表示指针。</li>
</ul>
<h3 id="1-2-指针取值"><a href="#1-2-指针取值" class="headerlink" title="1.2 指针取值"></a>1.2 指针取值</h3><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := &amp;a <span class="comment">//取变量a的地址，将指针保存在b中</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b)</span><br><span class="line">    c := *b <span class="comment">//指针取值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of c:%T\n&quot;</span>, c)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;value of c:%v\n&quot;</span>,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： 取地址操作符&amp;和取值操作符<em>是一对互补操作符，&amp;取出地址，</em>根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值(*)操作，可以获得指针变量指向的原变量的值。</li>
</ul>
<h3 id="1-3-new和make"><a href="#1-3-new和make" class="headerlink" title="1.3 new和make"></a>1.3 new和make</h3><h4 id="1-new"><a href="#1-new" class="headerlink" title="1) new"></a>1) new</h4><p>new是一个内置的函数，它的函数签名如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br></pre></td></tr></table></figure>

<ul>
<li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li>
<li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li>
</ul>
<p>指针作为引用类型需要初始化后才会拥有内存空间，才可以给它复制。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">    a = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *a = <span class="number">10</span></span><br><span class="line">    fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-make"><a href="#2-make" class="headerlink" title="2) make"></a>2) make</h4><p>make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type,size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure>
<p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。</p>
<h4 id="3-new与make的区别"><a href="#3-new与make的区别" class="headerlink" title="3) new与make的区别"></a>3) new与make的区别</h4><p>1.二者都是用来做内存分配的。<br>2.make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身;<br>3.而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</p>
]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>指针</tag>
        <tag>point</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习_基础语法</title>
    <url>/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h1><p>Go语言（Google开源、编译型语言、21世纪的C语言）</p>
<p>Go 语言的特点(简单易学习、开发效率高、执行性能好)</p>
<span id="more"></span>
<h2 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h2><h2 id="Go-语言代码结构"><a href="#Go-语言代码结构" class="headerlink" title="Go 语言代码结构"></a>Go 语言代码结构</h2><p>下面这个是一个简单的 Go 语言的代码结构</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码中，非注释的第一行，一定要是包的声明，声明我们写的Go文件到底属于哪一个包，每一个Go程序都应该包含一个 main 包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// “import”是导入的意思，这一行就是告诉 Go 编译器，我写的代码需要 fmt 这个包。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// “func”关键字，定义函数。&quot;main&quot;函数是程序开始执行的函数，每一个可执行程序都会有一个 &quot;main&quot;函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这一行表示访问 &quot;fmt&quot; 包中的 &quot;Println&quot; 函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello,world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意: GO语言的花括号，不能单独放在一行，必须跟在函数或者其他语句的结尾；Go 语言一行代码就代表一个语句，不需要加分号；带有逻辑的一些语句，必须放在函数内部</strong></p>
<h2 id="变量以及常量"><a href="#变量以及常量" class="headerlink" title="变量以及常量"></a>变量以及常量</h2><h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等。Go 语言中标识符只能由字母数字和下划线组成。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>Go 语言中有25个关键字:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="keyword">default</span> <span class="function"><span class="keyword">func</span></span> </span><br><span class="line"><span class="keyword">interface</span> <span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">defer</span> </span><br><span class="line"><span class="keyword">go</span> <span class="keyword">map</span> <span class="keyword">struct</span> <span class="keyword">chan</span> <span class="keyword">else</span> <span class="keyword">goto</span> <span class="keyword">package</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">const</span> <span class="keyword">fallthrough</span> <span class="keyword">if</span> <span class="keyword">range</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span> <span class="keyword">for</span> <span class="keyword">import</span> <span class="keyword">return</span> <span class="keyword">var</span></span><br></pre></td></tr></table></figure>

<p>Go语言中还有37个保留字:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Types:  <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">        <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">        <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">        <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Functions: <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span> <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span> <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>变量(Variable) 的功能是存储数据。常见变量的数据类型有：整形、浮点型、布尔型等。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明，并且Go语言的变量声明后必须使用。</p>
<p>Go 语言中的变量声明格式为：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>Go 语言中还支持批量声明，因为每次声明一个变量就需要写一个 <code>var</code> 关键字会比较繁琐。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">string</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">    d <span class="type">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。</p>
<p>Go 语言变量初始化的标准格式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 类型 = 表达式</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;小张&quot;</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者一次初始化多个变量</span></span><br><span class="line"><span class="keyword">var</span> name, age = <span class="string">&quot;小张&quot;</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小张&quot;</span> <span class="comment">//name 为 string</span></span><br></pre></td></tr></table></figure>

<p>在函数内部，可以使用更加简略的 <code>:=</code> 方式声明并且初始化变量</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    fmt.Println(m,n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用多重赋值时，如果想要忽略某个值，可以使用 匿名变量(annoymous variable)。匿名变量用一个<code>下划线_</code>表示</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;qqq&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, _ := foo()</span><br><span class="line">    _, y := foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;x=&quot;</span>, x) <span class="comment">// x= 10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;y=&quot;</span>, y) <span class="comment">// y= qqq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<ul>
<li><p>注意事项：</p>
<ol>
<li><p>函数外的每个语句都必须以关键字开始 (var, const, func 等)</p>
</li>
<li><p>:&#x3D; 不能使用在函数外</p>
</li>
<li><p>_多用于占位，表示忽略值</p>
</li>
</ol>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>相对于变量，常量是恒定不变的量，多用于定义程序运行期间不会改变的那些值。常量在定义的时候必须赋值</p>
<p>常量的声明:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure>

<p>多个常量可以一起声明:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415926</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>const 同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2  <span class="comment">// n2 = 100</span></span><br><span class="line">    n3  <span class="comment">// n3 = 100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>iota</code> 是 go 语言的常量计数器，只能在常量的表达式中使用</p>
<p><code>iota</code> 在 const 关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code> 计数一次</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    n2 <span class="comment">//1</span></span><br><span class="line">    n3 <span class="comment">//2 </span></span><br><span class="line">    n4 <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>Go 语言中有丰富的数据类型，除了基础的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道(channel)等。</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>按长度分为: int8，int16，int32，int64对应的无符号整型：uint8，uint16，uint32，uint64</p>
<p>uint8 就是 byte 型，int16对应C语言的short型，int64对应C语言中的long型。</p>
<p>特殊整型:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uint</td>
<td>32位操作系统上就是uint32，64位操作系统上就是uint64</td>
</tr>
<tr>
<td>int</td>
<td>32位操作系统上就是int32，64位操作系统上就是int64</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h4 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h4><p><code>v := 0b00101101</code>，代表二进制的 101101，相当于十进制的 45。<code>v := 0o377</code>，代表八进制的 377，相当于十进制的255。<code>v := 0x1p-2</code>，代表十六进制的 1除以2^2，也就是0.25。</p>
<p>而且还允许我们用 <code>_</code>来分隔数字，比如说 <code>v := 123_456</code>，表示 v 的值等于123456。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//十进制</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a) <span class="comment">//10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, a) <span class="comment">//1010 占位符%b表示二进制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//八进制 以0开头</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">077</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, b) <span class="comment">//77</span></span><br><span class="line">    <span class="comment">// 十六进制 以0x开头</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="type">int</span> = <span class="number">0xff</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, c) <span class="comment">//ff</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, c) <span class="comment">//FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go 语言支持两种浮点型数：<code>float32</code>和 <code>float64</code>。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%f\n&quot;</span>,math.Pi)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>,math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>complex64和complex128</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br></pre></td></tr></table></figure>
<p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Go 语言中以 <code>bool</code> 类型进行声明布尔型数据，布尔型数据只有 <code>true</code>和 <code>false</code> 两个值。</p>
<ul>
<li><p>注意事项：</p>
<ol>
<li><p>布尔类型变量的默认值为false。</p>
</li>
<li><p>Go语言中不允许将整型强制转换为布尔型。</p>
</li>
<li><p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
</li>
</ol>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go 语言中的字符串的内部实现使用 <code>UTF-8</code>编码。字符串的值为双引号中的内容。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><table>
<thead>
<tr>
<th>转义符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\r</td>
<td>回车符(返回行首)</td>
</tr>
<tr>
<td>\n</td>
<td>换行符(直接跳到下一行的同列位置)</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>Go语言中要定义一个多行字符串时，就必须使用 <code>反引号</code>字符:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串中的常用操作"><a href="#字符串中的常用操作" class="headerlink" title="字符串中的常用操作"></a>字符串中的常用操作</h4><table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>len(str)</td>
<td>求长度</td>
</tr>
<tr>
<td>+或fmt.Sprintf</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>strings.Split</td>
<td>分割</td>
</tr>
<tr>
<td>strings.contains</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>strings.HasPrefix，strings.HasSuffix</td>
<td>前缀&#x2F;后缀判断</td>
</tr>
<tr>
<td>strings.Index()，strings.LastIndex()</td>
<td>子串出现的位置</td>
</tr>
<tr>
<td>strings.Jon(a[]string,sep string)</td>
<td>join操作</td>
</tr>
</tbody></table>
<h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。字符用单引号（‘’）包裹起来，如</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>GO 语言的字符有两种类型：</p>
<ol>
<li><p>uint8类型，或者叫做byte型，代表一个ASCII码值</p>
</li>
<li><p>rune类型，代表一个UTF-8字符。</p>
</li>
</ol>
</li>
</ul>
<h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>要修改字符串，需要先将其转成<code>[]rune</code>或<code>[]byte</code>，完成后在转换为 <code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line">    <span class="comment">// 强制类型转换</span></span><br><span class="line">    byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">    byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">    s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">    runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">    runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go 语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure>
<p>其中T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>相加</td>
</tr>
<tr>
<td>-</td>
<td>相减</td>
</tr>
<tr>
<td>*</td>
<td>相乘</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>相除</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
</tr>
</tbody></table>
<p><strong>注意：++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符</strong></p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查两个值是否相等，如果相等返回 true否则返回false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查两个值是否不相等，如果不相等返回true否则返回false</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左边值是否大于右边值，如果是返回true，否则返回false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>检查左边值是否大于等于右边值，如果是返回true，否则返回false</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左边值是否小于右边值，如果是返回true，否则返回false</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>检查左边值是否小于等于右边值，如果是返回true，否则返回false</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑 AND 运算符。如果两边的操作都是True，则为True，否则为False</td>
</tr>
<tr>
<td>||</td>
<td>逻辑OR运算符。如果两边的操作有一个是True，则为True，否则为False</td>
</tr>
<tr>
<td>！</td>
<td>逻辑NOT运算符。如果条件为True，则为False，否则为True。</td>
</tr>
</tbody></table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>参与运算的两数各对应的二进位相与(两位均为1才为1)</td>
</tr>
<tr>
<td>|</td>
<td>参与运算的两数各对应的二进位相或(两位有一个为1就为1)</td>
</tr>
<tr>
<td>^</td>
<td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1（两位不一样则为1）</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移n位就是乘以2的n次方(“a&lt;&lt;b”就是把a的各二进位全部左移b位，高位丢弃，低位补零)</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移n位就是除以2的n次方(“a&gt;&gt;b”是把a的各二进位全部右移b位。)</td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>相加后再赋值</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>相减后再赋值</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>相乘后再赋值</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>相除后再赋值</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求余后再赋值</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移后赋值</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移后赋值</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与后赋值</td>
</tr>
<tr>
<td>|&#x3D;</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或后赋值</td>
</tr>
</tbody></table>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Go语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<h3 id="if-else-分支"><a href="#if-else-分支" class="headerlink" title="if-else 分支"></a>if-else 分支</h3><h4 id="if条件判断基本条件"><a href="#if条件判断基本条件" class="headerlink" title="if条件判断基本条件"></a>if条件判断基本条件</h4><p>Go 语言中 <code>if</code> 条件判断的格式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。</p>
<p>Go 语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。</p>
<h4 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h4><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for（循环结构）"><a href="#for（循环结构）" class="headerlink" title="for（循环结构）"></a>for（循环结构）</h3><p>for 循环的基本格式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for 循环的初始语句可以省略，但是初始语句后的分号必须要写。</span></span><br><span class="line"><span class="keyword">for</span> forDemo2() &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for 循环的初始语句和结束语句都可以省略</span></span><br><span class="line"><span class="keyword">for</span> forDemo3() &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环可以通过 break、goto、return、panic 语句强制退出循环</p>
<h3 id="for-range（键值循环）"><a href="#for-range（键值循环）" class="headerlink" title="for range（键值循环）"></a>for range（键值循环）</h3><p>Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 </p>
<p>通过for range遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用switch语句可以方便地对大量的值进行条件判断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">3</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个分支还可以有多个值，多个值中间使用英文逗号隔开</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;11&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分支还可以使用表达式，这个时候swtich后面不需要跟判断变量</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">age := <span class="number">111</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> age &gt; <span class="number">70</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;享受人生&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;活着真好&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> s == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure>

<h3 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h3><p>goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> breaking</span><br><span class="line"></span><br><span class="line">breaking:</span><br><span class="line">    fmt.Println(<span class="string">&quot;退出&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="break（跳出循环）"><a href="#break（跳出循环）" class="headerlink" title="break（跳出循环）"></a>break（跳出循环）</h3><p>break语句可以结束for、switch和select的代码块。</p>
<p>break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。</p>
<h3 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h3><p>continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h3><p>数组是同一种数据类型元素的集合。</p>
<h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义:"></a>数组定义:</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure>
<p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。</p>
<p>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1。</p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> numArray [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numArray [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [...]<span class="type">int</span>&#123;下标:数值&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cityArray [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 使用 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(cityArray); i++ &#123;</span><br><span class="line">        fmt.Println(cityArray[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用for range</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">range</span> cityArray &#123;</span><br><span class="line">        fmt.Println(index,value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h4 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">        &#123;<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;北京&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;西安&quot;</span>,<span class="string">&quot;成都&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v1 <span class="keyword">range</span> a &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v2 <span class="keyword">range</span> v1 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;%s\t&quot;</span>,v2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意： 多维数组只有第一层可以使用…来让编译器推导数组长度。例如：</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">    &#123;<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;北京&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;西安&quot;</span>,<span class="string">&quot;成都&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h3><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<ul>
<li>注意:<ol>
<li>数组支持 “&#x3D;&#x3D;“、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li>
<li>[n]<em>T表示指针数组，</em>[n]T表示数组指针 。</li>
</ol>
</li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p>声明切片类型的基本语法如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 []切片中的元素类型</span><br></pre></td></tr></table></figure>

<h4 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h4><p>使用 <code>len()</code> 函数求长度，使用内置的 <code>cap()</code> 函数求切片的容量。</p>
<h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式中的 <code>low</code> 和 <code>high</code> 表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1&lt;&#x3D;索引值&lt;4的元素组成切片s，得到的 <code>切片长度=high-low</code> ，容量等于得到的切片的底层数组的容量。</p>
<p>为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:</p>
<h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a[low: high: max]</span><br></pre></td></tr></table></figure>
<p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>
<h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    T: 切片的元素类型</span></span><br><span class="line"><span class="comment">    size: 切片中元素的数量</span></span><br><span class="line"><span class="comment">    cap: 切片的容量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h4><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<h4 id="判断切片是否为空值"><a href="#判断切片是否为空值" class="headerlink" title="判断切片是否为空值"></a>判断切片是否为空值</h4><p>使用 len(s) &#x3D;&#x3D; 0判断，不使用 s &#x3D;&#x3D; nil来判断。</p>
<h3 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h3><p>切片之间是不能比较的，我们不能使用&#x3D;&#x3D;操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 </p>
<h3 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h3><p>了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    s2 := s1</span><br><span class="line">    s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h3><p>切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Println(i,s[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Println(index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h3><p>Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1 2 3 4]</span></span><br><span class="line">    s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">    s = <span class="built_in">append</span>(s, s2...) <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<h3 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h3><p>切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。</p>
<h3 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h3><p>Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T)</span><br><span class="line"></span><br><span class="line"><span class="comment">// srcSlice：数据来源切片</span></span><br><span class="line"><span class="comment">// destSlice：目标切片</span></span><br></pre></td></tr></table></figure>

<h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>&#125;</span><br><span class="line">    <span class="comment">// 删除索引为2的元素</span></span><br><span class="line">    a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要从切片a中删除索引为 index 的元素，操作方法是 a &#x3D; append(a[:index]<br>, [index+1:]…)</p>
]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式笔记</title>
    <url>/2023/06/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="嵌入式笔记整理"><a href="#嵌入式笔记整理" class="headerlink" title="嵌入式笔记整理"></a>嵌入式笔记整理</h1><h2 id="第一章-嵌入式系统设计基础"><a href="#第一章-嵌入式系统设计基础" class="headerlink" title="第一章 嵌入式系统设计基础"></a>第一章 嵌入式系统设计基础</h2><h3 id="1-1-嵌入式系统概述"><a href="#1-1-嵌入式系统概述" class="headerlink" title="1.1 嵌入式系统概述"></a>1.1 嵌入式系统概述</h3><h4 id="1-1-1-什么是嵌入式系统"><a href="#1-1-1-什么是嵌入式系统" class="headerlink" title="1.1.1 什么是嵌入式系统"></a>1.1.1 什么是嵌入式系统</h4><p>嵌入式系统是<strong>以应用为中心</strong>，<strong>以计算机技术</strong>为基础，软件、硬件<strong>可剪裁</strong>，以适用于应用系统对功能、可靠性、成本、体积、功耗等要求严格的<strong>专用计算机系统</strong>。</p>
<span id="more"></span>
<h4 id="1-1-2-嵌入式系统的技术特点"><a href="#1-1-2-嵌入式系统的技术特点" class="headerlink" title="1.1.2 嵌入式系统的技术特点"></a>1.1.2 嵌入式系统的技术特点</h4><p>四大特性：专用性、低成本、可裁剪性、可靠性</p>
<h4 id="1-1-3-嵌入式系统的组成"><a href="#1-1-3-嵌入式系统的组成" class="headerlink" title="1.1.3 嵌入式系统的组成"></a>1.1.3 嵌入式系统的组成</h4><p>分为硬件设备和软件设备，嵌入式处理器-&gt;硬件核心。</p>
<img src = "./1.png">

<h5 id="1）嵌入式处理器类型"><a href="#1）嵌入式处理器类型" class="headerlink" title="1）嵌入式处理器类型"></a>1）嵌入式处理器类型</h5><p>微控制器(MCU)；嵌入式微处理器(MPU)；数字信号处理器(DSP)；片上系统(Soc)</p>
<h5 id="2）嵌入式操作系统"><a href="#2）嵌入式操作系统" class="headerlink" title="2）嵌入式操作系统"></a>2）嵌入式操作系统</h5><p>谷歌的Android系统和苹果的iOS系统。实时操作系统常用免费的uC&#x2F;OS-II或者商业化的VxWorks等。</p>
<h3 id="1-2-嵌入式系统的开发"><a href="#1-2-嵌入式系统的开发" class="headerlink" title="1.2 嵌入式系统的开发"></a>1.2 嵌入式系统的开发</h3><h4 id="1-2-1-嵌入式系统的开发模式"><a href="#1-2-1-嵌入式系统的开发模式" class="headerlink" title="1.2.1 嵌入式系统的开发模式"></a>1.2.1 嵌入式系统的开发模式</h4><p>宿主机-目标机(开发模式)</p>
<h2 id="第二章-ARM-Cortex-M3-处理器"><a href="#第二章-ARM-Cortex-M3-处理器" class="headerlink" title="第二章 ARM Cortex-M3 处理器"></a>第二章 ARM Cortex-M3 处理器</h2><h3 id="2-2-Cortex-M3-处理器"><a href="#2-2-Cortex-M3-处理器" class="headerlink" title="2.2 Cortex-M3 处理器"></a>2.2 Cortex-M3 处理器</h3><ul>
<li>CM3的功能模块<br>高性能32位RISC处理器；大量寄存器，都可用于多种用途；采用Thumb指令集结构；3级流水线（取指-译码-执行）；采用哈佛存储结构；高级微控制器总线结构</li>
</ul>
<p>CM3的两个状态两个级别两种模式</p>
<img src = "./2.png">

<ul>
<li>两个状态：Thumb状态、调试状态 </li>
<li>两个级别：特权级、非特权级</li>
<li>两种模式：异常处理模式、线程模式</li>
</ul>
<h3 id="2-3-寄存器"><a href="#2-3-寄存器" class="headerlink" title="2.3 寄存器"></a>2.3 寄存器</h3><h4 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1.通用寄存器"></a>1.通用寄存器</h4><img src = "./3.png">

<p>CM3设计有16个32位通用寄存器，R0~R12是真正意义上的通用寄存器。</p>
<h4 id="2-专用寄存器"><a href="#2-专用寄存器" class="headerlink" title="2.专用寄存器"></a>2.专用寄存器</h4><img src = "./4.png">

<p>专用寄存器不通过存储器地址访问，而是使用专用寄存器访问指令</p>
<ul>
<li><p>程序状态寄存器(Program Status Register,PSR)</p>
</li>
<li><p>异常屏蔽位寄存器(Exception Mask Register)</p>
</li>
</ul>
<h3 id="2-4-存储器组织"><a href="#2-4-存储器组织" class="headerlink" title="2.4 存储器组织"></a>2.4 存储器组织</h3><h5 id="1-位带区"><a href="#1-位带区" class="headerlink" title="1.位带区"></a>1.位带区</h5><img src = "./5.png">

<p>别名地址&#x3D;位带基地址+字节偏移量×32+位号×4</p>
<ul>
<li><p>位带基地址通常情况下为:0x22000以及0x42000</p>
</li>
<li><p>字节偏移量根据要访问的位带地址距离基地址0x2000和0x4000的偏移值</p>
</li>
<li><p>位号：题目会给</p>
</li>
</ul>
<h5 id="2-字节存储顺序"><a href="#2-字节存储顺序" class="headerlink" title="2.字节存储顺序"></a>2.字节存储顺序</h5><img src = "./6.png">

<p>低位低，高位高（小端存储）；高位低，低位高（大端存储）</p>
<h2 id="第四章-STM32-微控制器"><a href="#第四章-STM32-微控制器" class="headerlink" title="第四章 STM32 微控制器"></a>第四章 STM32 微控制器</h2><h3 id="4-1-STM32微控制器结构"><a href="#4-1-STM32微控制器结构" class="headerlink" title="4.1 STM32微控制器结构"></a>4.1 STM32微控制器结构</h3><h4 id="4-1-2-STM32系统结构"><a href="#4-1-2-STM32系统结构" class="headerlink" title="4.1.2 STM32系统结构"></a>4.1.2 STM32系统结构</h4><img src = "./7.png">

<ul>
<li>通用输入&#x2F;输出端口(GPIO)以及复用功能的输入&#x2F;输出端口(AFIO)</li>
<li>通用同步&#x2F;异步接收发送器(USART)；通用异步接收发送器(UART)</li>
<li>串行外设接口(SPI)</li>
<li>内部集成电路I2C接口(I2C)</li>
<li>看门狗(Watch Dog)，独立看门狗(IWDG)和窗口看门狗(WWDG)</li>
<li>实时时钟(RTC)</li>
<li>通用定时器(TIMx)</li>
<li>模拟&#x2F;数字转换器ADC</li>
</ul>
<table>
<thead>
<tr>
<th>缩写</th>
<th>外设名称</th>
<th>缩写</th>
<th>外设名称</th>
</tr>
</thead>
<tbody><tr>
<td>adc</td>
<td>A&#x2F;D转换器</td>
<td>bkp</td>
<td>备份寄存器</td>
</tr>
<tr>
<td>can</td>
<td>CAN控制器局域网</td>
<td>cec</td>
<td>消费电子单元</td>
</tr>
<tr>
<td>crc</td>
<td>CRC计算单元</td>
<td>dac</td>
<td>D&#x2F;A转换器</td>
</tr>
<tr>
<td>dbgmc</td>
<td>MCU调试模块</td>
<td>dma</td>
<td>DMA控制器</td>
</tr>
<tr>
<td>exti</td>
<td>外部中断寄存器</td>
<td>flash</td>
<td>闪存</td>
</tr>
<tr>
<td>fsmc</td>
<td>灵活的静态存储器控制器</td>
<td>gpio</td>
<td>通用I&#x2F;O接口</td>
</tr>
<tr>
<td>i2c</td>
<td>I²C总线接口</td>
<td>iwdg</td>
<td>独立看门狗</td>
</tr>
<tr>
<td>pwr</td>
<td>电源控制</td>
<td>rcc</td>
<td>复位和时钟控制器</td>
</tr>
<tr>
<td>rtc</td>
<td>实时时钟</td>
<td>sdio</td>
<td>SD存储卡接口</td>
</tr>
<tr>
<td>spi</td>
<td>SPI串行外设接口</td>
<td>tim</td>
<td>定时器</td>
</tr>
<tr>
<td>usart</td>
<td>通用同步异步收发器</td>
<td>wwdg</td>
<td>窗口看门狗</td>
</tr>
</tbody></table>
<h3 id="4-2-STM32微控制器开发"><a href="#4-2-STM32微控制器开发" class="headerlink" title="4.2 STM32微控制器开发"></a>4.2 STM32微控制器开发</h3><h4 id="4-2-3-C语言应用"><a href="#4-2-3-C语言应用" class="headerlink" title="4.2.3 C语言应用"></a>4.2.3 C语言应用</h4><h5 id="2-C语言的位操作"><a href="#2-C语言的位操作" class="headerlink" title="2. C语言的位操作"></a>2. C语言的位操作</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>) <span class="comment">//位与实现复位:将整形变量a的D6位清零，其他位不变。</span></span><br><span class="line">a |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) <span class="comment">// 位或实现置位:将整形变量a的D6位置位，其他位不变。</span></span><br><span class="line">a ^= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) <span class="comment">// 位异或实现求反：将整形变量a的D6位取反，其他位不变</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-复位与时钟控制-RCC"><a href="#4-3-复位与时钟控制-RCC" class="headerlink" title="4.3 复位与时钟控制(RCC)"></a>4.3 复位与时钟控制(RCC)</h3><h5 id="1-电源控制"><a href="#1-电源控制" class="headerlink" title="1. 电源控制"></a>1. 电源控制</h5><p>3种低功耗模式</p>
<ul>
<li><p>睡眠模式(Sleep Mode)</p>
</li>
<li><p>停止模式(Stop Mode)</p>
</li>
<li><p>备用模式(Standby Mode)</p>
</li>
</ul>
<h5 id="2-复位"><a href="#2-复位" class="headerlink" title="2. 复位"></a>2. 复位</h5><p>三种复位：系统复位、电源复位和备份复位</p>
<h5 id="3-时钟树"><a href="#3-时钟树" class="headerlink" title="3. 时钟树"></a>3. 时钟树</h5><p>系统时钟 SYSCLK</p>
<p>内部高速时钟HIS、高速外部时钟HSE和锁相环PLL</p>
<h2 id="第五章-STM32的通用I-x2F-O端口"><a href="#第五章-STM32的通用I-x2F-O端口" class="headerlink" title="第五章 STM32的通用I&#x2F;O端口"></a>第五章 STM32的通用I&#x2F;O端口</h2><h3 id="5-1-GPIO的结构和功能"><a href="#5-1-GPIO的结构和功能" class="headerlink" title="5.1 GPIO的结构和功能"></a>5.1 GPIO的结构和功能</h3><p>GPIO一共112个引脚，用GPIOx(x是A、B、C、D、E、F、G)表示，即GPIOA GPIOB … GPIOG。每组端口有16个外设引脚，分别用Px0,Px1,…Px15(x是A~G)表示。</p>
<h5 id="1-输入模式"><a href="#1-输入模式" class="headerlink" title="1.输入模式"></a>1.输入模式</h5><p>4种输入模式：</p>
<ul>
<li>模拟输入模式(Analog): 不上拉也不下拉</li>
<li>浮空输入模式(Input Floating): 不上拉也不下拉 </li>
<li>上拉输入模式(Input Pull-up): 接上拉电阻</li>
<li>下拉输入模式(Input Pull-down): 接下拉电阻</li>
</ul>
<h5 id="2-输出模式"><a href="#2-输出模式" class="headerlink" title="2. 输出模式"></a>2. 输出模式</h5><p>4中输出模式，但是常用以下两种输出模式:</p>
<ul>
<li><p>推挽输出(Output Push-Pull)</p>
</li>
<li><p>开漏输出(Output Open-Drain)</p>
</li>
</ul>
<h3 id="5-3-GPIO-案例"><a href="#5-3-GPIO-案例" class="headerlink" title="5.3 GPIO 案例"></a>5.3 GPIO 案例</h3><h4 id="5-3-2-应用程序分析"><a href="#5-3-2-应用程序分析" class="headerlink" title="5.3.2 应用程序分析"></a>5.3.2 应用程序分析</h4><h5 id="1-开启外设时钟"><a href="#1-开启外设时钟" class="headerlink" title="1. 开启外设时钟"></a>1. 开启外设时钟</h5><h5 id="2-初始化外设"><a href="#2-初始化外设" class="headerlink" title="2. 初始化外设"></a>2. 初始化外设</h5><h5 id="3-控制外设工作"><a href="#3-控制外设工作" class="headerlink" title="3. 控制外设工作"></a>3. 控制外设工作</h5><h4 id="5-3-3-实例代码"><a href="#5-3-3-实例代码" class="headerlink" title="5.3.3 实例代码"></a>5.3.3 实例代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOB，GPIO_PIN_5，GPIO_PIN_RESET)；</span><br><span class="line"><span class="comment">// PB5引脚输出低电平，LED0灯亮</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5,GPIO_PIN_SET);</span><br><span class="line"><span class="comment">// PE5 引脚输出高电平，LED1灯灭</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>) <span class="comment">//持续1秒</span></span><br><span class="line"></span><br><span class="line">HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5);</span><br><span class="line"><span class="comment">// 读取PC5引脚的电平状态</span></span><br><span class="line"></span><br><span class="line">HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_3);</span><br><span class="line"><span class="comment">// 反转 PE3 引脚的电平状态</span></span><br></pre></td></tr></table></figure>


<h2 id="第六章-CM3异常和STM32中断"><a href="#第六章-CM3异常和STM32中断" class="headerlink" title="第六章 CM3异常和STM32中断"></a>第六章 CM3异常和STM32中断</h2><h3 id="6-1-Cortex-M3-的异常"><a href="#6-1-Cortex-M3-的异常" class="headerlink" title="6.1 Cortex-M3 的异常"></a>6.1 Cortex-M3 的异常</h3><h5 id="2-异常优先级"><a href="#2-异常优先级" class="headerlink" title="2.异常优先级"></a>2.异常优先级</h5><p>优先级的数值越小，优先级越高</p>
<p>组优先级（Group Priority）和子优先级(Sub-Priority)。组优先级被称为抢占优先级。</p>
<p>组优先级确定是否可以打断正在执行的中断，实现嵌套。子优先级只用于在相同组优先级时多个子优先级同时出现的情况，高优先级别（优先级数值小）的异常首先被处理。</p>
<h5 id="3-嵌套向量中断控制器NVIC"><a href="#3-嵌套向量中断控制器NVIC" class="headerlink" title="3. 嵌套向量中断控制器NVIC"></a>3. 嵌套向量中断控制器NVIC</h5><p>NVIC 集成在 ARM Cortex-M3 内核中</p>
<h3 id="6-2-STM32的中断应用"><a href="#6-2-STM32的中断应用" class="headerlink" title="6.2 STM32的中断应用"></a>6.2 STM32的中断应用</h3><h4 id="6-2-1-NVIC-初始化配置"><a href="#6-2-1-NVIC-初始化配置" class="headerlink" title="6.2.1 NVIC 初始化配置"></a>6.2.1 NVIC 初始化配置</h4><h5 id="1-配置组优先级"><a href="#1-配置组优先级" class="headerlink" title="1. 配置组优先级"></a>1. 配置组优先级</h5><img src = "./8.png">

<h4 id="6-2-2-外部中断EXTI"><a href="#6-2-2-外部中断EXTI" class="headerlink" title="6.2.2 外部中断EXTI"></a>6.2.2 外部中断EXTI</h4><p>STM32 芯片外设的中断请求直接连接到 NVIC，来自芯片之外的外设中断请求需要通过EXTI（外部中断&#x2F;事件控制器）连接到NVIC。</p>
<h5 id="2-EXTI-寄存器"><a href="#2-EXTI-寄存器" class="headerlink" title="2. EXTI 寄存器"></a>2. EXTI 寄存器</h5><img src = "./9.png">

<img src = "./10.png">

<h2 id="第七章-STM32-的串行通信接口"><a href="#第七章-STM32-的串行通信接口" class="headerlink" title="第七章 STM32 的串行通信接口"></a>第七章 STM32 的串行通信接口</h2><h3 id="7-1-串行异步通信"><a href="#7-1-串行异步通信" class="headerlink" title="7.1 串行异步通信"></a>7.1 串行异步通信</h3><p>串行通信有两类：<strong>一类</strong>是速度较快的同步串行通信，以数据块为基本传输单位，主要应用于网络连接；<strong>另一类</strong>是速度较慢的异步通信，以字符为单位传输，主要应用于近距离通信。通常所说的串行通信一般是指<strong>串行同步通信</strong></p>
<h4 id="7-1-1-串行异步通信字符格式"><a href="#7-1-1-串行异步通信字符格式" class="headerlink" title="7.1.1 串行异步通信字符格式"></a>7.1.1 串行异步通信字符格式</h4><img src = "./11.png">

<ul>
<li><p>起始位(Start Bit): 采取逻辑 0 电平</p>
</li>
<li><p>数据位(Data Bit): 一般是8位</p>
</li>
<li><p>校验位(Parity Bit): 可有可无，一般是奇偶校验位</p>
</li>
<li><p>停止位(Stop Bit): 字符最后必须有停止位，采取逻辑1电平</p>
</li>
</ul>
<p>通信传输速率要相同，如9600bps表示一秒传输9600位</p>
<h4 id="7-1-2-串行异步通信接口"><a href="#7-1-2-串行异步通信接口" class="headerlink" title="7.1.2 串行异步通信接口"></a>7.1.2 串行异步通信接口</h4><h5 id="1-RS-232标准的引脚定义"><a href="#1-RS-232标准的引脚定义" class="headerlink" title="1. RS-232标准的引脚定义"></a>1. RS-232标准的引脚定义</h5><ul>
<li>TxD(Transmitted Data,发送数据)</li>
<li>RxD(Received Data, 接收数据)</li>
<li>RTS(Request To Send，请求发送)</li>
<li>CTS(Clear To Send，清除发送)</li>
<li>DTR(Data Terminal Ready，数据终端准备好)</li>
<li>DSR(Data Set Ready，数据装置准备好)</li>
<li>GND(Ground，信号地)</li>
<li>CD(Carrier Detected，载波检测)</li>
<li>RI(RIng Indicator，振铃指示)</li>
</ul>
<h5 id="2-RS-232接口的连接"><a href="#2-RS-232接口的连接" class="headerlink" title="2. RS-232接口的连接"></a>2. RS-232接口的连接</h5><p>三线相连</p>
<img src = "./12.png">

<h3 id="7-2-通用同步-x2F-异步接收-x2F-发送器"><a href="#7-2-通用同步-x2F-异步接收-x2F-发送器" class="headerlink" title="7.2 通用同步&#x2F;异步接收&#x2F;发送器"></a>7.2 通用同步&#x2F;异步接收&#x2F;发送器</h3><p>通用同步&#x2F;异步接收&#x2F;发送器（USART）和通用异步接收&#x2F;发送器(UART)</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式复习</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习_结构体</title>
    <url>/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="Go语言基础之结构体"><a href="#Go语言基础之结构体" class="headerlink" title="Go语言基础之结构体"></a>Go语言基础之结构体</h1><h2 id="一、类型别名和自定义类型"><a href="#一、类型别名和自定义类型" class="headerlink" title="一、类型别名和自定义类型"></a>一、类型别名和自定义类型</h2><h3 id="1-1-自定义类型"><a href="#1-1-自定义类型" class="headerlink" title="1.1 自定义类型"></a>1.1 自定义类型</h3><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p>
<span id="more"></span>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>通过<code>type</code>关键字，<code>MyInt</code>就是一种新的类型，它具有 <code>int</code> 的特性。</p>
<h3 id="1-2-类型别名"><a href="#1-2-类型别名" class="headerlink" title="1.2 类型别名"></a>1.2 类型别名</h3><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure>

<h3 id="1-3-类型定义和类型别名的区别"><a href="#1-3-类型定义和类型别名的区别" class="headerlink" title="1.3 类型定义和类型别名的区别"></a>1.3 类型定义和类型别名的区别</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a NewInt</span><br><span class="line">    <span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a: main.NewInt</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b: int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、结构体"><a href="#二、结构体" class="headerlink" title="二、结构体"></a>二、结构体</h2><p>Go语言中通过<code>struct</code>来实现面向对象。</p>
<h3 id="2-1-结构体的定义"><a href="#2-1-结构体的定义" class="headerlink" title="2.1 结构体的定义"></a>2.1 结构体的定义</h3><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型。</li>
</ul>
<h3 id="2-2-结构体实例化"><a href="#2-2-结构体实例化" class="headerlink" title="2.2 结构体实例化"></a>2.2 结构体实例化</h3><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure>

<h4 id="1-基本实例化"><a href="#1-基本实例化" class="headerlink" title="1) 基本实例化"></a>1) 基本实例化</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">    age <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 person</span><br><span class="line">    p1.name = <span class="string">&quot;结构体&quot;</span></span><br><span class="line">    p1.age = <span class="number">23</span></span><br><span class="line">    p1.city = <span class="string">&quot;网络&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过<code>.</code>来访问结构体的字段（成员变量），例如 <code>p1.name</code>和<code>p1.age</code>等。</p>
<h4 id="2-匿名结构体"><a href="#2-匿名结构体" class="headerlink" title="2) 匿名结构体"></a>2) 匿名结构体</h4><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> usr <span class="keyword">struct</span>&#123;Name <span class="type">string</span>; Age <span class="type">int</span>&#125;</span><br><span class="line">    usr.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">    usr.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, usr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建指针类型结构体"><a href="#3-创建指针类型结构体" class="headerlink" title="3) 创建指针类型结构体"></a>3) 创建指针类型结构体</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">p2.age = <span class="number">18</span></span><br><span class="line">p2.city = <span class="string">&quot;上海&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p2)</span><br></pre></td></tr></table></figure>

<h4 id="4-取结构体的地址实例化"><a href="#4-取结构体的地址实例化" class="headerlink" title="4) 取结构体的地址实例化"></a>4) 取结构体的地址实例化</h4><p>使用 <code>&amp;</code> 对结构体进行取地址操作相当于对该结构体类型进行了一次 <code>new</code> 实例化操作。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3) <span class="comment">// *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">// p3=&amp;main.person&#123;name:&quot;&quot;,city:&quot;&quot;,age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;demo&quot;</span></span><br><span class="line">p3.city = <span class="string">&quot;awa&quot;</span></span><br><span class="line">p3.age = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">// p3=&amp;main.person&#123;name:&quot;demo&quot;,city:&quot;awa&quot;,age:10&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-结构体初始化"><a href="#2-3-结构体初始化" class="headerlink" title="2.3 结构体初始化"></a>2.3 结构体初始化</h3><h4 id="1-使用键值对初始化"><a href="#1-使用键值对初始化" class="headerlink" title="1) 使用键值对初始化"></a>1) 使用键值对初始化</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">p3 := person&#123;</span><br><span class="line">    name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对结构体指针进行键值对初始化</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">    name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用值的列表初始化"><a href="#2-使用值的列表初始化" class="headerlink" title="2) 使用值的列表初始化"></a>2) 使用值的列表初始化</h4><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">    <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="number">28</span></span><br><span class="line">&#125;</span><br><span class="line">使用这种格式初始化时，需要注意：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 必须初始化结构体的所有字段。</span><br><span class="line"><span class="number">2.</span> 初始值的填充顺序必须与字段在结构体中的声明顺序一致。</span><br><span class="line"><span class="number">3.</span> 该方式不能和键值初始化方式混用。</span><br></pre></td></tr></table></figure>

<h3 id="2-4-结构体内存布局"><a href="#2-4-结构体内存布局" class="headerlink" title="2.4 结构体内存布局"></a>2.4 结构体内存布局</h3><p>结构体占用一块连续的内存</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int8</span></span><br><span class="line">    b <span class="type">int8</span></span><br><span class="line">    c <span class="type">int8</span></span><br><span class="line">    d <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">n</span>.a <span class="number">0</span>x0000a0060</span><br><span class="line"><span class="attribute">n</span>.b <span class="number">0</span>x0000a0061</span><br><span class="line"><span class="attribute">n</span>.c <span class="number">0</span>x0000a0062</span><br><span class="line"><span class="attribute">n</span>.d <span class="number">0</span>x0000a0063</span><br></pre></td></tr></table></figure>

<h4 id="1-空结构体"><a href="#1-空结构体" class="headerlink" title="1) 空结构体"></a>1) 空结构体</h4><p>空结构体不占用空间。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v)) <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-构造函数"><a href="#2-5-构造函数" class="headerlink" title="2.5 构造函数"></a>2.5 构造函数</h3><p>Go语言的结构体没有构造函数，我们可以自己实现。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *person &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用构造函数</span></span><br><span class="line">p9 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;沙河&quot;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-方法和接收者"><a href="#2-6-方法和接收者" class="headerlink" title="2.6 方法和接收者"></a>2.6 方法和接收者</h3><p>Go语言中的<code>方法(Method)</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者(Receiver)</code>。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收者变量：接收者中的参数变量在命名时，官方建议使用接收者类型名称首字母小写，而不是self、this之类的命名。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name stirng, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dream Person 做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言\n&quot;</span>,&amp;p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法与函数不同的是，函数不属于任何类型，方法属于特定的类型。</p>
<h4 id="1）指针类型的接收者"><a href="#1）指针类型的接收者" class="headerlink" title="1）指针类型的接收者"></a>1）指针类型的接收者</h4><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该方法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1.SetAge(<span class="number">20</span>)</span><br><span class="line">    fmt.Pritnln(p1.age) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）值类型的接收者"><a href="#2）值类型的接收者" class="headerlink" title="2）值类型的接收者"></a>2）值类型的接收者</h4><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetAge2(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1.SetAge2(<span class="number">20</span>) <span class="comment">// (*p1).SetAge2(20)</span></span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）什么时候需要使用指针类型接收者"><a href="#3）什么时候需要使用指针类型接收者" class="headerlink" title="3）什么时候需要使用指针类型接收者"></a>3）什么时候需要使用指针类型接收者</h4><ol>
<li><p>需要修改接收者中的值</p>
</li>
<li><p>接收者是拷贝代价较大的大对象</p>
</li>
<li><p>保证一致性，如果有某个方法使用了指针接收者，那么其他方法夜应该使用指针接收者。</p>
</li>
</ol>
<h3 id="2-7-任意类型添加方法"><a href="#2-7-任意类型添加方法" class="headerlink" title="2.7 任意类型添加方法"></a>2.7 任意类型添加方法</h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span></span> SayHello() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, 我是一个int&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m1 MyInt</span><br><span class="line">    m1.SayHello()</span><br><span class="line">    m1 = <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v %T\n&quot;</span>, m1, m1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-结构体的匿名字段"><a href="#2-8-结构体的匿名字段" class="headerlink" title="2.8 结构体的匿名字段"></a>2.8 结构体的匿名字段</h3><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段被称为匿名字段。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        <span class="string">&quot;小王&quot;</span>,</span><br><span class="line">        <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于结构体要求字段名称必须唯一，因此一个结构体中同类型的匿名字段只能有一个。</p>
<h3 id="2-9-嵌套结构体"><a href="#2-9-嵌套结构体" class="headerlink" title="2.9 嵌套结构体"></a>2.9 嵌套结构体</h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="type">string</span></span><br><span class="line">    City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Gender <span class="type">string</span></span><br><span class="line">    Address Address</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user1 := User&#123;</span><br><span class="line">        Name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">        Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">            City: <span class="string">&quot;威海&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)</span><br><span class="line"><span class="comment">//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1）嵌套匿名字段"><a href="#1）嵌套匿名字段" class="headerlink" title="1）嵌套匿名字段"></a>1）嵌套匿名字段</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="type">string</span></span><br><span class="line">    City <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Gender <span class="type">string</span></span><br><span class="line">    Address <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user2 User</span><br><span class="line">    user2.Name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    user2.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">    user2.Address.Province = <span class="string">&quot;山东&quot;</span> <span class="comment">/// 匿名字段默认使用类型名作为字段名</span></span><br><span class="line">    user2.City = <span class="string">&quot;威海&quot;</span>  <span class="comment">// 匿名字段可以省略</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;user2=%v\n&quot;</span>, user2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）-嵌套结构体的字段名冲突"><a href="#2）-嵌套结构体的字段名冲突" class="headerlink" title="2） 嵌套结构体的字段名冲突"></a>2） 嵌套结构体的字段名冲突</h4><p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="type">string</span></span><br><span class="line">    City <span class="type">string</span></span><br><span class="line">    CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account <span class="type">string</span></span><br><span class="line">    CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Gender <span class="type">string</span></span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user3 User</span><br><span class="line">    user3.Name = <span class="string">&quot;李四&quot;</span></span><br><span class="line">    user3.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">    user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">// 指定Address结构体中的CreateTIme</span></span><br><span class="line">    user3.Email.CreateTime = <span class="string">&quot;2010&quot;</span> <span class="comment">// 指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-结构体的”继承”"><a href="#2-10-结构体的”继承”" class="headerlink" title="2.10 结构体的”继承”"></a>2.10 结构体的”继承”</h3><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动 \n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet <span class="type">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang()</span><br><span class="line">    d1.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-11-结构体字段的可见性"><a href="#2-11-结构体字段的可见性" class="headerlink" title="2.11 结构体字段的可见性"></a>2.11 结构体字段的可见性</h3><p>结构体中字段大写开头表示可公开访问，小写表示私有(仅在定义当前结构体的包中可以访问)</p>
<h3 id="2-12-结构体与JSON序列化"><a href="#2-12-结构体与JSON序列化" class="headerlink" title="2.12 结构体与JSON序列化"></a>2.12 结构体与JSON序列化</h3><p>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键&#x2F;值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">    Gender <span class="type">string</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title <span class="type">string</span></span><br><span class="line">    Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := &amp;Class&#123;</span><br><span class="line">        Title: <span class="string">&quot;101&quot;</span>,</span><br><span class="line">        Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        stu := &amp;Student&#123;</span><br><span class="line">            Name: fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">            Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">            ID: i,</span><br><span class="line">        &#125;</span><br><span class="line">        c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// JSON序列化: 结构体--&gt;JSON格式的字符串</span></span><br><span class="line">    data, err := json.Marshal(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line">    <span class="comment">// JSON反序列化: JSON格式的字符串 --&gt; 结构体</span></span><br><span class="line">    str := <span class="string">`&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">    c1 := &amp;Class&#123;&#125;</span><br><span class="line">	err = json.Unmarshal([]<span class="type">byte</span>(str), c1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-13-结构体标签-Tag"><a href="#2-13-结构体标签-Tag" class="headerlink" title="2.13 结构体标签(Tag)"></a>2.13 结构体标签(Tag)</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span></span><br></pre></td></tr></table></figure>
<p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p>
<p>注意事项: 为结构体编写<code>Tag</code>时，必须严格遵循键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="type">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">	Gender <span class="type">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">	name   <span class="type">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		name:   <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(s1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a>结构体和方法补充知识点</h3><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int8</span></span><br><span class="line">    dreams []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetDreams(dreams []<span class="type">string</span>) &#123;</span><br><span class="line">    p.dreams = dreams</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p1 := Person&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>&#125;</span><br><span class="line">    p1.SetDreams(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你真的想要修改 p1.dreams吗</span></span><br><span class="line">    data[<span class="number">1</span>] = <span class="string">&quot;不睡觉&quot;</span></span><br><span class="line">    fmt.Println(p1.dreams) <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetDreams(dreams []<span class="type">string</span>) &#123;</span><br><span class="line">    p.dreams = <span class="built_in">make</span>([] <span class="type">string</span>, <span class="built_in">len</span>(dreams))</span><br><span class="line">    <span class="built_in">copy</span>(p.dreams, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>结构体</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title>近代史</title>
    <url>/2023/06/15/%E8%BF%91%E4%BB%A3%E5%8F%B2/</url>
    <content><![CDATA[<h1 id="第一章-进入近代后中华民族的磨难与抗争"><a href="#第一章-进入近代后中华民族的磨难与抗争" class="headerlink" title="第一章 进入近代后中华民族的磨难与抗争"></a>第一章 进入近代后中华民族的磨难与抗争</h1><span id="more"></span>
<h2 id="第二节、西方列强对中国的侵略"><a href="#第二节、西方列强对中国的侵略" class="headerlink" title="第二节、西方列强对中国的侵略"></a>第二节、西方列强对中国的侵略</h2><h3 id="二、政治控制的三个方面"><a href="#二、政治控制的三个方面" class="headerlink" title="二、政治控制的三个方面"></a>二、政治控制的三个方面</h3><h4 id="一、控制中国的内政、外交"><a href="#一、控制中国的内政、外交" class="headerlink" title="一、控制中国的内政、外交"></a>一、控制中国的内政、外交</h4><p>《天津条约》，允许外国公使常驻北京。外国公使可以在北京直接向中国政府发号施令</p>
<p>资本-帝国主义列强在中国享有领事裁判权</p>
<p><strong>把持中国海关</strong>，是外国侵略者控制中国政治的重要手段之一。</p>
<h4 id="二、镇压中国人民的反抗"><a href="#二、镇压中国人民的反抗" class="headerlink" title="二、镇压中国人民的反抗"></a>二、镇压中国人民的反抗</h4><h4 id="三、扶植、收买代理人"><a href="#三、扶植、收买代理人" class="headerlink" title="三、扶植、收买代理人"></a>三、扶植、收买代理人</h4><p>奕䜣、文祥。曾国潘、李鸿章；清王朝最高统治者慈禧太后；袁世凯</p>
<h3 id="三、经济掠夺"><a href="#三、经济掠夺" class="headerlink" title="三、经济掠夺"></a>三、经济掠夺</h3><h4 id="一、控制中国的通商口岸"><a href="#一、控制中国的通商口岸" class="headerlink" title="一、控制中国的通商口岸"></a>一、控制中国的通商口岸</h4><p>《南京条约》规定，开放广州、厦门、福州、宁波、上海5个港口城市为通商口岸。</p>
<h4 id="二、剥夺中国的关税自主权"><a href="#二、剥夺中国的关税自主权" class="headerlink" title="二、剥夺中国的关税自主权"></a>二、剥夺中国的关税自主权</h4><p>其商品不需要重新课税；控制了中国海关的行政权</p>
<h4 id="三、实行商品倾销和资本输出"><a href="#三、实行商品倾销和资本输出" class="headerlink" title="三、实行商品倾销和资本输出"></a>三、实行商品倾销和资本输出</h4><p>中国的对外贸易，从长期出超逐渐转变为大量入超（低于市场价）</p>
<h2 id="单选：由于《马关条约》规定允许外国人在中国办工厂"><a href="#单选：由于《马关条约》规定允许外国人在中国办工厂" class="headerlink" title="单选：由于《马关条约》规定允许外国人在中国办工厂"></a>单选：由于《马关条约》规定允许外国人在中国办工厂</h2><h4 id="四、操纵中国的经济命脉"><a href="#四、操纵中国的经济命脉" class="headerlink" title="四、操纵中国的经济命脉"></a>四、操纵中国的经济命脉</h4><p>近代工业，外国资本很快形成了垄断低位。</p>
<p>中国政府举借外债，主要是以关税和盐税为担保的</p>
<p>中国开设的第一家银行，英国丽如银行。</p>
<p>中国被纳入资本主义的世界经济体系，成了西方大国的经济附庸</p>
<h2 id="第三节-反抗外国武装侵略的斗争"><a href="#第三节-反抗外国武装侵略的斗争" class="headerlink" title="第三节 反抗外国武装侵略的斗争"></a>第三节 反抗外国武装侵略的斗争</h2><h3 id="一、抵御外来侵略的斗争历程"><a href="#一、抵御外来侵略的斗争历程" class="headerlink" title="一、抵御外来侵略的斗争历程"></a>一、抵御外来侵略的斗争历程</h3><p>三元里人民的抗英战争，是中国近代史上中国人民<strong>第一次</strong>大规模的反侵略武装斗争</p>
<h3 id="二、义和团运动与列强瓜分中国图谋的破产"><a href="#二、义和团运动与列强瓜分中国图谋的破产" class="headerlink" title="二、义和团运动与列强瓜分中国图谋的破产"></a>二、义和团运动与列强瓜分中国图谋的破产</h3><h4 id="列强瓜分中国图谋的破产"><a href="#列强瓜分中国图谋的破产" class="headerlink" title="列强瓜分中国图谋的破产"></a>列强瓜分中国图谋的破产</h4><p>帝国注意列强之间的矛盾和互相制约；是中华民族进行不屈不挠的反侵略斗争</p>
<p>消极：义和团存在排外主义的错误，曾蒙受封建统治者的欺骗，小生产者的局限性</p>
<p>积极：义和团运动在粉碎帝国主义列强瓜分中国的斗争中，发挥了重大的历史作用</p>
<h2 id="第四节-反侵略斗争的"><a href="#第四节-反侵略斗争的" class="headerlink" title="第四节 反侵略斗争的"></a>第四节 反侵略斗争的</h2><h3 id="一、反侵略战争的失败及其原因"><a href="#一、反侵略战争的失败及其原因" class="headerlink" title="一、反侵略战争的失败及其原因"></a>一、反侵略战争的失败及其原因</h3><p>根本原因：社会制度的腐败；重要原因：经济技术的落后；</p>
<h3 id="二、民族意识的觉醒"><a href="#二、民族意识的觉醒" class="headerlink" title="二、民族意识的觉醒"></a>二、民族意识的觉醒</h3><p>中日甲午战争之后，中国人民的民族意识开始普遍觉醒。</p>
<p>林则徐是近代中国睁眼看世界的第一人。编写《四洲志》。</p>
<p>魏源编写《海国图志》【总结鸦片战争经验教训、论述海防战略战术的《筹海篇》，翻译西人论述的《夷情备采》及西洋科技船炮图说等】</p>
<p>提出“师夷长技以制夷”，主张学习外国现金的军事和科学技术，以期富国强兵，抵御外国侵略。</p>
<h4 id="救亡图存和振兴中华"><a href="#救亡图存和振兴中华" class="headerlink" title="救亡图存和振兴中华"></a>救亡图存和振兴中华</h4><p>梁启超、康有为，严复；</p>
<p>孙中山1894年11月创立了兴中会</p>
<p>中国近代史，是一部充满磨难、落后挨打的悲惨屈辱史，更是一部中华民族抵抗外来侵略、实现民族独立的伟大斗争史。</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="第一节-太平天国运动的起落"><a href="#第一节-太平天国运动的起落" class="headerlink" title="第一节 太平天国运动的起落"></a>第一节 太平天国运动的起落</h2><h3 id="一、太平天国农民战争"><a href="#一、太平天国农民战争" class="headerlink" title="一、太平天国农民战争"></a>一、太平天国农民战争</h3><h1 id="天朝田亩制度"><a href="#天朝田亩制度" class="headerlink" title="天朝田亩制度"></a>天朝田亩制度</h1><p>性质：《天朝田亩制度》实际上是一个以解决土地问题为中心的比较完整的社会改革方案</p>
<p>局限性：并没有超出农民小生产者的狭隘眼界，自给自足的自然经济；不切实际的空想性质；</p>
<h1 id="资政新篇"><a href="#资政新篇" class="headerlink" title="资政新篇"></a>资政新篇</h1><p>政治方面：主张“禁朋党之弊”，加强中央集权，并学习西方，制定法律，制度。</p>
<p>经济方面：主张发展近代工矿、交通等事业，奖励科技发明和机器制造</p>
<p>文化方面：建议设立新闻馆，提倡兴办学校、医院等</p>
<p>外交方面：主张同外国平等交往、自由通商，禁止鸦片输入。</p>
<p>性质：是一个具有资本主义色彩的方案</p>
<h4 id="天京事变"><a href="#天京事变" class="headerlink" title="天京事变"></a>天京事变</h4><p>影响：天京事变严重地削弱了太平天国的领导和军事力量，成为太平天国由盛转衰的分水岭。</p>
<h3 id="二、农民斗争的意义和局限"><a href="#二、农民斗争的意义和局限" class="headerlink" title="二、农民斗争的意义和局限"></a>二、农民斗争的意义和局限</h3><h4 id="太平天国农民起义的历史意义"><a href="#太平天国农民起义的历史意义" class="headerlink" title="太平天国农民起义的历史意义"></a>太平天国农民起义的历史意义</h4><p>① 打击了封建统治阶级，撼动了清王朝的统治</p>
<p>② 中国旧式农民战争的最高峰</p>
<p>③ 冲击了孔子和儒家经典的正统权威，削弱了封建统治的精神支柱</p>
<p>④ 打击了外国侵略势力</p>
<p>⑤ 在19世纪中叶的亚洲民族解放运动中，冲击了西方殖民主义者在亚洲的统治。</p>
<h4 id="太平天国农民起义失败的原因和教训"><a href="#太平天国农民起义失败的原因和教训" class="headerlink" title="太平天国农民起义失败的原因和教训"></a>太平天国农民起义失败的原因和教训</h4><p>无法克服小生产者所固有的阶级局限性，缺乏科学思想理论的指导，没有先进阶级的领导。</p>
<p>太平天国后期无法制止和克服领导集团自身腐败现象的滋生，</p>
<p>在军事战略上出现了重大失误</p>
<p>梦想以虚幻的力量代替农民起义者自身的努力</p>
<p>未能正确地对待儒学</p>
<p>对于西方资本注意侵略者还缺乏理性的认识。</p>
<p>在半殖民地半封建的中国，农民具有伟大的革命潜力，但它自身不能负担起领导反帝反封建斗争取得胜利的重任。单纯的农民战争不可能完成争取民族独立和人民解放的历史任务</p>
<h1 id="第三章-辛亥革命与君主专制制度的终结"><a href="#第三章-辛亥革命与君主专制制度的终结" class="headerlink" title="第三章 辛亥革命与君主专制制度的终结"></a>第三章 辛亥革命与君主专制制度的终结</h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><h3 id="资产阶级革命派的活动"><a href="#资产阶级革命派的活动" class="headerlink" title="资产阶级革命派的活动"></a>资产阶级革命派的活动</h3><h4 id="资产阶级革命派的宣传与组织工作"><a href="#资产阶级革命派的宣传与组织工作" class="headerlink" title="资产阶级革命派的宣传与组织工作"></a>资产阶级革命派的宣传与组织工作</h4><p>章炳麟发表《驳康有为论革命书》，中国人民完全有能力建立民主共和制度。</p>
<p>邹容写了《革命军》，号召建立“中华共和国”</p>
<p>陈天华《警世钟》《猛回头》 推翻清政府这个“洋人的朝廷”</p>
<p>1905年8月20日，孙中山在日本东京成立中国同盟会，以《民报》为机关报。这是近代中国第一个领导资产阶级革命的全国性政党。</p>
<p>成立的意义：标志着中国资产阶级民主革命进入了一个新的阶段。</p>
<h3 id="二、三民主义的提出"><a href="#二、三民主义的提出" class="headerlink" title="二、三民主义的提出"></a>二、三民主义的提出</h3><p>民族主义、民权主义、民生主义</p>
<h4 id="民族主义"><a href="#民族主义" class="headerlink" title="民族主义"></a>民族主义</h4><p>以革命的手段推翻清政府的统治，建立中华民族“独立的国家”</p>
<p>局限性：没有从正面鲜明地提出反对帝国主义的主张。</p>
<p>当时的革命派，害怕帝国主义的干涉，幻想承认不平等条约“继续有效”为条件来换取列强对自己的支持。</p>
<h4 id="民权主义"><a href="#民权主义" class="headerlink" title="民权主义"></a>民权主义</h4><p>创立民国，推翻封建君主专制制度，建立资产阶级民主共和国</p>
<p>政治革命的目的是建立民国</p>
<p>政治革命应当与民族革命并行</p>
<p>局限性：忽略了广大劳动群众在国家中的地位，因而难以使人民的民主权利得到真正的保证。</p>
<h4 id="民生主义"><a href="#民生主义" class="headerlink" title="民生主义"></a>民生主义</h4><p>平均地权是社会革命</p>
<p>局限性：没有正面触及封建土地所有制，不能满足广大农民的土地要求，在革命中难以成为发动广大工农群众的理论武器</p>
<p>三民主义的性质：是一个比较完整而明确的资产阶级民主革命纲领</p>
<p>历史意义：对推动革命的发展产生了重大而积极的影响。</p>
<h3 id="四、关于革命与改良的辩论"><a href="#四、关于革命与改良的辩论" class="headerlink" title="四、关于革命与改良的辩论"></a>四、关于革命与改良的辩论</h3><h4 id="要不要以革命手段推翻清王朝"><a href="#要不要以革命手段推翻清王朝" class="headerlink" title="要不要以革命手段推翻清王朝"></a>要不要以革命手段推翻清王朝</h4><h4 id="要不要推翻帝制，实行共和"><a href="#要不要推翻帝制，实行共和" class="headerlink" title="要不要推翻帝制，实行共和"></a>要不要推翻帝制，实行共和</h4><h4 id="要不要进行社会革命"><a href="#要不要进行社会革命" class="headerlink" title="要不要进行社会革命"></a>要不要进行社会革命</h4><p>意义：划清了革命与改良的界限，传播了民主革命思想，促进了革命形式的发展。</p>
<p>局限性：这场论战暴露了革命派在思想理论方面的弱点，</p>
<h2 id="第二节-辛亥革命"><a href="#第二节-辛亥革命" class="headerlink" title="第二节 辛亥革命"></a>第二节 辛亥革命</h2><h3 id="中华民国的建立"><a href="#中华民国的建立" class="headerlink" title="中华民国的建立"></a>中华民国的建立</h3><h1 id="辛亥革命的历史意义"><a href="#辛亥革命的历史意义" class="headerlink" title="辛亥革命的历史意义"></a>辛亥革命的历史意义</h1><p>一、辛亥革命推翻了封建势力的政治代表、帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力。</p>
<p>二、辛亥革命结束了中国延续两千多年的封建君主专制制度</p>
<p>三、辛亥革命推动了人民思想的解放</p>
<p>四、推动了中国的社会变革，促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化。</p>
<p>五、在一定程度上打击了帝国主义的侵略势力。</p>
<h1 id="第四章-中国共产党成立"><a href="#第四章-中国共产党成立" class="headerlink" title="第四章 中国共产党成立"></a>第四章 中国共产党成立</h1><h2 id="第一节-新文化运动和五四运动"><a href="#第一节-新文化运动和五四运动" class="headerlink" title="第一节 新文化运动和五四运动"></a>第一节 新文化运动和五四运动</h2><h3 id="五四运动"><a href="#五四运动" class="headerlink" title="五四运动"></a>五四运动</h3><h4 id="五四运动的爆发"><a href="#五四运动的爆发" class="headerlink" title="五四运动的爆发"></a>五四运动的爆发</h4><p>首先，是新的社会力量的成长、壮大。五四运动获得了比以往革命斗争更加广泛的群众基础</p>
<p>其次，是新文化运动掀起的思想解放的潮流。具有初步共产主义思想的知识分子是最初的群众队伍和骨干力量</p>
<p>最后，是俄国十月革命对中国的影响。</p>
<p>直接导火索：巴黎和会上中国外交的失败</p>
<p>中国工人阶级开始以独立的姿态登上政治舞台。斗争的主力由学生转向了工人，运动的中心由北京转到了上海。</p>
<p>中国政府代表没有出席巴黎合约签字仪式。</p>
<h1 id="五四运动的历史特点和意义"><a href="#五四运动的历史特点和意义" class="headerlink" title="五四运动的历史特点和意义"></a>五四运动的历史特点和意义</h1><p>特点：彻底反帝反封建的伟大爱国革命运动，是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动，是一场传播新思想新文化新知识的伟大思想启蒙运动和新文化运动</p>
<p>意义：是中国旧民主注意革命走向新民主注意革命的转折点，具有里程碑的意义。即它以彻底反帝反封建的革命性、追求救国强国真理的进步性、各族各界群众积极参与的广泛性，推动了中国社会进步，促进了马克思主义在中国的传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立做了思想上干部上的准备，为新的革命力量、革命文化、革命斗争登上历史舞台创造了条件。其核心是爱国主义，它改变了以往只有觉悟的革命者而缺少觉醒的人民大众的斗争状况，实现了中国人民和中华民族自鸦片战争以来的第一次全面觉醒。五四运动以全民族的搏击培育了永久奋斗的伟大传统。</p>
<h2 id="第三节-中国革命的新局面"><a href="#第三节-中国革命的新局面" class="headerlink" title="第三节 中国革命的新局面"></a>第三节 中国革命的新局面</h2><p>中国共产党成立的历史特点：具有完整的科学世界观和社会革命论的马克思主义。具有坚强的革命性。</p>
<h1 id="中国共产党成立的历史意义"><a href="#中国共产党成立的历史意义" class="headerlink" title="中国共产党成立的历史意义"></a>中国共产党成立的历史意义</h1><p>是一场开天辟地的大事变</p>
<p>一、从根本上改变了近代以后中国人民的反帝反封建斗争之所以屡次挫折和失败的这种局面。</p>
<p>二、肩负起实现中华民族伟大复兴的历史使命</p>
<p>三、中国共产党的先驱们创建了中国共产党，形成了伟大建党精神，这是中国共产党的精神之源。</p>
<p>四、中国共产党的成立，深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局。</p>
<h2 id="第三节-中国革命的新局面-1"><a href="#第三节-中国革命的新局面-1" class="headerlink" title="第三节 中国革命的新局面"></a>第三节 中国革命的新局面</h2><h3 id="一、民主革命纲领的制定和工农运动的发动"><a href="#一、民主革命纲领的制定和工农运动的发动" class="headerlink" title="一、民主革命纲领的制定和工农运动的发动"></a>一、民主革命纲领的制定和工农运动的发动</h3><h4 id="民主革命纲领的制定"><a href="#民主革命纲领的制定" class="headerlink" title="民主革命纲领的制定"></a>民主革命纲领的制定</h4><p>中共二大第一次提出了反帝反封建的民主革命纲领</p>
<p>党的最高纲领是实现社会主义、共产主义</p>
<p>最低纲领：打倒军阀；推翻国际帝国主义的压迫：统一中国为真正民主共和国</p>
<h4 id="工农运动的发动"><a href="#工农运动的发动" class="headerlink" title="工农运动的发动"></a>工农运动的发动</h4><p>浙江萧山县衙前村成立了中国第一个农民协会</p>
<h1 id="第五章-中国革命的新道路"><a href="#第五章-中国革命的新道路" class="headerlink" title="第五章 中国革命的新道路"></a>第五章 中国革命的新道路</h1><h2 id="第一节-中国共产党对革命新道路的探索"><a href="#第一节-中国共产党对革命新道路的探索" class="headerlink" title="第一节 中国共产党对革命新道路的探索"></a>第一节 中国共产党对革命新道路的探索</h2><h3 id="土地革命战争的兴起（1927-8-1937-7）"><a href="#土地革命战争的兴起（1927-8-1937-7）" class="headerlink" title="土地革命战争的兴起（1927.8~1937.7）"></a>土地革命战争的兴起（1927.8~1937.7）</h3><h4 id="开展武装反抗国民党反动统治的斗争"><a href="#开展武装反抗国民党反动统治的斗争" class="headerlink" title="开展武装反抗国民党反动统治的斗争"></a>开展武装反抗国民党反动统治的斗争</h4><p>1927年7月中旬，中共中央政治局临时常委会决定了三件大事：</p>
<p>准备起义，发动秋收起义，召开紧急会议（八七会议），确定了土地革命和武装起义的方针</p>
<p>八七会议历史意义：给正处在思想混乱和组织涣散中的中国共产党指明了新的出路，这是由大革命失败到土地革命战争兴起的历史性转变。</p>
<p>1927年8月1日，在南昌打响了武装反抗国民党反动派的第一枪，这是中国共产党独立领导革命战争、创建人民军队和武装夺取政权的开端。9月9日，秋收起义爆发，起义军公开打出了“工农革命军”的旗帜，9月29日，三湾改编，10月7日，创建井冈山农村革命根据地的斗争，这是中国人民革命史上具有决定意义的新起点。12月11日，广州起义</p>
<p>土地战争革命时期（十年内战）</p>
<h3 id="农村包围城市、武装夺取政权道路的开辟"><a href="#农村包围城市、武装夺取政权道路的开辟" class="headerlink" title="农村包围城市、武装夺取政权道路的开辟"></a>农村包围城市、武装夺取政权道路的开辟</h3><h4 id="对中国革命新道路的探索"><a href="#对中国革命新道路的探索" class="headerlink" title="对中国革命新道路的探索"></a>对中国革命新道路的探索</h4><h1 id="古田会议"><a href="#古田会议" class="headerlink" title="古田会议"></a>古田会议</h1><p>1929年12月，大会根据中央九月来信精神，通过了毛泽东起草的古田会议决议，其中最重要的是关于纠正党内错误思想的决议案，确立了思想建党、政治建军的原则；阐述了加强党的思想建设的极端重要性，指明党内各种非无产阶级思想的表现、来源及纠正办法；规定红军是一个执行革命的政治任务的武装集团，必须绝对服从共产党的领导，必须全心全意为党的纲领、路线和政策而奋斗；提出红军必须担负打仗、筹款和做群众工作的任务，必须加强政治工作。</p>
<p>古田会议决议是中国共产党和红军建设的纲领性文献，是党和人民军队建设史上的重要里程碑。古田会议确立了马克思主义建党建军原则，创造性地解决了在农村环境中、在党组织和军队以农民为主要成分的条件下，如何保持党的无产阶级先锋队性质和建设党领导的新型人民军队的重大问题。</p>
<p>游击战争是中国革命的主要形式，农村根据地成为主要战略阵地</p>
<h2 id="第二节-中国革命在曲折中前进"><a href="#第二节-中国革命在曲折中前进" class="headerlink" title="第二节 中国革命在曲折中前进"></a>第二节 中国革命在曲折中前进</h2><h3 id="一、土地革命战争的发展及其挫折"><a href="#一、土地革命战争的发展及其挫折" class="headerlink" title="一、土地革命战争的发展及其挫折"></a>一、土地革命战争的发展及其挫折</h3><p>中华苏维埃共和国是中国历史上第一个全国性的工农民主政权。</p>
<h3 id="二、遵义会议实现伟大历史转折"><a href="#二、遵义会议实现伟大历史转折" class="headerlink" title="二、遵义会议实现伟大历史转折"></a>二、遵义会议实现伟大历史转折</h3><p>1935年1月15日至17日，遵义会议，会议集中解决了当时具有决定意义的军事和组织问题。会议增选毛泽东为中央政治局常委，委托张闻天起草《中央关于反对敌人五次“围剿”的总结的决议》。</p>
<h3 id="三、红军长征胜利和迎接全民族抗争"><a href="#三、红军长征胜利和迎接全民族抗争" class="headerlink" title="三、红军长征胜利和迎接全民族抗争"></a>三、红军长征胜利和迎接全民族抗争</h3><p>中国工农红军长征是一次理想信念的伟大远征，是一次检验真理的伟大远征，是一次唤醒民众的伟大远征，是一次开创新局的伟大远征。</p>
<p>长征的胜利，极大地促进了党在政治上和思想上的成熟。</p>
<p>长征的胜利，是中国革命转危为安的关键。</p>
<p>长征宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败 ，宣告了中国共产党和红军肩负起民族希望胜利实现了北上抗日的战略转折，实现了中国共产党和中国革命事业从挫折走向胜利的伟大转折，开启了中国共产党为实现民族独立、人民解放而斗争的新的伟大进军。</p>
<ul>
<li>长征精神<br>1、把全国人民和中华民族的根本利益看得高于一切，坚定革命的理想和信念，坚信正义事业必然胜利的精神<br>2、为了救国救民，不怕任何艰难险阻，不惜付出一切牺牲的精神<br>3、坚持独立自主、实事求是，一切从实际触发的精神<br>4、顾全大局、严守纪律、紧密团结的精神<br>5、紧紧依靠人民群众，同人民群众生死相依、患难与共、艰苦奋斗的精神。</li>
</ul>
<h1 id="第六章-中华民族的抗日战争"><a href="#第六章-中华民族的抗日战争" class="headerlink" title="第六章 中华民族的抗日战争"></a>第六章 中华民族的抗日战争</h1><h2 id="第四节-抗日战争的中流砥柱"><a href="#第四节-抗日战争的中流砥柱" class="headerlink" title="第四节 抗日战争的中流砥柱"></a>第四节 抗日战争的中流砥柱</h2><h3 id="游击战争的战略低位和作用"><a href="#游击战争的战略低位和作用" class="headerlink" title="游击战争的战略低位和作用"></a>游击战争的战略低位和作用</h3><p>在战略防御阶段，从全局看，敌后游击战是辅助的，对组织日军进攻、减轻正面战场压力、使战争转入相持阶段起了关键性作用。</p>
<p>在战略相持阶段，敌后游击战争称为主要的抗日作战方式。</p>
<h3 id="抗日民主根据地的建设"><a href="#抗日民主根据地的建设" class="headerlink" title="抗日民主根据地的建设"></a>抗日民主根据地的建设</h3><p>三三制原则，即共产党员、党外进步人士和中间派各占1&#x2F;3</p>
<h2 id="第五节-抗日战争的胜利及其意义"><a href="#第五节-抗日战争的胜利及其意义" class="headerlink" title="第五节 抗日战争的胜利及其意义"></a>第五节 抗日战争的胜利及其意义</h2><h1 id="重点-抗日战争胜利的原因"><a href="#重点-抗日战争胜利的原因" class="headerlink" title="-重点)!抗日战争胜利的原因"></a>-重点)!抗日战争胜利的原因</h1><p>第一，以爱国主义为核心的民族精神是中国人民抗日战争胜利的决定因素。</p>
<p>第二，中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。</p>
<p>第三，全民族抗战是中国人民抗日战争胜利的重要法宝。</p>
<p>第四，中国人民抗日战争的胜利，同世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持也是分不开的。</p>
<h1 id="重点-抗日战争胜利的意义"><a href="#重点-抗日战争胜利的意义" class="headerlink" title="-重点)!抗日战争胜利的意义"></a>-重点)!抗日战争胜利的意义</h1><p>① 是中华民族从近代以来陷入深重危机走向伟大复习的历史转折点。</p>
<p>② 彻底粉碎了日本军国注意殖民奴役中国的图谋，有力捍卫了国家主权和领土完整，彻底洗刷了近代以来抗击外来侵略屡战屡败的民族耻辱。</p>
<p>③ 促进了中华民族的大团结，形成能了伟大的抗战精神。</p>
<p>④ 对世界各国夺取反法西斯战争的胜利，维护世界和平产生了巨大影响。</p>
<p>⑤ 坚定了中国人民追求民族独立、自由、解放的意志，开启了古老中国凤凰涅槃、浴火重生的历史新征程。</p>
<h1 id="第七章-为建立新中国而奋斗"><a href="#第七章-为建立新中国而奋斗" class="headerlink" title="第七章 为建立新中国而奋斗"></a>第七章 为建立新中国而奋斗</h1><h2 id="第二节-全国解放战争的发展和第二条战线的形成"><a href="#第二节-全国解放战争的发展和第二条战线的形成" class="headerlink" title="第二节 全国解放战争的发展和第二条战线的形成"></a>第二节 全国解放战争的发展和第二条战线的形成</h2><h3 id="解放区的土地改革运动与农民的广泛发动"><a href="#解放区的土地改革运动与农民的广泛发动" class="headerlink" title="解放区的土地改革运动与农民的广泛发动"></a>解放区的土地改革运动与农民的广泛发动</h3><h4 id="从五四指示到《中国土地法大纲》"><a href="#从五四指示到《中国土地法大纲》" class="headerlink" title="从五四指示到《中国土地法大纲》"></a>从五四指示到《中国土地法大纲》</h4><p>1946年5月4日，中共中央发布《关于土地问题的指示》（五四指示）</p>
<p>1947年7月至9月，中国共产党制定和通过了《中国土地法纲领》明确规定“废除封建性及半封建性剥削的土地制度，实行耕者有其田的土地制度”。《中国土地法大纲》是一个彻底反封建的土地革命纲领。</p>
<h1 id="重点-第四节-建立人民民主转折的新中国"><a href="#重点-第四节-建立人民民主转折的新中国" class="headerlink" title="-重点)! 第四节 建立人民民主转折的新中国"></a>-重点)! 第四节 建立人民民主转折的新中国</h1><p>4月21日，毛泽东、朱德发布《向全国进军的命令》</p>
<p>宣告延续22年之久的国民党反动统治覆灭</p>
<h2 id="二、人民政协与共同纲领"><a href="#二、人民政协与共同纲领" class="headerlink" title="二、人民政协与共同纲领"></a>二、人民政协与共同纲领</h2><p>1949年6月30日，毛泽东发表了《论人民民主专政》，明确指出，人民民主专政需要工人阶级的领导。人民民主专政的基础是工人阶级、农民阶级和城市小资产阶级的联盟，而主要是 工人和农民的联盟。</p>
<p>中国七届二中全会的决议和毛泽东的《论人民民主专政》，构成了《中国人民政治协商会议共同纲领》的基础。</p>
<h1 id="第八章-中华民族共和国的成立与中国社会主义建设道路的探索"><a href="#第八章-中华民族共和国的成立与中国社会主义建设道路的探索" class="headerlink" title="第八章 中华民族共和国的成立与中国社会主义建设道路的探索"></a>第八章 中华民族共和国的成立与中国社会主义建设道路的探索</h1><h1 id="重点-巩固民族独立，维护国家主权和安全"><a href="#重点-巩固民族独立，维护国家主权和安全" class="headerlink" title="-重点)!巩固民族独立，维护国家主权和安全"></a>-重点)!巩固民族独立，维护国家主权和安全</h1><p>以毛泽东为主要代表的中国共产党人提出了“另起炉灶”“打扫干净屋子再请客”“一边倒”的外交方针</p>
<h1 id="重点-恢复国民经济，为社会主义改造创造条件"><a href="#重点-恢复国民经济，为社会主义改造创造条件" class="headerlink" title="-重点)!恢复国民经济，为社会主义改造创造条件"></a>-重点)!恢复国民经济，为社会主义改造创造条件</h1><p>目的：国家经济公有化</p>
<p>没收官僚资本归人民的国家所有，是新民主主义革命的三大经济纲领之一，也是《共同纲领》规定的一项历史任务。</p>
<h1 id="重点-党提出过度时期总路线"><a href="#重点-党提出过度时期总路线" class="headerlink" title="-重点)!党提出过度时期总路线"></a>-重点)!党提出过度时期总路线</h1><p>党在过渡时期的总路线，明确规定：“从中华人民共和国成立，到社会主义改造基本完成，这是一个过度时期”</p>
<p>内容：逐步实现国家的社会主义工业化，并逐步实现国家对农业，对手工业和资本主义工商业的社会主义改造。</p>
<p>主要内容概括为“一化三改”，又称“一体两翼”。“一化”是“主体”，“三改”是“两翼”</p>
<h3 id="改造资本主义工商业"><a href="#改造资本主义工商业" class="headerlink" title="改造资本主义工商业"></a>改造资本主义工商业</h3><p>在企业利润分配上实行“四马分肥”，即所得税占30%，工人福利占15%，企业公积金占30%，资方股息红利占25%，资本家对工人的剥削有所减轻。</p>
]]></content>
      <categories>
        <category>近代史</category>
      </categories>
      <tags>
        <tag>近代史</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统结构</title>
    <url>/2023/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h1><p><a href="#Cache%E5%86%99%E7%AD%96%E7%95%A5">Cache写策略</a></p>
<p><a href="#%E6%B5%81%E6%B0%B4%E7%9A%84%E5%88%86%E7%B1%BB">流水的分类</a></p>
<p><a href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F">中断系统</a></p>
<p><a href="#%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96">指令操作码的优化</a><br>{理论最短码}</p>
<img src = "./5.png">

<p>[流水处理机一道题]<br><img src =  "./2.png"></p>
<span id="more"></span>
<h1 id="第一章-计算机系统结构基础及并发性的开发"><a href="#第一章-计算机系统结构基础及并发性的开发" class="headerlink" title="第一章 计算机系统结构基础及并发性的开发"></a>第一章 计算机系统结构基础及并发性的开发</h1><h2 id="1-1-计算机系统的层次结构"><a href="#1-1-计算机系统的层次结构" class="headerlink" title="1.1 计算机系统的层次结构"></a>1.1 计算机系统的层次结构</h2><img src = "./3.png">

<p>其中，0级和1级为硬件，2-5为软件</p>
<p>上层对下层进行解释和翻译，具有透明性。</p>
<ul>
<li><p>翻译技术是先用转换程序将高一级机器级上的程序整个地变换成低一级机器级上等效的程序，然后再在低一级机器级上实现的技术。</p>
</li>
<li><p>翻译技术则是在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级的机器级语言程序中的每条语句或指令逐条解释来实现的技术。</p>
</li>
</ul>
<h2 id="1-2-计算机系统结构、计算机组成和计算机实现"><a href="#1-2-计算机系统结构、计算机组成和计算机实现" class="headerlink" title="1.2 计算机系统结构、计算机组成和计算机实现"></a>1.2 计算机系统结构、计算机组成和计算机实现</h2><h3 id="1-2-1-计算机系统结构的定义和内涵"><a href="#1-2-1-计算机系统结构的定义和内涵" class="headerlink" title="1.2.1 计算机系统结构的定义和内涵"></a>1.2.1 计算机系统结构的定义和内涵</h3><p>系统结构是对计算机系统中各级界面的定义及其上下的功能分配</p>
<p>内涵：确定计算机软硬件的界面。</p>
<p>计算机系统结构也称计算机系统的体系结构，它只是系统结构中的一部分，指的是传统机器级的系统结构。</p>
<p>结论：计算机系统结构研究的是软、硬件之间的功能分配以及对传统机器级界面的确定，为机器语言、汇编语言程序设计者或编译程序生成系统提供使其设计或生成的程序能在机器上正确运行而应看到和遵循的计算机属性。</p>
<h3 id="1-2-2-计算机组成和计算机实现的定义及内涵"><a href="#1-2-2-计算机组成和计算机实现的定义及内涵" class="headerlink" title="1.2.2 计算机组成和计算机实现的定义及内涵"></a>1.2.2 计算机组成和计算机实现的定义及内涵</h3><p>计算机组成指的是计算机系统结构的逻辑实现，包括机器级内部的数据流和控制流的组成以及逻辑设计等。（器件设计）</p>
<p>计算机实现的设计着眼于器件技术和微组装技术，其中，器件技术起着主导作用。</p>
<h2 id="1-3-计算机系统的软、硬件取舍和性能评测及定量设计原理"><a href="#1-3-计算机系统的软、硬件取舍和性能评测及定量设计原理" class="headerlink" title="1.3 计算机系统的软、硬件取舍和性能评测及定量设计原理"></a>1.3 计算机系统的软、硬件取舍和性能评测及定量设计原理</h2><h3 id="1-3-1-软、硬件取舍的基本原则"><a href="#1-3-1-软、硬件取舍的基本原则" class="headerlink" title="1.3.1 软、硬件取舍的基本原则"></a>1.3.1 软、硬件取舍的基本原则</h3><p>软、硬件的功能分配是计算机系统结构的主要任务，而软件和硬件在逻辑功能上又是等效的。</p>
<p><strong>原则1</strong>： 应考虑在现有硬件、器件（主要是逻辑器件和存储器件）条件下，系统要有高的性能价格，主要从实现费用、速度和其他性能要求来综合考虑。</p>
<p>设计费用：D硬件≈100D软件</p>
<p>重复生产费用： M硬件≈100M软件</p>
<p>结论：只有对产量大的计算机系统，增大硬件功能实现的比例才是适宜的。如果用硬件实现不能给用户带来明显的好处，产量仍较低，则系统是不会有生命力的。</p>
<p><strong>原则2</strong>：要考虑准备采用和可能采用的组成技术，使之尽可能不要过多或不合理地限制各种组成、实现技术的采用。</p>
<p><strong>原则3</strong>：不能仅从“硬”的角度考虑如何便于应用组成技术的成果和便于发挥器件技术的进展，还应从“软”的角度把如何为编译和操作系统的实现以及如何为高级语言程序的设计提供更多，更好的硬件支持放在首位。</p>
<h3 id="1-3-2-计算机系统性能评测及定量设计原理"><a href="#1-3-2-计算机系统性能评测及定量设计原理" class="headerlink" title="1.3.2 计算机系统性能评测及定量设计原理"></a>1.3.2 计算机系统性能评测及定量设计原理</h3><h4 id="性能评测"><a href="#性能评测" class="headerlink" title="性能评测"></a>性能评测</h4><p>$$<br>T_cpu&#x3D; IC × CPI × \frac{1}{f_c}<br>$$</p>
<p>IC 总指令条数，平均每条指令的时钟周期数 CPI、主时钟频率 fc</p>
<p>MIPS(百万条指令数每秒)、MFLOPS（百万次浮点运算每秒）</p>
<h4 id="计算机系统的定量设计原理"><a href="#计算机系统的定量设计原理" class="headerlink" title="计算机系统的定量设计原理"></a>计算机系统的定量设计原理</h4><p>哈夫曼压缩原理，尽可能加速处理高频率时间远比加速处理概率低的事件对性能的提高要显著。</p>
<p>Amdahl定律。该定律是1967年IBM公司的Amdahl在设计IBM360 系列机时首先提出来的。该定律可用于确定对系统中性能瓶颈部件采取措施提高速度后能得到系统性能改进的成都，即系统加速比$S_p$。系统加速比$S_p$定义为系统改进后的性能与未改进时的性能的比值，或者定义为系统未改进时的程序执行时间$T_old$与改进后程序执行时间 $T_new$的比值。系统加速比$S_p$与两个因素有关，即性能可改进比$f_new$和系统加速比$r_new$</p>
<h3 id="1-3-3-计算机系统设计的主要方法和任务"><a href="#1-3-3-计算机系统设计的主要方法和任务" class="headerlink" title="1.3.3 计算机系统设计的主要方法和任务"></a>1.3.3 计算机系统设计的主要方法和任务</h3><h4 id="计算机系统设计的主要任务"><a href="#计算机系统设计的主要任务" class="headerlink" title="计算机系统设计的主要任务"></a>计算机系统设计的主要任务</h4><p>(1) 要弄清其应用领域是专用的还是通用的。</p>
<p>(2) 要弄清软件兼容是放在哪级层次。</p>
<p>(3) 要弄清对操作系统有何种要求。</p>
<p>(4) 要如何保证有高的标准化程度。</p>
<h4 id="计算机系统的设计方法"><a href="#计算机系统的设计方法" class="headerlink" title="计算机系统的设计方法"></a>计算机系统的设计方法</h4><p>“由上往下[软件决定硬件]”、“由下往上[硬件决定软件]”、“由中间开始[软硬件结合]”</p>
<h2 id="1-4-软件界、应用、器件的发展对系统结构的影响"><a href="#1-4-软件界、应用、器件的发展对系统结构的影响" class="headerlink" title="1.4 软件界、应用、器件的发展对系统结构的影响"></a>1.4 软件界、应用、器件的发展对系统结构的影响</h2><h3 id="1-4-1-软件的发展对系统结构的影响"><a href="#1-4-1-软件的发展对系统结构的影响" class="headerlink" title="1.4.1 软件的发展对系统结构的影响"></a>1.4.1 软件的发展对系统结构的影响</h3><h4 id="1-统一高级语言"><a href="#1-统一高级语言" class="headerlink" title="1. 统一高级语言"></a>1. 统一高级语言</h4><p>(1) 不同的用途要求语言的语法、语义结构不同</p>
<p>(2) 人们对语言的基本结构看法不一</p>
<p>(3) 即使同一种高级语言在不同厂家的机器上也不能完全通用</p>
<h4 id="3-模拟和仿真"><a href="#3-模拟和仿真" class="headerlink" title="3. 模拟和仿真"></a>3. 模拟和仿真</h4><p>仿真是用微程序解释，其解释程序存在于控制存储器中；而模拟是用机器语言程序解释，其解释程序存在于主存中。</p>
<h2 id="1-5-系统结构中的并发性开发及计算机系统的分类"><a href="#1-5-系统结构中的并发性开发及计算机系统的分类" class="headerlink" title="1.5 系统结构中的并发性开发及计算机系统的分类"></a>1.5 系统结构中的并发性开发及计算机系统的分类</h2><h3 id="1-5-1-并行性的概念和开发。"><a href="#1-5-1-并行性的概念和开发。" class="headerlink" title="1.5.1 并行性的概念和开发。"></a>1.5.1 并行性的概念和开发。</h3><p>并行性包含同时性和并发性二重含义。同时性指两个或多个事件在同一时刻发生。并发性指两个或多个事件在同一事件间隔内发生。</p>
<p>开发并行性的途径有时间重叠、资源重复和资源共享等。</p>
<h3 id="1-5-2-计算机系统的分类"><a href="#1-5-2-计算机系统的分类" class="headerlink" title="1.5.2 计算机系统的分类"></a>1.5.2 计算机系统的分类</h3><p>计算机系统分为：单指令流单数据流、单指令流多数据流、多指令流单数据流和多指令流多数据流。</p>
<h1 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h1><p>什么是透明性概念？对于计算机系统结构，下列哪些是透明的？哪些是不透明的？</p>
<p>客观存在的事物或属性，从某个角度去看，却看不到，称这些事物和属性对它是透明的。透明了就可以简化这部分的设计，然而因为透明而无法控制和干预，就会带来不利。因此，透明性的取舍要正确选择。</p>
<p>对计算机系统结构透明的有：存储器的模 m 交叉存取，数据总线宽度，阵列运算部件，通道是采用结合型还是独立型，PDP-11系列的单总线结构，串行、重叠还是流水控制方式，Cache存储器。</p>
<p>不透明的有：浮点数据表示，I&#x2F;O系统是采用通道方式还是外围处理机方式，字符行运算指令，访问方式保护，程序性中断，堆栈指令，存储器最小编制单位。</p>
<h1 id="第二章-数据表示、寻址方式与指令系统"><a href="#第二章-数据表示、寻址方式与指令系统" class="headerlink" title="第二章 数据表示、寻址方式与指令系统"></a>第二章 数据表示、寻址方式与指令系统</h1><h2 id="2-1-数据表示"><a href="#2-1-数据表示" class="headerlink" title="2.1 数据表示"></a>2.1 数据表示</h2><p>数据表示(静态)[硬件]、数据结构（动态）[软件]</p>
<p>数据表示指的是能由机器硬件识别和引用的数据类型，表现在它有对这种类型的数据进行操作的指令和运算部件。</p>
<h3 id="2-1-2-高级数据表示"><a href="#2-1-2-高级数据表示" class="headerlink" title="2.1.2 高级数据表示"></a>2.1.2 高级数据表示</h3><p>标识符(1对1)和数据描述符(1对多)</p>
<p>向量(向量处理机)、数组数据表示(流水)</p>
<p>堆栈数据表示(先进后出，后进先出):层层叠放</p>
<p>嵌套调用：常用于树型结构，二叉树</p>
<h3 id="2-1-3-引入数据表示的原则"><a href="#2-1-3-引入数据表示的原则" class="headerlink" title="2.1.3 引入数据表示的原则"></a>2.1.3 引入数据表示的原则</h3><p>原则1：看系统的效率是否显著提高，包括实现时间和存储空间是否有显著减少</p>
<p>原则2：看引入这种数据表示后，其通用性和利用率是否提高。</p>
<h3 id="2-1-4-浮点数尾数基值大小和下溢处理方法的选择"><a href="#2-1-4-浮点数尾数基值大小和下溢处理方法的选择" class="headerlink" title="2.1.4 浮点数尾数基值大小和下溢处理方法的选择"></a>2.1.4 浮点数尾数基值大小和下溢处理方法的选择</h3><p>用浮点数表示实数比用定点数表示有更大的可表示数范围。</p>
<h4 id="浮点数尾数的下溢处理方法"><a href="#浮点数尾数的下溢处理方法" class="headerlink" title="浮点数尾数的下溢处理方法"></a>浮点数尾数的下溢处理方法</h4><p>截断法、舍入法、恒置”1”法、查表舍入法</p>
<h2 id="2-2-寻址方式"><a href="#2-2-寻址方式" class="headerlink" title="2.2 寻址方式"></a>2.2 寻址方式</h2><p>寻址方式的三种面向</p>
<p>寄存器-寄存器(RR)、寄存器-存储器(RM)、存储器-存储器(MM)</p>
<h2 id="2-3-指令系统的设计和优化"><a href="#2-3-指令系统的设计和优化" class="headerlink" title="2.3 指令系统的设计和优化"></a>2.3 指令系统的设计和优化</h2><h3 id="指令操作码的优化"><a href="#指令操作码的优化" class="headerlink" title="指令操作码的优化"></a>指令操作码的优化</h3><p>指令是由操作码和地址码两部分组成的。</p>
<p>$$<br>信息冗余度 &#x3D; \frac{实际平均码长-H}{实际平均码长}<br>$$</p>
<p>理论最短码<br>$$<br>H &#x3D; ∑P_ilog_2Pi<br>$$</p>
<img src = "./1.png">

<h1 id="第三章-存储、中断、总线与输入-x2F-输出系统"><a href="#第三章-存储、中断、总线与输入-x2F-输出系统" class="headerlink" title="第三章 存储、中断、总线与输入&#x2F;输出系统"></a>第三章 存储、中断、总线与输入&#x2F;输出系统</h1><h2 id="3-1-存储系统的基本要求和并行主存系统"><a href="#3-1-存储系统的基本要求和并行主存系统" class="headerlink" title="3.1 存储系统的基本要求和并行主存系统"></a>3.1 存储系统的基本要求和并行主存系统</h2><p>Cache-主存(速度)、主存-辅存(容量)</p>
<h3 id="3-1-2-并行主存系统"><a href="#3-1-2-并行主存系统" class="headerlink" title="3.1.2 并行主存系统"></a>3.1.2 并行主存系统</h3><p>分布式交叉存储</p>
<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p>中断可分为内部中断、外部中断和软件中断三类。</p>
<p>内部中断(自陷、故障、终止)</p>
<p>外部中断（时钟中断和I&#x2F;O中断）</p>
<p>内中断优于外中断</p>
<h2 id="3-3-总线系统"><a href="#3-3-总线系统" class="headerlink" title="3.3 总线系统"></a>3.3 总线系统</h2><h3 id="3-3-1-总线的分类"><a href="#3-3-1-总线的分类" class="headerlink" title="3.3.1 总线的分类"></a>3.3.1 总线的分类</h3><p>总线按用法可分为专用和非专用两类</p>
<h3 id="3-3-3-总线的通信技术"><a href="#3-3-3-总线的通信技术" class="headerlink" title="3.3.3 总线的通信技术"></a>3.3.3 总线的通信技术</h3><p>同步通信和异步通信</p>
<h1 id="第四章-存储体系"><a href="#第四章-存储体系" class="headerlink" title="第四章 存储体系"></a>第四章 存储体系</h1><h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><p>存储系统的构成依据：</p>
<p>预知的可能性基于计算机程序具有局部性，它包括时间上的局部性和空间上的局部性。</p>
<h3 id="4-1-3-存储体系的性能参数"><a href="#4-1-3-存储体系的性能参数" class="headerlink" title="4.1.3 存储体系的性能参数"></a>4.1.3 存储体系的性能参数</h3><p>SMi为Mi的以位计算的存储容量，ci为Mi的每位价格</p>
<p>存储层次的每位价格为</p>
<p>$$<br>c &#x3D; \frac{c_1<em>S_M1+c_2</em>S_M2}{S_M1+S_M2}<br>$$</p>
<p>命中率 H&#x3D;R1&#x2F;(R1+R2)</p>
<p>等效访问时间$T_A &#x3D; HT_A1+(1-H)T_A2$</p>
<p>设CPU对存储层次相邻二级的访问时间比 $r&#x3D;T_A2&#x2F;T_A1$</p>
<h2 id="4-2-虚拟存储器"><a href="#4-2-虚拟存储器" class="headerlink" title="4.2 虚拟存储器"></a>4.2 虚拟存储器</h2><img src = "./4.png">

<h3 id="4-2-1-虚拟存储器的管理方式"><a href="#4-2-1-虚拟存储器的管理方式" class="headerlink" title="4.2.1 虚拟存储器的管理方式"></a>4.2.1 虚拟存储器的管理方式</h3><h3 id="1-段式管理"><a href="#1-段式管理" class="headerlink" title="1.段式管理"></a>1.段式管理</h3><p>功能：用户给出一个地址(虚地址或逻辑地址)虚拟地址存储要给出该地址对应的数址。</p>
<p>实现：由辅助硬件将虚地址映射到主存中的某个单元，主存地址称为实地址</p>
<p>特征：离散性、多次性、对换性、虚拟性</p>
<h2 id="4-3-高速缓存存储器"><a href="#4-3-高速缓存存储器" class="headerlink" title="4.3 高速缓存存储器"></a>4.3 高速缓存存储器</h2><p>高速缓存存储器(RAM(SRAM[静态]、DRAM[主存])、ROM)</p>
<h3 id="4-3-2-地址的映像与变换"><a href="#4-3-2-地址的映像与变换" class="headerlink" title="4.3.2 地址的映像与变换"></a>4.3.2 地址的映像与变换</h3><p>映射关系分为:</p>
<p>全相联(随意放):3+6+19-&gt; 随意(RAND){块号+块内地址+有效码}</p>
<p>直接映射(对号入座): 有效位+19（主存内地址）{标记号+主存内地址+块号}</p>
<p>组相联（组内随意，组外对号入座）:组地址+3+6 {组标记+块号+块内地址}</p>
<p>先进先出(FIFO)、近期最少使用(IRU)、最近不常使用(LFU)</p>
<h3 id="4-3-3-Cache存储器的LRU替换算法的硬件实现"><a href="#4-3-3-Cache存储器的LRU替换算法的硬件实现" class="headerlink" title="4.3.3 Cache存储器的LRU替换算法的硬件实现"></a>4.3.3 Cache存储器的LRU替换算法的硬件实现</h3><p>替换策略:</p>
<ol>
<li><p>随机算法:针对全相联，易实现且命中率低</p>
</li>
<li><p>先进先出算法[队列]：选择最早调入的行替换，精度低</p>
</li>
</ol>
<p>计数器[堆栈] (命中):</p>
<ol start="3">
<li><p>近期最少使用的算法 LRU</p>
</li>
<li><p>最不常使用的算法: LFU</p>
</li>
</ol>
<h3 id="4-3-4-Cache存储器的透明性及性能分析"><a href="#4-3-4-Cache存储器的透明性及性能分析" class="headerlink" title="4.3.4 Cache存储器的透明性及性能分析"></a>4.3.4 Cache存储器的透明性及性能分析</h3><h4 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h4><p>Cache写策略分为命中和不命中两种情况，命中有写回法和全写法，不命中则有非分配写法和分配写法</p>
<h2 id="4-4-三级存储体系"><a href="#4-4-三级存储体系" class="headerlink" title="4.4 三级存储体系"></a>4.4 三级存储体系</h2><p>虚拟存储器(叶式、段式、分页式)</p>
<h1 id="第五章-标量处理器"><a href="#第五章-标量处理器" class="headerlink" title="第五章 标量处理器"></a>第五章 标量处理器</h1><p>流水处理</p>
<h2 id="5-2-1-流水方式"><a href="#5-2-1-流水方式" class="headerlink" title="5.2.1 流水方式"></a>5.2.1 流水方式</h2><h3 id="流水的分类"><a href="#流水的分类" class="headerlink" title="流水的分类"></a>流水的分类</h3><p>浮点加可进一步细分成“求阶差”、“对阶”、“尾数相加”、“规格化”4个子过程</p>
<p>把一个任务分为多个&#x2F;若干个子任务</p>
<p>按处理级别分为：部件级、处理机级和系统级</p>
<p>按功能的多少分为：单功能流水线和多功能流水线</p>
<p>按连接方式分为：静态流水线和动态流水线。</p>
<p>按流水线处理机分为：标量流水机和向量流水机</p>
<p>是否有反馈回路分为：线性流水和非线性流水</p>
<p>顺序流水线和乱序流水线</p>
<h3 id="5-2-2-标量流水线的主要性能"><a href="#5-2-2-标量流水线的主要性能" class="headerlink" title="5.2.2 标量流水线的主要性能"></a>5.2.2 标量流水线的主要性能</h3><p>标量流水线的性能主要是吞吐率$T_p$、加速比$S_p$和效率$\eta$</p>
<h4 id="1-吞吐率-T-p-和加速比-S-p"><a href="#1-吞吐率-T-p-和加速比-S-p" class="headerlink" title="1.吞吐率$T_p$和加速比$S_p$"></a>1.吞吐率$T_p$和加速比$S_p$</h4><p>吞吐率的计算公式<br>$$<br>T_p &#x3D; \frac{n}{T_k}<br>$$</p>
<p>n: 任务数</p>
<p>Tk: 处理完n个任务所需时间</p>
<p>加速比的计算公式<br>$$<br>S_p &#x3D; \frac{T_0}{T_k}<br>$$</p>
<p>最大吞吐率$T_pmax$为1&#x2F;$\Delta t_2$</p>
<p>实际吞吐率:$T_p&#x3D;\frac{n}{(k+n-1)\Delta t}$</p>
<p>$e&#x3D;\frac{n}{kT_k}$</p>
<p>$S&#x3D;\frac{T_0}{T_k}&#x3D;\frac{nk\Delta t}{k\Delta t+(n-1)\Delta t}$</p>
<h1 id="第六章-向量处理机"><a href="#第六章-向量处理机" class="headerlink" title="第六章 向量处理机"></a>第六章 向量处理机</h1><h2 id="6-1-向量的流水处理和向量流水处理机"><a href="#6-1-向量的流水处理和向量流水处理机" class="headerlink" title="6.1 向量的流水处理和向量流水处理机"></a>6.1 向量的流水处理和向量流水处理机</h2><h3 id="6-1-2-向量流水处理机的结构举例"><a href="#6-1-2-向量流水处理机的结构举例" class="headerlink" title="6.1.2 向量流水处理机的结构举例"></a>6.1.2 向量流水处理机的结构举例</h3><p>“存储器”-“存储器”结构(并行)</p>
<p>“寄存器”-“寄存器”结构(并行)</p>
<p>不同之处：容量不同</p>
]]></content>
      <categories>
        <category>计算机系统结构</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全</title>
    <url>/2023/06/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><a href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">网络安全基本概念</a><br><a href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9A%84%E7%89%B9%E5%BE%81%E5%A1%AB%E7%A9%BA%E9%A2%98">网络安全的特征填空题</a><br><a href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9A%84%E7%9B%AE%E6%A0%87">网络安全的目标</a><br><a href="#%E5%90%84%E7%A7%8D%E5%A8%81%E8%83%81%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%89%B9%E5%BE%81%E7%9A%84%E5%BD%B1%E5%93%8D">各种威胁对网络安全特征的影响</a><br><a href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9A%84%E9%98%B2%E6%8A%A4%E4%BD%93%E7%B3%BB">网络安全的防护体系</a><br><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4%E7%AD%89%E7%BA%A7%E5%88%92%E5%88%86%E5%87%86%E5%88%99">计算机信息系统安全保护等级划分准则</a><br><a href="#%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2">密码技术的发展历史</a><br><a href="#%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E6%88%90">密码系统的构成</a><br><a href="#%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E7%9A%84%E5%88%86%E7%B1%BB">密码技术的分类</a><br><a href="#%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%B8%AD%E4%BB%A3%E6%8D%A2%E5%AF%86%E7%A0%81%E4%B8%8E%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81-%E5%90%AB%E4%B9%89%E5%8E%9F%E7%90%86%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B">古典密码体制中代换密码与置换密码含义原理典案例</a><br><a href="#%E6%B5%81%E5%AF%86%E7%A0%81%E5%90%AB%E4%B9%89">流密码含义，设计思想</a><br><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0">非对称密码体制出现的原因</a><br><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E7%9A%84%E5%90%AB%E4%B9%89">非对称密码体制的含义</a><br><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86">非对称密码体制的原理</a><br><a href="#rsa%E7%AE%97%E6%B3%95%E5%90%AB%E4%B9%89">RSA算法含义</a><br><a href="#rsa%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">RSA算法设计思想</a><br><a href="#rsa%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B">RSA算法经典案例</a><br><a href="#%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E5%90%AB%E4%B9%89">密钥管理含义</a><br><a href="#%E5%AF%86%E9%92%A5%E5%88%86%E7%B1%BB">密钥分类</a><br><a href="#%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91%E4%B8%8E%E5%8D%8F%E5%95%86%E6%8A%80%E6%9C%AF%E5%90%AB%E4%B9%89%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">密钥分发与协商技术含义，设计思想，存在的问题</a><br><a href="#%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91%E4%B8%AD%E5%BF%83%E5%90%AB%E4%B9%89%E4%BD%9C%E7%94%A8ca">密钥分发中心含义，作用，CA</a><br><a href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%90%AB%E4%B9%89">数字签名含义</a><br><a href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%AD%BE%E5%90%8D%E7%9A%84%E5%BC%82%E5%90%8C">与传统签名的异同</a><br><a href="#%E5%8E%9F%E7%90%86">数字签名原理</a><br><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%90%AB%E4%B9%89">哈希函数含义</a><br><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84">哈希函数的结构</a><br><a href="#%E5%AE%89%E5%85%A8%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0sha%E7%AE%97%E6%B3%95%E5%90%AB%E4%B9%89">安全哈希函数SHA算法含义</a><br><a href="#%E5%AE%89%E5%85%A8%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0sha%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3">安全哈希函数SHA算法设计思想</a><br><a href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E5%90%AB%E4%B9%89">消息认证含义</a><br><a href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%9A%84%E7%B1%BB%E5%9E%8B">消息认证的类型</a><br><a href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF%E5%8C%85%E6%8B%AC%E6%95%B0%E6%8D%AE%E6%BA%90%E8%AE%A4%E8%AF%81%E5%92%8C%E5%AE%9E%E4%BD%93%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">身份认证技术包括数据源认证和实体身份认证</a><br><a href="#%E9%BB%91%E5%AE%A2%E5%90%AB%E4%B9%89%E5%8A%A8%E6%9C%BA%E9%BB%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E4%B8%8E%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B">黑客含义、动机、黑客常用的攻击方法与攻击流程</a><br><a href="#%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF%E5%90%AB%E4%B9%89%E4%BD%9C%E7%94%A8">社会工程学攻击技术含义，作用</a><br><a href="#%E7%BD%91%E8%B7%AF%E6%BC%8F%E6%B4%9E%E5%90%AB%E4%B9%89">网路漏洞含义</a><br><a href="#%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E5%9B%A0">存在漏斗的原因</a><br><a href="#%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8D%B1%E5%AE%B3">漏洞的危害</a><br><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7">常见的漏洞扫描工具</a><br><a href="#%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%90%AB%E4%B9%89">入侵检测含义</a><br><a href="#%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%90%AB%E4%B9%89%E4%BC%98%E7%BC%BA%E7%82%B9">入侵检测模型、含义，优缺点</a><br><a href="#%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E6%88%90%E5%88%86%E7%B1%BB">入侵检测系统的构成，分类</a><br><a href="#%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%9F%BA%E4%BA%8E%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">基于网络的入侵检测与基于主机的入侵检测的优缺点</a><br><a href="#%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87">入侵检测系统的评估指标</a><br><a href="#snort%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E6%88%90%E8%A7%84%E5%88%99%E7%BB%93%E6%9E%84%E5%85%B8%E5%9E%8B%E7%9A%84%E8%A7%84%E5%88%99%E5%AE%9E%E4%BE%8B">snort系统的构成，规则结构，典型的规则实例</a><br><a href="#%E5%AE%9E%E7%8E%B0web%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95">实现web安全的方法</a><br><a href="#%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%B1%82%E6%98%AF%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%90%AB%E4%B9%89%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">安全套接字层是传输层的安全协议，含义，提供的三种安全服务，体系结构</a><br><a href="#pgpsmime%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E5%90%AB%E4%B9%89%E5%8E%9F%E7%90%86">PGP,S&#x2F;MIME应用层的安全协议，含义，原理</a><br><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AEipsec%E8%A7%A3%E5%86%B3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">网络层的安全协议Ipsec，解决的网络的安全问题，体系结构</a><br><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E5%90%AB%E4%B9%89%E5%8E%9F%E7%90%86%E5%88%86%E7%B1%BB">防火墙的含义，原理，分类</a><br><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E6%8A%80%E6%9C%AF">防火墙的技术</a><br><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">防火墙的体系结构</a><br>[防火墙规则的设计策略]<br><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%90%AB%E4%B9%89%E7%89%B9%E5%BE%81%E5%8D%B1%E5%AE%B3">计算机病毒含义，特征，危害</a><br><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">计算机病毒的工作原理</a><br><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E7%9A%84%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E9%98%B2%E6%B2%BB%E6%8E%AA%E6%96%BD">计算机病毒的检测技术与防治措施</a><br><a href="#%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB">恶意代码与计算机病毒区别，及其分类</a></p>
<ul>
<li>比较长的有:<br>以及经典算法DES与AES含义，算法思想，DES与AES的S盒异同；<br>入侵检测，模型<br>VPN含义，分类，隧道原理<br>网络攻击技术分类，含义</li>
</ul>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="网络安全基本概念"><a href="#网络安全基本概念" class="headerlink" title="网络安全基本概念"></a>网络安全基本概念</h2><p>网络安全基本概念：是指网络系统的硬件和软件及其系统中的数据安全，它体现于网络信息的存储，传输和使用过程</p>
<h1 id="网络安全的特征（填空题）"><a href="#网络安全的特征（填空题）" class="headerlink" title="网络安全的特征（填空题）"></a>网络安全的特征（填空题）</h1><p>保密性、完整性、可用性、可控性、可审查性、可保护性</p>
<h2 id="网络安全的目标"><a href="#网络安全的目标" class="headerlink" title="网络安全的目标"></a>网络安全的目标</h2><p>截获、伪造、篡改、中断、重发</p>
<h2 id="各种威胁对网络安全特征的影响"><a href="#各种威胁对网络安全特征的影响" class="headerlink" title="各种威胁对网络安全特征的影响"></a>各种威胁对网络安全特征的影响</h2><p>非授权访问，信息泄露或丢失、破坏数据完整性、拒绝服务攻击、利用网络传播病毒。</p>
<h2 id="网络安全的防护体系"><a href="#网络安全的防护体系" class="headerlink" title="网络安全的防护体系"></a>网络安全的防护体系</h2><p>物理安全策略；访问控制策略；防火墙控制；信息加密策略；区块链技术策略；云计算的安全策略；网络安全管理策略；</p>
<p>网络安全技术体系：物理安全、网络安全和信息安全。</p>
<h2 id="计算机信息系统安全保护等级划分准则"><a href="#计算机信息系统安全保护等级划分准则" class="headerlink" title="计算机信息系统安全保护等级划分准则"></a>计算机信息系统安全保护等级划分准则</h2><p>用户自主保护级、系统审计保护级、安全标记保护级、结构化保护级和访问验证保护级。</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="密码技术的发展历史"><a href="#密码技术的发展历史" class="headerlink" title="密码技术的发展历史"></a>密码技术的发展历史</h2><p>凯撒密码[埃及法老]-&gt;恩尼格玛机器[二战]-&gt;加密和解密[20世纪70年代]-&gt;互联网通信、电子支付[现在]</p>
<h2 id="密码系统的构成"><a href="#密码系统的构成" class="headerlink" title="密码系统的构成"></a>密码系统的构成</h2><p>明文、密文、加密、解密、加密算法、解密算法、密钥管理（加密密钥和解密密钥）</p>
<h2 id="密码技术的分类"><a href="#密码技术的分类" class="headerlink" title="密码技术的分类"></a>密码技术的分类</h2><p>单钥体制（加密密钥和解密密钥相同）、双钥体质（加密密钥和解密密钥不同）</p>
<h2 id="古典密码体制中代换密码与置换密码-含义，原理，经典案例"><a href="#古典密码体制中代换密码与置换密码-含义，原理，经典案例" class="headerlink" title="古典密码体制中代换密码与置换密码 含义，原理，经典案例"></a>古典密码体制中代换密码与置换密码 含义，原理，经典案例</h2><h3 id="代换密码"><a href="#代换密码" class="headerlink" title="代换密码"></a>代换密码</h3><p>代换密码的主要思想是通过符号的简单替换而达到掩盖明文信息的目的，也就是将明文中的字母由其他字母、数字或者符号取代的一种方法，其中的替代方案就称为密钥。</p>
<p>最简单的著名代换密码称为移位密码</p>
<h3 id="置换密码"><a href="#置换密码" class="headerlink" title="置换密码"></a>置换密码</h3><p>通过重新排列消息中元素的位置而不改变元素本身来变换一个消息的密码方案称为置换密码（也称为换位密码）。置换密码是古典密码中除代换密码外的重要一类，它的原理应用于现代分组密码的构成。</p>
<p>我国古代的藏头诗就属于这种加密方式</p>
<h2 id="对称密码体质含义，分类（流密码、分组密码）"><a href="#对称密码体质含义，分类（流密码、分组密码）" class="headerlink" title="对称密码体质含义，分类（流密码、分组密码）"></a>对称密码体质含义，分类（流密码、分组密码）</h2><p>对称密码又分为流密码和分组密码。流密码的中心思想是以尽可能简单的方式来生成一个伪随机性尽可能好的周期序列。流密码体质以简洁、快速的特点，成为新一代移动通信的主流加密算法；分组密码是将明文序列划分成等长的数组，对每一组用同一加密算法和同一密钥进行加密。分组密码体制夜具有简捷、快速的特点，并且容易实现标准化，使其成为软硬件加密的主流。</p>
<h2 id="分组密码含义"><a href="#分组密码含义" class="headerlink" title="分组密码含义"></a>分组密码含义</h2><p>含义：将明文序列划分成等长的分组，对每一组用同一加密算法和同一密钥进行加密</p>
<h2 id="分组密码设计思想"><a href="#分组密码设计思想" class="headerlink" title="分组密码设计思想"></a>分组密码设计思想</h2><p>分组密码的实质是设计一种算法，在密钥控制下，把n比特明文简捷讯速地置换成唯一的n比特密文，并且这种变换是可逆的，即所得到的密文是可解密的。</p>
<h2 id="流密码含义，设计思想"><a href="#流密码含义，设计思想" class="headerlink" title="流密码含义，设计思想"></a>流密码含义，设计思想</h2><h3 id="流密码含义"><a href="#流密码含义" class="headerlink" title="流密码含义"></a>流密码含义</h3><p>流密码（Stream Cipher）是一种对称加密算法，它以比特流（bitstream）为单位进行加密和解密操作。与分组密码算法（如AES）不同，流密码对输入数据进行逐比特的处理，输出与输入数据流长度相同的密钥流（keystream），再将密钥流与明文（或密文）逐比特进行异或运算，以实现加密或解密的目的。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>流密码的设计思想主要包括伪随机性、混合运算、周期性、密钥保密性、生成速度和抗攻击性。</p>
<h2 id="非对称密码体制出现的原因"><a href="#非对称密码体制出现的原因" class="headerlink" title="非对称密码体制出现的原因"></a>非对称密码体制出现的原因</h2><p>为了解决对称密码体制的密钥管理困难问题</p>
<p>为了解决对称密码体制的密钥分配困难问题</p>
<p>为了满足对数字签名的需求</p>
<h2 id="非对称密码体制的含义"><a href="#非对称密码体制的含义" class="headerlink" title="非对称密码体制的含义"></a>非对称密码体制的含义</h2><p>将公开密钥公开，私有密钥保密</p>
<h2 id="非对称密码体制的原理"><a href="#非对称密码体制的原理" class="headerlink" title="非对称密码体制的原理"></a>非对称密码体制的原理</h2><p>非对称密码体制的原理是基于公钥和私钥的概念，利用公钥加密和私钥解密的算法实现加密和解密操作。同时，非对称密码体制还可以用于数字签名和密钥交换。它的安全性依赖于数学难题的困难性，提供了更高的安全性和灵活性。</p>
<h2 id="RSA算法含义"><a href="#RSA算法含义" class="headerlink" title="RSA算法含义"></a>RSA算法含义</h2><p>rsa一般指rsa加密算法。RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。1</p>
<h2 id="RSA算法设计思想"><a href="#RSA算法设计思想" class="headerlink" title="RSA算法设计思想"></a>RSA算法设计思想</h2><p>根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p>
<h2 id="RSA算法经典案例"><a href="#RSA算法经典案例" class="headerlink" title="RSA算法经典案例"></a>RSA算法经典案例</h2><img src = "./1.png">

<h2 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h2><p>椭圆曲线方程的一般形式是</p>
<p>$$<br>y^2+axy+by&#x3D;x^3+cx^2+dx+e<br>$$</p>
<p>有限域上的椭圆曲线<br>$$<br>E: y^2 &#x3D; (x^3+ax+b)(mod p)<br>$$</p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="密钥管理含义"><a href="#密钥管理含义" class="headerlink" title="密钥管理含义"></a>密钥管理含义</h2><p>密钥管理就是管理密钥从产生到销毁的过程，包括密钥的产生、存储、分配、保护、更新、吊销和销毁等。</p>
<h2 id="密钥分类"><a href="#密钥分类" class="headerlink" title="密钥分类"></a>密钥分类</h2><p>对称密钥和非对称密钥（公钥和私钥）</p>
<p>作用上：会话密钥、密钥加密密钥、主密钥</p>
<h2 id="密钥分发与协商技术含义，设计思想，存在的问题"><a href="#密钥分发与协商技术含义，设计思想，存在的问题" class="headerlink" title="密钥分发与协商技术含义，设计思想，存在的问题"></a>密钥分发与协商技术含义，设计思想，存在的问题</h2><p>密钥分发技术是指将密钥发送到数据交换的两方,而其他人无法看到的方法。</p>
<p>密钥协商是指需要保密通信的双方通过公开信道的通信来达成一个共享的秘密密钥的过程。</p>
<p>通常是一种协议，利用该协议，通信双方可以在一个公开的信道上通过相互传送一些消息来共同建立一个安全的共享秘密密钥。在密钥协商中，双方共同建立的秘密密钥通常是双方输入消息的一个函数。典型协议：Diffie-Hellman密钥交换协议</p>
<p>密钥分配与密钥协商过程都是用以在保密通信双方之间建立通信所使用的密钥的协议(或机制)。在这种协议(或机制)运行结束时，参与协议运行的双方都将得到相同的密钥，同时，所得到的密钥对于其他任何方(除可能的可信管理机构外)都是不可知的。</p>
<h2 id="密钥分发中心含义，作用，CA"><a href="#密钥分发中心含义，作用，CA" class="headerlink" title="密钥分发中心含义，作用，CA"></a>密钥分发中心含义，作用，CA</h2><p>通信各方建立一个大家都信赖的密钥分发中心（Key Distribution Center , KDC）， 解决对称密钥安全可靠的分发。</p>
<p>方法;通信发起方生成会话密钥，由KDC为A,B生成通信的会话密钥</p>
<p>要使公钥密码有效， 需要证实你拥有的公钥， 实际上就是要与你通信的实体的公钥。</p>
<p>将公钥与特定的实体绑定， 通常由认证中心（ Certification Authority，CA） 完成。</p>
<p>认证中心（ Certification Authority，CA） 的作用：</p>
<ol>
<li><p>CA可以证实一个实体的真实身份；</p>
</li>
<li><p>一旦CA验证了某个实体的身份， CA会生成一个把其身份和实体的公钥绑定起来的证书， 其中包含该实体的公钥及其全局唯一的身份识别信息等， 并由CA对证书进行数字签名；</p>
</li>
</ol>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="数字签名含义"><a href="#数字签名含义" class="headerlink" title="数字签名含义"></a>数字签名含义</h2><p>数字签名是以密码学的方法对数据文件作用产生的一组代表签名者身份与数据完整性的数据信息，通常附加在数据文件的后面。</p>
<h2 id="与传统签名的异同"><a href="#与传统签名的异同" class="headerlink" title="与传统签名的异同"></a>与传统签名的异同</h2><p>数字签名与书面签名的区别之一在于同一签名者对不同文件的数字签名是不相同的。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>数字签名就是用私有密钥进行加密，而认证就是利用公开密钥进行正确的解密。</p>
<h2 id="哈希函数含义"><a href="#哈希函数含义" class="headerlink" title="哈希函数含义"></a>哈希函数含义</h2><p>哈希函数是一个输入为任意长的二元串，输出为固定长度的二元串的函数。 </p>
<h1 id="哈希函数的结构"><a href="#哈希函数的结构" class="headerlink" title="哈希函数的结构"></a>哈希函数的结构</h1><img src = "./2.png">

<h2 id="安全哈希函数SHA算法含义"><a href="#安全哈希函数SHA算法含义" class="headerlink" title="安全哈希函数SHA算法含义"></a>安全哈希函数SHA算法含义</h2><p>含义：哈希函数是一个输入为任意长的二元串，输出为固定长度的二元串的函数。</p>
<h2 id="安全哈希函数SHA算法设计思想"><a href="#安全哈希函数SHA算法设计思想" class="headerlink" title="安全哈希函数SHA算法设计思想"></a>安全哈希函数SHA算法设计思想</h2><p>SHA算法的设计思想是通过单向性、唯一性、均匀性、高度复杂性和迭代性等手段，实现对输入数据的安全加密和哈希值的生成。</p>
<h2 id="消息认证含义"><a href="#消息认证含义" class="headerlink" title="消息认证含义"></a>消息认证含义</h2><p>消息认证是使消息的接收者能够检验收到的消息是否是真实的认证方法。消息认证的目的有两个：其以是消息源的认证，即验证消息的来源是真实的；其二是消息的认证，即验证信息在传送过程中未被篡改。</p>
<h2 id="消息认证的类型"><a href="#消息认证的类型" class="headerlink" title="消息认证的类型"></a>消息认证的类型</h2><p><strong>消息认证码</strong>：是以消息和密钥作为输入的公开函数，可以生成定长的输出。该方法需要在信息的发送方和接收方之间共享密钥。</p>
<p><strong>哈希函数</strong>：是不带密钥的公开函数，它将任意长度的输入信息映射为固定长度的输出值。</p>
<h2 id="身份认证技术包括数据源认证和实体身份认证"><a href="#身份认证技术包括数据源认证和实体身份认证" class="headerlink" title="身份认证技术包括数据源认证和实体身份认证"></a>身份认证技术包括数据源认证和实体身份认证</h2><h3 id="数据源认证"><a href="#数据源认证" class="headerlink" title="数据源认证"></a>数据源认证</h3><p>数据源认证夜称为消息认证，数据源认证是与数据完整性密切相关。数据源认证包含从发送者到接收者的消息传输过程，接收者在接收时会验证消息；接收方执行消息验证的目的在于确认消息发送者的身份；确认在原消息离开消息发送者之后的数据完整性以及确认消息传输的“活现性”</p>
<h3 id="实体身份认证"><a href="#实体身份认证" class="headerlink" title="实体身份认证"></a>实体身份认证</h3><p>通信实体可以是一个人、一个程序、一个客户或一个服务器。需要验证身份的实体称为原告；试图证明原告身份的一方称为验证者。在身份认证中，原告可以使用三种类型的证据来完成：知道某事、拥有某事、固有某事，向验证者证明自己的身份</p>
<h3 id="典型的身份认证系统"><a href="#典型的身份认证系统" class="headerlink" title="典型的身份认证系统"></a>典型的身份认证系统</h3><p>Kerberos系统（三向认证【对设备进行认证】）</p>
<p>Kerberos 认证的基本思想是使用可信第三方把某个用户引见给某个服务器，引见方法是在用户和服务器间分发会话密钥建立安全信道。</p>
<p>Kerberos 认证包括三个子协议，认证服务器交换(AS交换)、票证授予服务器交换(TGS 交换)、客户&#x2F;服务器认证应用交换(AP交换)</p>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="黑客含义、动机、黑客常用的攻击方法与攻击流程"><a href="#黑客含义、动机、黑客常用的攻击方法与攻击流程" class="headerlink" title="黑客含义、动机、黑客常用的攻击方法与攻击流程"></a>黑客含义、动机、黑客常用的攻击方法与攻击流程</h2><p>含义：从事对网络信息安全实施破坏性活动的黑客</p>
<p>动机：好奇心理；挑战性；报复心理；经济利益；政治目的；情报获取</p>
<p>攻击方法：入侵前：“踩点”是传统概念的电子化形式</p>
<p>入侵后：阻塞类攻击；控制类攻击；探测类攻击；欺骗类攻击；漏洞类攻击；病毒类攻击；电磁辐射类攻击</p>
<p>攻击流程：黑客攻击一个系统的流程一般来说分为：侦察，扫描；获取访问；维持访问；擦除踪迹</p>
<h2 id="社会工程学攻击技术含义，作用"><a href="#社会工程学攻击技术含义，作用" class="headerlink" title="社会工程学攻击技术含义，作用"></a>社会工程学攻击技术含义，作用</h2><p>社会工程学的攻击技术（社会工程学是一种利用人际关系的互动性，通过人的本能反应、好奇心、新人、贪婪等心理弱点实施诸如窃取、欺骗等危害手段，取得访问保密信息系统的权限以获取非法利益的攻击行为。[在线攻击、电话攻击、垃圾搜寻、公共信息挖掘、范向社会工程学]）</p>
<p>作用：信息获取、身份欺骗、网络入侵、社交工具滥用、内部威胁</p>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="网路漏洞含义"><a href="#网路漏洞含义" class="headerlink" title="网路漏洞含义"></a>网路漏洞含义</h2><p>含义：硬件，软件或策略上的缺陷，由于这些缺陷，使得攻击者能够在未经授权的情况下访问计算机系统</p>
<h2 id="存在漏洞的原因"><a href="#存在漏洞的原因" class="headerlink" title="存在漏洞的原因"></a>存在漏洞的原因</h2><p>网络协议漏洞(TPC&#x2F;IP协议)、应用软件系统漏洞、配置不当引起的漏洞</p>
<h2 id="漏洞的危害"><a href="#漏洞的危害" class="headerlink" title="漏洞的危害"></a>漏洞的危害</h2><p>对系统的完整性、系统的可用性、系统的机密性、系统的可控性、系统的可靠性产生危害。</p>
<h2 id="常见的漏洞扫描工具"><a href="#常见的漏洞扫描工具" class="headerlink" title="常见的漏洞扫描工具"></a>常见的漏洞扫描工具</h2><p>NetCat、Nmap、SATAN、Nessus、X-Scan、PScan</p>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="入侵检测含义"><a href="#入侵检测含义" class="headerlink" title="入侵检测含义"></a>入侵检测含义</h2><p>对潜在的、有预谋的、未经授权的访问信息、操作信息致使系统不可靠、不稳定或无法使用的企图的检测和监视</p>
<p>分为两种方法：被动、非在线地发现和实时、在线地发现计算机网络系统中的攻击者。</p>
<h2 id="入侵检测模型、含义、优缺点"><a href="#入侵检测模型、含义、优缺点" class="headerlink" title="入侵检测模型、含义、优缺点"></a>入侵检测模型、含义、优缺点</h2><img src = "./3.png">

<p>含义：指在计算机网络或计算机系统中的若干关键点收集信息并对收集到的信息进行分析，从而判断网络或系统中是否有违反安全策略的行为和被攻击的迹象，它是对入侵行为的发觉</p>
<p>模型：CIDF通用入侵检测模型</p>
<h2 id="入侵检测系统的构成，分类"><a href="#入侵检测系统的构成，分类" class="headerlink" title="入侵检测系统的构成，分类"></a>入侵检测系统的构成，分类</h2><p>事件提取、入侵分析、入侵响应和远程管理四部分功能。</p>
<p>从数据来源角度分类，基于网络、基于主机和分布式入侵检测系统</p>
<p>从检测的策略角度分类，滥用检测、异常检测和完整性分析。</p>
<h2 id="基于网络的入侵检测与基于主机的入侵检测的优缺点"><a href="#基于网络的入侵检测与基于主机的入侵检测的优缺点" class="headerlink" title="基于网络的入侵检测与基于主机的入侵检测的优缺点"></a>基于网络的入侵检测与基于主机的入侵检测的优缺点</h2><p>基于主机的优点：监视特定的系统活动，非常适用于被加密的和交换的环境；近实时的检测和应答；不需要额外的硬件</p>
<p>基于网络的优点：拥有成本低，攻击者转移证据困难；实时检测和响应；能够检测未成功的攻击企图；操作系统独立</p>
<h2 id="入侵检测系统的评估指标"><a href="#入侵检测系统的评估指标" class="headerlink" title="入侵检测系统的评估指标"></a>入侵检测系统的评估指标</h2><p>收集信息攻击；获取访问权限攻击；拒绝服务攻击；逃避检测攻击</p>
<h2 id="snort系统的构成，规则结构，典型的规则实例"><a href="#snort系统的构成，规则结构，典型的规则实例" class="headerlink" title="snort系统的构成，规则结构，典型的规则实例"></a>snort系统的构成，规则结构，典型的规则实例</h2><p>包括四个模块：数据包嗅探器、预处理器、检测引擎和报警输出模块。</p>
<ul>
<li><p>规则结构<br>Snort采用基于规则的网络入侵模式搜索机制，对网络数据包进行模式匹配，从中发现入侵或恶意攻击行为。Snort将已知的入侵行为以规则的形式存放在规则库中，每一条规则由规则头和规则选项两个部分组成。</p>
</li>
<li><p>典型的规则实例<br>端口扫描、系统后门、拒绝服务、缓冲区溢出</p>
</li>
</ul>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="实现web安全的方法"><a href="#实现web安全的方法" class="headerlink" title="实现web安全的方法"></a>实现web安全的方法</h2><p>在网络层，由于IP数据包本身不具备任何安全特性，很容易被修改，伪造，查看或重播，IPSec可提供端到端的安全机制，可对数据包进行安全处理，支持数据加密可确保资料的完整性。在TCP传输层上实现数据的安全传输可采用SSL和TLS来提供安全服务。在应用层实现通信安全的标准有SEL协议，S&#x2F;MIME,PGP,可以在相应的应用中提供机密性，完整性和不可抵赖性等安全服务</p>
<h2 id="安全套接字层是传输层的安全协议，含义，提供的三种安全服务，体系结构"><a href="#安全套接字层是传输层的安全协议，含义，提供的三种安全服务，体系结构" class="headerlink" title="安全套接字层是传输层的安全协议，含义，提供的三种安全服务，体系结构"></a>安全套接字层是传输层的安全协议，含义，提供的三种安全服务，体系结构</h2><p>SSL是一种构建在TCP协议之上的保密措施通信协议</p>
<p>三种安全服务：信息保密，信息完整性和相互认证</p>
<p>SSL由两层组成，底层是SSL记录层，用于封装不同的上层协议：SSL握手协议、SSL密码更改规则协议和SSL报警协议。</p>
<h2 id="PGP-S-x2F-MIME应用层的安全协议，含义，原理"><a href="#PGP-S-x2F-MIME应用层的安全协议，含义，原理" class="headerlink" title="PGP,S&#x2F;MIME应用层的安全协议，含义，原理"></a>PGP,S&#x2F;MIME应用层的安全协议，含义，原理</h2><p>PGP是一种长期在学术圈和技术圈内得到广泛使用的安全邮件标准，也是一种供大众使用的加密软件</p>
<p>PGP原理：对称加密、公钥加密、数字签名、密钥管理</p>
<p>S&#x2F;MIME是一个邮件加密专用协议。</p>
<p>S&#x2F;MIME原理：数字证书、公钥加密、数字签名、MIME封装</p>
<h2 id="网络层的安全协议Ipsec，解决的网络的安全问题，体系结构"><a href="#网络层的安全协议Ipsec，解决的网络的安全问题，体系结构" class="headerlink" title="网络层的安全协议Ipsec，解决的网络的安全问题，体系结构"></a>网络层的安全协议Ipsec，解决的网络的安全问题，体系结构</h2><p>要解决网络的安全问题，就要首先解决IP的安全问题。IPSec正是解决IP通信安全的一个可行方案，它是一组协议，包含了12个RFC文件和几十个Internet草案，已经成为工业标准的网络安全协议。</p>
<p>IPSec通过使用两种通信安全协议：认证头(AH)和封装安全载荷(ESP)以及像Internet密钥交换(IKE)协议这样的密钥管理过程和协议来实现安全性。</p>
<h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="防火墙的含义，原理，分类"><a href="#防火墙的含义，原理，分类" class="headerlink" title="防火墙的含义，原理，分类"></a>防火墙的含义，原理，分类</h2><p>含义:防火墙是在两个网络之间执行访问控制策略的一个或一组系统,包括硬件和软件,目的是保护网络不被他人侵入。</p>
<p>原理：基于网络体系结构的防火墙原理，基于双网络堆栈Dual Network Stack的防火墙原理</p>
<p>分类：按实现技术方式来分类，防火墙可分为包过滤防火墙，应用网关防火墙，代理防火墙和状态检测防火墙</p>
<p>从形态上来分类，防火墙可以分为软件防火墙和硬件防火墙</p>
<h2 id="防火墙的技术"><a href="#防火墙的技术" class="headerlink" title="防火墙的技术"></a>防火墙的技术</h2><p>隔离的技术，管理的技术，防火墙操作系统的技术，通信堆叠的技术，网络地址转换技术，多重地址转换技术，虚拟私有网络技术，动态密码认证技术，代理服务器技术</p>
<h2 id="防火墙的体系结构"><a href="#防火墙的体系结构" class="headerlink" title="防火墙的体系结构"></a>防火墙的体系结构</h2><p>双重宿主主机体系结构；堡垒主机过滤体系结构；过滤子网体系结构；应用层网关体系结构</p>
<h2 id="防火墙规则的设计策略"><a href="#防火墙规则的设计策略" class="headerlink" title="防火墙规则的设计策略"></a>防火墙规则的设计策略</h2><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="计算机病毒含义，特征，危害"><a href="#计算机病毒含义，特征，危害" class="headerlink" title="计算机病毒含义，特征，危害"></a>计算机病毒含义，特征，危害</h2><p>计算机病毒是指编制者在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码。</p>
<p>特征：传染性，寄生性，隐蔽性，破坏性，潜伏性，可触发性</p>
<p>危害：盗窃数据信息，破坏数据信息，破坏硬件设备，耗费系统资源，影响运作速度，给用户造成心理压力</p>
<h2 id="计算机病毒的工作原理"><a href="#计算机病毒的工作原理" class="headerlink" title="计算机病毒的工作原理"></a>计算机病毒的工作原理</h2><p>计算机病毒是具有一定破坏作用且会自动复制并传播自己的程序，它是不受人欢迎的，没有人会主动在自己的计算机上去运行病毒程序。但是作为程序，病毒为了实现自我必须要获得被运行的机会，因此，病毒的运行过程一般情况下就是隐藏自身并偷偷地获取被运行的机会，当被执行之后不断复制自身并广泛传播，条件成熟后发作，进行破坏活动。</p>
<h2 id="计算机病毒的检测技术与防治措施"><a href="#计算机病毒的检测技术与防治措施" class="headerlink" title="计算机病毒的检测技术与防治措施"></a>计算机病毒的检测技术与防治措施</h2><p>检测：特征代码法，检验和法，行为检测法，虚拟执行法</p>
<p>防治措施：严格的管理，有效的技术</p>
<h2 id="恶意代码与计算机病毒区别，及其分类"><a href="#恶意代码与计算机病毒区别，及其分类" class="headerlink" title="恶意代码与计算机病毒区别，及其分类"></a>恶意代码与计算机病毒区别，及其分类</h2><p>分类：病毒，蠕虫，木马，后门程序，广告软件&#x2F;间谍软件，移动代码，rootkit，下载器，逻辑炸弹，口令嗅探器，钓鱼程序，其他类别</p>
<h1 id="长的题目"><a href="#长的题目" class="headerlink" title="长的题目"></a>长的题目</h1><h2 id="以及经典算法DES与AES含义，算法思想，DES与AES的S盒异同；"><a href="#以及经典算法DES与AES含义，算法思想，DES与AES的S盒异同；" class="headerlink" title="以及经典算法DES与AES含义，算法思想，DES与AES的S盒异同；"></a>以及经典算法DES与AES含义，算法思想，DES与AES的S盒异同；</h2><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>DES算法是1977年由美国国家标准局公布的第一个分组密码算法。</p>
<ol>
<li>提供高质量的数据保护，防止数据未经授权的泄露和未被察觉的修改。</li>
<li>具有一定程度的复杂性，使得破译的开销超过可能获得的利益，同时又要便于掌握和计算机软硬件的实现。</li>
<li>密码体制的安全性不依赖于算法的保密，仅依赖于密钥的保密和算法自身的强度。</li>
<li>实现经济、运行有效，并且适用于多种不同的应用场合</li>
</ol>
<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>初始置换（Initial Permutation）：将明文按照预定义的顺序进行置换，以增加密码算法的随机性和复杂性。</p>
<p>轮函数（Round Function）：DES算法使用了16轮迭代加密过程。在每一轮中，明文经过扩展置换、与子密钥进行异或运算、S盒替换和P盒置换等操作，以增加密码算法的混淆和扩散效果。</p>
<p>子密钥生成（Key Schedule）：DES算法使用了一个56位的初始密钥，通过经过置换和循环移位等操作生成16个48位的子密钥，用于每一轮的加密操作。</p>
<p>S盒替换（S-Box Substitution）：DES算法中使用了8个不同的S盒，每个S盒将6位输入映射为4位输出。S盒替换增加了密码算法的非线性性，提高了加密的安全性。</p>
<p>P盒置换（P-Box Permutation）：在每一轮的迭代中，经过S盒替换后的结果再经过P盒置换，以增加密码算法的扩散效果。</p>
<p>逆初始置换（Final Permutation）：在最后一轮迭代完成后，将经过16轮迭代加密后的结果按照逆初始置换进行置换，得到最终的密文。</p>
<p>DES算法的核心思想是通过多轮迭代和复杂的置换、替换运算，将明文转换为密文。</p>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>AES是一种对称加密算法，也被称为Rijndael算法。它是目前广泛应用的加密标准，被用于保护敏感信息的安全性。</p>
<p>AES算法的含义可以解释如下：</p>
<p>高级（Advanced）：AES算法采用了先进的加密技术和复杂的运算过程，以提供更强大的安全性和防御能力。</p>
<p>加密（Encryption）：AES算法使用对称密钥加密，即使用相同的密钥进行加密和解密操作。它可以将明文转换为密文，以保护数据的机密性。</p>
<p>标准（Standard）：AES算法是由美国国家标准与技术研究院（NIST）于2001年发布的标准加密算法。它在全球范围内被广泛接受和应用。</p>
<h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>AES（Advanced Encryption Standard）的算法思想可以简要概括如下：</p>
<p>轮变换、轮密钥生成、解密</p>
<p>AES算法的核心思想是通过多轮迭代和复杂的置换、替换、混淆运算，将明文转换为密文。</p>
<h3 id="S盒异同"><a href="#S盒异同" class="headerlink" title="S盒异同"></a>S盒异同</h3><ul>
<li><p>异同之处：</p>
<p>  数量和大小：DES使用了8个S盒，每个S盒都是4x16的二维表格，每个元素为4位；而AES使用了4个S盒，每个S盒都是16x16的二维表格，每个元素为8位。</p>
<p>  输入输出位数：DES的S盒输入为6位，输出为4位；而AES的S盒输入为8位，输出也为8位。</p>
<p>  构造方式：DES的S盒是通过代换构造的，即通过预定义的置换表将输入的6位映射到输出的4位；而AES的S盒是通过有限域上的运算（如乘法和逆变换）构造的。</p>
<p>  作用和位置：DES的S盒用于替换轮函数中的一部分输入，增加密码算法的非线性性；而AES的S盒用于字节替换操作，增加密码算法的非线性性。</p>
</li>
<li><p>相似之处：</p>
<p>  都用于增加密码算法的非线性性：无论是DES还是AES，S盒都是用来增加密码算法的非线性性，以提高密码算法的安全性。</p>
<p>  都是固定的置换表：DES和AES的S盒都是预定义的固定置换表，不会随着密钥或明文的变化而改变。</p>
</li>
</ul>
<h2 id="入侵检测，模型"><a href="#入侵检测，模型" class="headerlink" title="入侵检测，模型"></a>入侵检测，模型</h2><img src = "./4.png">

<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">异常入侵检测技术(Anomaly Detection)，也称为基于行为的入侵检测技术，是指根据用户的行为和系统资源的使用状况来检测是否存在网络入侵。</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>异常入侵检测技术的优点是：</span><br><span class="line">①能够检测出使用新的网络入侵方法的攻击；</span><br><span class="line">②较少依赖于特定的主机操作系统。</span><br><span class="line">异常入侵检测技术的缺点是：</span><br><span class="line">①误报率高；</span><br><span class="line">②行为模型建立困难；</span><br></pre></td></tr></table></figure>

<img src = "./5.png">

<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">误用人侵检测技术<span class="comment">(Misuse Detection)</span>，也称为基于特征<span class="comment">(Signature)</span>的入侵检测技术，根据已知的网络攻击方法或系统安全缺陷方面的知识，建立特征数据库，然后在收集到的网络活动中进行特征匹配来检测是否存在网络入侵。</span><br><span class="line"></span><br><span class="line">- 误用入侵检测技术的优点是：</span><br><span class="line">①检测准确度高；</span><br><span class="line">②技术相对成熟；</span><br><span class="line">③便于进行系统防护。</span><br><span class="line">误用入侵检测技术的缺点是：</span><br><span class="line">①不能检测出新的网络入侵方法的攻击；</span><br><span class="line">②完全依赖于入侵特征的有效性；</span><br><span class="line">③维护特征库的工作量巨大。</span><br></pre></td></tr></table></figure>

<h2 id="VPN含义，分类，隧道原理"><a href="#VPN含义，分类，隧道原理" class="headerlink" title="VPN含义，分类，隧道原理"></a>VPN含义，分类，隧道原理</h2><p>VPN是Virtual Private Network（虚拟专用网络）的缩写，是一种通过公共网络（如互联网）建立加密连接的技术。它可以在不安全的公共网络上创建一个安全的通信通道，使用户能够安全地访问私有网络资源。</p>
<p>分类：Access VPN、Intranet VPN、Extranet VPN</p>
<p>二层隧道协议:用于传输二层网络协议，主要有三种PPTP协议、L2F协议、L2TP协议，它主要应用于构建 Access VPN 和 Extranet VPN</p>
<p>三层隧道协议：用于传输三层网络协议，它主要应用能够与构建 Intranet VPN 和 Extranet VPN</p>
<p>应用层的 SSL VPN： 用于基于 Web的应用，借助浏览器与VPN网关建立SSL连接，主要应用于 Access VPN</p>
<h2 id="网络攻击技术分类，含义"><a href="#网络攻击技术分类，含义" class="headerlink" title="网络攻击技术分类，含义"></a>网络攻击技术分类，含义</h2><p>拨号和VPN攻击技术(VPN是指通过公众IP网络建立私有数据传输通道，将远程的分支办公室、移动办公人员等连接起来，减轻企业远程访问费用负担。)</p>
<p><strong>针对防火墙的攻击技术</strong>（IP地址欺骗[突破防火墙系统最常用的方法是存储地址欺骗，它同时也是其他一系列攻击方法的基础。]，<strong>TCP序号攻击</strong>[TCP序号攻击是绕过基于分组过滤方法的防火墙系统的最有效和最危险的方式之一]，<strong>IP分段攻击</strong>[把IP数据分组分段的办法来处理仅支持给定最大IP分组长度的网络部分]，<strong>基于Postscript的攻击</strong>[使用端口80传送内部信息给攻击者]，<strong>基于堡垒主机Web服务器的攻击</strong>[设法把堡垒主机Web服务器转变成避开防火墙内外部路由器作用或影响的系统。]，<strong>IP隧道攻击</strong>[在80端口发送能产生穿过防火墙的IP隧道的程序]，<strong>计算机病毒攻击</strong>[一种把自己复制为更大的程序并加以改变的代码段，它只是在程序开始运行时执行，然后病毒复制它自己，并在复制时影响其他程序]，<strong>前缀扫描攻击、特洛伊木马攻击</strong>【藏匿在某一段合法程序内完成伪装预定功能的代码段】）</p>
<p>网络拒绝服务攻击技术（Dos是指故意攻击网络协议的缺陷或直接通过野蛮手段耗尽被攻击对象的资源）</p>
<img src = "./6.png">]]></content>
      <categories>
        <category>计算机网络安全</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>123</title>
    <url>/2023/12/22/123/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/12/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>考试专用</tag>
      </tags>
  </entry>
</search>
