<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/06/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>嵌入式笔记</title>
    <url>/2023/06/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="嵌入式笔记整理"><a href="#嵌入式笔记整理" class="headerlink" title="嵌入式笔记整理"></a>嵌入式笔记整理</h1><h2 id="第一章-嵌入式系统设计基础"><a href="#第一章-嵌入式系统设计基础" class="headerlink" title="第一章 嵌入式系统设计基础"></a>第一章 嵌入式系统设计基础</h2><h3 id="1-1-嵌入式系统概述"><a href="#1-1-嵌入式系统概述" class="headerlink" title="1.1 嵌入式系统概述"></a>1.1 嵌入式系统概述</h3><h4 id="1-1-1-什么是嵌入式系统"><a href="#1-1-1-什么是嵌入式系统" class="headerlink" title="1.1.1 什么是嵌入式系统"></a>1.1.1 什么是嵌入式系统</h4><p>嵌入式系统是<strong>以应用为中心</strong>，<strong>以计算机技术</strong>为基础，软件、硬件<strong>可剪裁</strong>，以适用于应用系统对功能、可靠性、成本、体积、功耗等要求严格的<strong>专用计算机系统</strong>。</p>
<span id="more"></span>
<h4 id="1-1-2-嵌入式系统的技术特点"><a href="#1-1-2-嵌入式系统的技术特点" class="headerlink" title="1.1.2 嵌入式系统的技术特点"></a>1.1.2 嵌入式系统的技术特点</h4><p>四大特性：专用性、低成本、可裁剪性、可靠性</p>
<h4 id="1-1-3-嵌入式系统的组成"><a href="#1-1-3-嵌入式系统的组成" class="headerlink" title="1.1.3 嵌入式系统的组成"></a>1.1.3 嵌入式系统的组成</h4><p>分为硬件设备和软件设备，嵌入式处理器-&gt;硬件核心。</p>
<img src = "./1.png">

<h5 id="1）嵌入式处理器类型"><a href="#1）嵌入式处理器类型" class="headerlink" title="1）嵌入式处理器类型"></a>1）嵌入式处理器类型</h5><p>微控制器(MCU)；嵌入式微处理器(MPU)；数字信号处理器(DSP)；片上系统(Soc)</p>
<h5 id="2）嵌入式操作系统"><a href="#2）嵌入式操作系统" class="headerlink" title="2）嵌入式操作系统"></a>2）嵌入式操作系统</h5><p>谷歌的Android系统和苹果的iOS系统。实时操作系统常用免费的uC&#x2F;OS-II或者商业化的VxWorks等。</p>
<h3 id="1-2-嵌入式系统的开发"><a href="#1-2-嵌入式系统的开发" class="headerlink" title="1.2 嵌入式系统的开发"></a>1.2 嵌入式系统的开发</h3><h4 id="1-2-1-嵌入式系统的开发模式"><a href="#1-2-1-嵌入式系统的开发模式" class="headerlink" title="1.2.1 嵌入式系统的开发模式"></a>1.2.1 嵌入式系统的开发模式</h4><p>宿主机-目标机(开发模式)</p>
<h2 id="第二章-ARM-Cortex-M3-处理器"><a href="#第二章-ARM-Cortex-M3-处理器" class="headerlink" title="第二章 ARM Cortex-M3 处理器"></a>第二章 ARM Cortex-M3 处理器</h2><h3 id="2-2-Cortex-M3-处理器"><a href="#2-2-Cortex-M3-处理器" class="headerlink" title="2.2 Cortex-M3 处理器"></a>2.2 Cortex-M3 处理器</h3><ul>
<li>CM3的功能模块<br>高性能32位RISC处理器；大量寄存器，都可用于多种用途；采用Thumb指令集结构；3级流水线（取指-译码-执行）；采用哈佛存储结构；高级微控制器总线结构</li>
</ul>
<p>CM3的两个状态两个级别两种模式</p>
<img src = "./2.png">

<ul>
<li>两个状态：Thumb状态、调试状态 </li>
<li>两个级别：特权级、非特权级</li>
<li>两种模式：异常处理模式、线程模式</li>
</ul>
<h3 id="2-3-寄存器"><a href="#2-3-寄存器" class="headerlink" title="2.3 寄存器"></a>2.3 寄存器</h3><h4 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1.通用寄存器"></a>1.通用寄存器</h4><img src = "./3.png">

<p>CM3设计有16个32位通用寄存器，R0~R12是真正意义上的通用寄存器。</p>
<h4 id="2-专用寄存器"><a href="#2-专用寄存器" class="headerlink" title="2.专用寄存器"></a>2.专用寄存器</h4><img src = "./4.png">

<p>专用寄存器不通过存储器地址访问，而是使用专用寄存器访问指令</p>
<ul>
<li><p>程序状态寄存器(Program Status Register,PSR)</p>
</li>
<li><p>异常屏蔽位寄存器(Exception Mask Register)</p>
</li>
</ul>
<h3 id="2-4-存储器组织"><a href="#2-4-存储器组织" class="headerlink" title="2.4 存储器组织"></a>2.4 存储器组织</h3><h5 id="1-位带区"><a href="#1-位带区" class="headerlink" title="1.位带区"></a>1.位带区</h5><img src = "./5.png">

<p>别名地址&#x3D;位带基地址+字节偏移量×32+位号×4</p>
<ul>
<li><p>位带基地址通常情况下为:0x22000以及0x42000</p>
</li>
<li><p>字节偏移量根据要访问的位带地址距离基地址0x2000和0x4000的偏移值</p>
</li>
<li><p>位号：题目会给</p>
</li>
</ul>
<h5 id="2-字节存储顺序"><a href="#2-字节存储顺序" class="headerlink" title="2.字节存储顺序"></a>2.字节存储顺序</h5><img src = "./6.png">

<p>低位低，高位高（小端存储）；高位低，低位高（大端存储）</p>
<h2 id="第四章-STM32-微控制器"><a href="#第四章-STM32-微控制器" class="headerlink" title="第四章 STM32 微控制器"></a>第四章 STM32 微控制器</h2><h3 id="4-1-STM32微控制器结构"><a href="#4-1-STM32微控制器结构" class="headerlink" title="4.1 STM32微控制器结构"></a>4.1 STM32微控制器结构</h3><h4 id="4-1-2-STM32系统结构"><a href="#4-1-2-STM32系统结构" class="headerlink" title="4.1.2 STM32系统结构"></a>4.1.2 STM32系统结构</h4><img src = "./7.png">

<ul>
<li>通用输入&#x2F;输出端口(GPIO)以及复用功能的输入&#x2F;输出端口(AFIO)</li>
<li>通用同步&#x2F;异步接收发送器(USART)；通用异步接收发送器(UART)</li>
<li>串行外设接口(SPI)</li>
<li>内部集成电路I2C接口(I2C)</li>
<li>看门狗(Watch Dog)，独立看门狗(IWDG)和窗口看门狗(WWDG)</li>
<li>实时时钟(RTC)</li>
<li>通用定时器(TIMx)</li>
<li>模拟&#x2F;数字转换器ADC</li>
</ul>
<table>
<thead>
<tr>
<th>缩写</th>
<th>外设名称</th>
<th>缩写</th>
<th>外设名称</th>
</tr>
</thead>
<tbody><tr>
<td>adc</td>
<td>A&#x2F;D转换器</td>
<td>bkp</td>
<td>备份寄存器</td>
</tr>
<tr>
<td>can</td>
<td>CAN控制器局域网</td>
<td>cec</td>
<td>消费电子单元</td>
</tr>
<tr>
<td>crc</td>
<td>CRC计算单元</td>
<td>dac</td>
<td>D&#x2F;A转换器</td>
</tr>
<tr>
<td>dbgmc</td>
<td>MCU调试模块</td>
<td>dma</td>
<td>DMA控制器</td>
</tr>
<tr>
<td>exti</td>
<td>外部中断寄存器</td>
<td>flash</td>
<td>闪存</td>
</tr>
<tr>
<td>fsmc</td>
<td>灵活的静态存储器控制器</td>
<td>gpio</td>
<td>通用I&#x2F;O接口</td>
</tr>
<tr>
<td>i2c</td>
<td>I²C总线接口</td>
<td>iwdg</td>
<td>独立看门狗</td>
</tr>
<tr>
<td>pwr</td>
<td>电源控制</td>
<td>rcc</td>
<td>复位和时钟控制器</td>
</tr>
<tr>
<td>rtc</td>
<td>实时时钟</td>
<td>sdio</td>
<td>SD存储卡接口</td>
</tr>
<tr>
<td>spi</td>
<td>SPI串行外设接口</td>
<td>tim</td>
<td>定时器</td>
</tr>
<tr>
<td>usart</td>
<td>通用同步异步收发器</td>
<td>wwdg</td>
<td>窗口看门狗</td>
</tr>
</tbody></table>
<h3 id="4-2-STM32微控制器开发"><a href="#4-2-STM32微控制器开发" class="headerlink" title="4.2 STM32微控制器开发"></a>4.2 STM32微控制器开发</h3><h4 id="4-2-3-C语言应用"><a href="#4-2-3-C语言应用" class="headerlink" title="4.2.3 C语言应用"></a>4.2.3 C语言应用</h4><h5 id="2-C语言的位操作"><a href="#2-C语言的位操作" class="headerlink" title="2. C语言的位操作"></a>2. C语言的位操作</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>) <span class="comment">//位与实现复位:将整形变量a的D6位清零，其他位不变。</span></span><br><span class="line">a |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) <span class="comment">// 位或实现置位:将整形变量a的D6位置位，其他位不变。</span></span><br><span class="line">a ^= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>) <span class="comment">// 位异或实现求反：将整形变量a的D6位取反，其他位不变</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-复位与时钟控制-RCC"><a href="#4-3-复位与时钟控制-RCC" class="headerlink" title="4.3 复位与时钟控制(RCC)"></a>4.3 复位与时钟控制(RCC)</h3><h5 id="1-电源控制"><a href="#1-电源控制" class="headerlink" title="1. 电源控制"></a>1. 电源控制</h5><p>3种低功耗模式</p>
<ul>
<li><p>睡眠模式(Sleep Mode)</p>
</li>
<li><p>停止模式(Stop Mode)</p>
</li>
<li><p>备用模式(Standby Mode)</p>
</li>
</ul>
<h5 id="2-复位"><a href="#2-复位" class="headerlink" title="2. 复位"></a>2. 复位</h5><p>三种复位：系统复位、电源复位和备份复位</p>
<h5 id="3-时钟树"><a href="#3-时钟树" class="headerlink" title="3. 时钟树"></a>3. 时钟树</h5><p>系统时钟 SYSCLK</p>
<p>内部高速时钟HIS、高速外部时钟HSE和锁相环PLL</p>
<h2 id="第五章-STM32的通用I-x2F-O端口"><a href="#第五章-STM32的通用I-x2F-O端口" class="headerlink" title="第五章 STM32的通用I&#x2F;O端口"></a>第五章 STM32的通用I&#x2F;O端口</h2><h3 id="5-1-GPIO的结构和功能"><a href="#5-1-GPIO的结构和功能" class="headerlink" title="5.1 GPIO的结构和功能"></a>5.1 GPIO的结构和功能</h3><p>GPIO一共112个引脚，用GPIOx(x是A、B、C、D、E、F、G)表示，即GPIOA GPIOB … GPIOG。每组端口有16个外设引脚，分别用Px0,Px1,…Px15(x是A~G)表示。</p>
<h5 id="1-输入模式"><a href="#1-输入模式" class="headerlink" title="1.输入模式"></a>1.输入模式</h5><p>4种输入模式：</p>
<ul>
<li>模拟输入模式(Analog): 不上拉也不下拉</li>
<li>浮空输入模式(Input Floating): 不上拉也不下拉 </li>
<li>上拉输入模式(Input Pull-up): 接上拉电阻</li>
<li>下拉输入模式(Input Pull-down): 接下拉电阻</li>
</ul>
<h5 id="2-输出模式"><a href="#2-输出模式" class="headerlink" title="2. 输出模式"></a>2. 输出模式</h5><p>4中输出模式，但是常用以下两种输出模式:</p>
<ul>
<li><p>推挽输出(Output Push-Pull)</p>
</li>
<li><p>开漏输出(Output Open-Drain)</p>
</li>
</ul>
<h3 id="5-3-GPIO-案例"><a href="#5-3-GPIO-案例" class="headerlink" title="5.3 GPIO 案例"></a>5.3 GPIO 案例</h3><h4 id="5-3-2-应用程序分析"><a href="#5-3-2-应用程序分析" class="headerlink" title="5.3.2 应用程序分析"></a>5.3.2 应用程序分析</h4><h5 id="1-开启外设时钟"><a href="#1-开启外设时钟" class="headerlink" title="1. 开启外设时钟"></a>1. 开启外设时钟</h5><h5 id="2-初始化外设"><a href="#2-初始化外设" class="headerlink" title="2. 初始化外设"></a>2. 初始化外设</h5><h5 id="3-控制外设工作"><a href="#3-控制外设工作" class="headerlink" title="3. 控制外设工作"></a>3. 控制外设工作</h5><h4 id="5-3-3-实例代码"><a href="#5-3-3-实例代码" class="headerlink" title="5.3.3 实例代码"></a>5.3.3 实例代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOB，GPIO_PIN_5，GPIO_PIN_RESET)；</span><br><span class="line"><span class="comment">// PB5引脚输出低电平，LED0灯亮</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5,GPIO_PIN_SET);</span><br><span class="line"><span class="comment">// PE5 引脚输出高电平，LED1灯灭</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>) <span class="comment">//持续1秒</span></span><br><span class="line"></span><br><span class="line">HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5);</span><br><span class="line"><span class="comment">// 读取PC5引脚的电平状态</span></span><br><span class="line"></span><br><span class="line">HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_3);</span><br><span class="line"><span class="comment">// 反转 PE3 引脚的电平状态</span></span><br></pre></td></tr></table></figure>


<h2 id="第六章-CM3异常和STM32中断"><a href="#第六章-CM3异常和STM32中断" class="headerlink" title="第六章 CM3异常和STM32中断"></a>第六章 CM3异常和STM32中断</h2><h3 id="6-1-Cortex-M3-的异常"><a href="#6-1-Cortex-M3-的异常" class="headerlink" title="6.1 Cortex-M3 的异常"></a>6.1 Cortex-M3 的异常</h3><h5 id="2-异常优先级"><a href="#2-异常优先级" class="headerlink" title="2.异常优先级"></a>2.异常优先级</h5><p>优先级的数值越小，优先级越高</p>
<p>组优先级（Group Priority）和子优先级(Sub-Priority)。组优先级被称为抢占优先级。</p>
<p>组优先级确定是否可以打断正在执行的中断，实现嵌套。子优先级只用于在相同组优先级时多个子优先级同时出现的情况，高优先级别（优先级数值小）的异常首先被处理。</p>
<h5 id="3-嵌套向量中断控制器NVIC"><a href="#3-嵌套向量中断控制器NVIC" class="headerlink" title="3. 嵌套向量中断控制器NVIC"></a>3. 嵌套向量中断控制器NVIC</h5><p>NVIC 集成在 ARM Cortex-M3 内核中</p>
<h3 id="6-2-STM32的中断应用"><a href="#6-2-STM32的中断应用" class="headerlink" title="6.2 STM32的中断应用"></a>6.2 STM32的中断应用</h3><h4 id="6-2-1-NVIC-初始化配置"><a href="#6-2-1-NVIC-初始化配置" class="headerlink" title="6.2.1 NVIC 初始化配置"></a>6.2.1 NVIC 初始化配置</h4><h5 id="1-配置组优先级"><a href="#1-配置组优先级" class="headerlink" title="1. 配置组优先级"></a>1. 配置组优先级</h5><img src = "./8.png">

<h4 id="6-2-2-外部中断EXTI"><a href="#6-2-2-外部中断EXTI" class="headerlink" title="6.2.2 外部中断EXTI"></a>6.2.2 外部中断EXTI</h4><p>STM32 芯片外设的中断请求直接连接到 NVIC，来自芯片之外的外设中断请求需要通过EXTI（外部中断&#x2F;事件控制器）连接到NVIC。</p>
<h5 id="2-EXTI-寄存器"><a href="#2-EXTI-寄存器" class="headerlink" title="2. EXTI 寄存器"></a>2. EXTI 寄存器</h5><img src = "./9.png">

<img src = "./10.png">

<h2 id="第七章-STM32-的串行通信接口"><a href="#第七章-STM32-的串行通信接口" class="headerlink" title="第七章 STM32 的串行通信接口"></a>第七章 STM32 的串行通信接口</h2><h3 id="7-1-串行异步通信"><a href="#7-1-串行异步通信" class="headerlink" title="7.1 串行异步通信"></a>7.1 串行异步通信</h3><p>串行通信有两类：<strong>一类</strong>是速度较快的同步串行通信，以数据块为基本传输单位，主要应用于网络连接；<strong>另一类</strong>是速度较慢的异步通信，以字符为单位传输，主要应用于近距离通信。通常所说的串行通信一般是指<strong>串行同步通信</strong></p>
<h4 id="7-1-1-串行异步通信字符格式"><a href="#7-1-1-串行异步通信字符格式" class="headerlink" title="7.1.1 串行异步通信字符格式"></a>7.1.1 串行异步通信字符格式</h4><img src = "./11.png">

<ul>
<li><p>起始位(Start Bit): 采取逻辑 0 电平</p>
</li>
<li><p>数据位(Data Bit): 一般是8位</p>
</li>
<li><p>校验位(Parity Bit): 可有可无，一般是奇偶校验位</p>
</li>
<li><p>停止位(Stop Bit): 字符最后必须有停止位，采取逻辑1电平</p>
</li>
</ul>
<p>通信传输速率要相同，如9600bps表示一秒传输9600位</p>
<h4 id="7-1-2-串行异步通信接口"><a href="#7-1-2-串行异步通信接口" class="headerlink" title="7.1.2 串行异步通信接口"></a>7.1.2 串行异步通信接口</h4><h5 id="1-RS-232标准的引脚定义"><a href="#1-RS-232标准的引脚定义" class="headerlink" title="1. RS-232标准的引脚定义"></a>1. RS-232标准的引脚定义</h5><ul>
<li>TxD(Transmitted Data,发送数据)</li>
<li>RxD(Received Data, 接收数据)</li>
<li>RTS(Request To Send，请求发送)</li>
<li>CTS(Clear To Send，清除发送)</li>
<li>DTR(Data Terminal Ready，数据终端准备好)</li>
<li>DSR(Data Set Ready，数据装置准备好)</li>
<li>GND(Ground，信号地)</li>
<li>CD(Carrier Detected，载波检测)</li>
<li>RI(RIng Indicator，振铃指示)</li>
</ul>
<h5 id="2-RS-232接口的连接"><a href="#2-RS-232接口的连接" class="headerlink" title="2. RS-232接口的连接"></a>2. RS-232接口的连接</h5><p>三线相连</p>
<img src = "./12.png">

<h3 id="7-2-通用同步-x2F-异步接收-x2F-发送器"><a href="#7-2-通用同步-x2F-异步接收-x2F-发送器" class="headerlink" title="7.2 通用同步&#x2F;异步接收&#x2F;发送器"></a>7.2 通用同步&#x2F;异步接收&#x2F;发送器</h3><p>通用同步&#x2F;异步接收&#x2F;发送器（USART）和通用异步接收&#x2F;发送器(UART)</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式复习</tag>
      </tags>
  </entry>
  <entry>
    <title>text1</title>
    <url>/2023/06/13/text1/</url>
    <content><![CDATA[<h2 id="111"><a href="#111" class="headerlink" title="111"></a>111</h2><ol start="5">
<li>. 低字节位数据存放在内存低地址处，高字节位数据存放在内存高地址处，这就是小端字节序。</li>
<li>202.96.128.128</li>
<li>D 节省</li>
<li>银行</li>
<li>对<br>10 无缓冲是同步的<br>11。 132<br>12 func f(a,b int) (value int, error)</li>
</ol>
<p>13 int 和体系架构</p>
<p>14 其他三个</p>
<p>15 主键是唯一、不为空</p>
<p>16 direct </p>
<p>17 直接插入</p>
<p>18 堆</p>
<p>19 在100000</p>
<p>20 不选进程是动态的过程</p>
<p>21 不选 HTTP返回码 302</p>
<p>22 选 协程和线程都可以 以及 通过 channel</p>
<p>23 不选接口赋值</p>
<p>24 不选 数据库索引的存在</p>
<p>25 不选 POST比get安全 </p>
<p>26 不选域名解析</p>
<p>27 只选快速 12</p>
<p>28</p>
]]></content>
  </entry>
  <entry>
    <title>Golang学习_基础语法</title>
    <url>/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h1><p>Go语言（Google开源、编译型语言、21世纪的C语言）</p>
<p>Go 语言的特点(简单易学习、开发效率高、执行性能好)</p>
<span id="more"></span>
<h2 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h2><h2 id="Go-语言代码结构"><a href="#Go-语言代码结构" class="headerlink" title="Go 语言代码结构"></a>Go 语言代码结构</h2><p>下面这个是一个简单的 Go 语言的代码结构</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码中，非注释的第一行，一定要是包的声明，声明我们写的Go文件到底属于哪一个包，每一个Go程序都应该包含一个 main 包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// “import”是导入的意思，这一行就是告诉 Go 编译器，我写的代码需要 fmt 这个包。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// “func”关键字，定义函数。&quot;main&quot;函数是程序开始执行的函数，每一个可执行程序都会有一个 &quot;main&quot;函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这一行表示访问 &quot;fmt&quot; 包中的 &quot;Println&quot; 函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello,world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意: GO语言的花括号，不能单独放在一行，必须跟在函数或者其他语句的结尾；Go 语言一行代码就代表一个语句，不需要加分号；带有逻辑的一些语句，必须放在函数内部</strong></p>
<h2 id="变量以及常量"><a href="#变量以及常量" class="headerlink" title="变量以及常量"></a>变量以及常量</h2><h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等。Go 语言中标识符只能由字母数字和下划线组成。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>Go 语言中有25个关键字:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="keyword">default</span> <span class="function"><span class="keyword">func</span></span> </span><br><span class="line"><span class="keyword">interface</span> <span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">defer</span> </span><br><span class="line"><span class="keyword">go</span> <span class="keyword">map</span> <span class="keyword">struct</span> <span class="keyword">chan</span> <span class="keyword">else</span> <span class="keyword">goto</span> <span class="keyword">package</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">const</span> <span class="keyword">fallthrough</span> <span class="keyword">if</span> <span class="keyword">range</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span> <span class="keyword">for</span> <span class="keyword">import</span> <span class="keyword">return</span> <span class="keyword">var</span></span><br></pre></td></tr></table></figure>

<p>Go语言中还有37个保留字:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Types:  <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">        <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">        <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">        <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Functions: <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span> <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span> <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>变量(Variable) 的功能是存储数据。常见变量的数据类型有：整形、浮点型、布尔型等。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明，并且Go语言的变量声明后必须使用。</p>
<p>Go 语言中的变量声明格式为：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>Go 语言中还支持批量声明，因为每次声明一个变量就需要写一个 <code>var</code> 关键字会比较繁琐。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">string</span></span><br><span class="line">    b <span class="type">int</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">    d <span class="type">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。</p>
<p>Go 语言变量初始化的标准格式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 类型 = 表达式</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;小张&quot;</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者一次初始化多个变量</span></span><br><span class="line"><span class="keyword">var</span> name, age = <span class="string">&quot;小张&quot;</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小张&quot;</span> <span class="comment">//name 为 string</span></span><br></pre></td></tr></table></figure>

<p>在函数内部，可以使用更加简略的 <code>:=</code> 方式声明并且初始化变量</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    fmt.Println(m,n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用多重赋值时，如果想要忽略某个值，可以使用 匿名变量(annoymous variable)。匿名变量用一个<code>下划线_</code>表示</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;qqq&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, _ := foo()</span><br><span class="line">    _, y := foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;x=&quot;</span>, x) <span class="comment">// x= 10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;y=&quot;</span>, y) <span class="comment">// y= qqq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<ul>
<li><p>注意事项：</p>
<ol>
<li><p>函数外的每个语句都必须以关键字开始 (var, const, func 等)</p>
</li>
<li><p>:&#x3D; 不能使用在函数外</p>
</li>
<li><p>_多用于占位，表示忽略值</p>
</li>
</ol>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>相对于变量，常量是恒定不变的量，多用于定义程序运行期间不会改变的那些值。常量在定义的时候必须赋值</p>
<p>常量的声明:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure>

<p>多个常量可以一起声明:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415926</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>const 同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2  <span class="comment">// n2 = 100</span></span><br><span class="line">    n3  <span class="comment">// n3 = 100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>iota</code> 是 go 语言的常量计数器，只能在常量的表达式中使用</p>
<p><code>iota</code> 在 const 关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code> 计数一次</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    n2 <span class="comment">//1</span></span><br><span class="line">    n3 <span class="comment">//2 </span></span><br><span class="line">    n4 <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>Go 语言中有丰富的数据类型，除了基础的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道(channel)等。</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>按长度分为: int8，int16，int32，int64对应的无符号整型：uint8，uint16，uint32，uint64</p>
<p>uint8 就是 byte 型，int16对应C语言的short型，int64对应C语言中的long型。</p>
<p>特殊整型:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uint</td>
<td>32位操作系统上就是uint32，64位操作系统上就是uint64</td>
</tr>
<tr>
<td>int</td>
<td>32位操作系统上就是int32，64位操作系统上就是int64</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h4 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h4><p><code>v := 0b00101101</code>，代表二进制的 101101，相当于十进制的 45。<code>v := 0o377</code>，代表八进制的 377，相当于十进制的255。<code>v := 0x1p-2</code>，代表十六进制的 1除以2^2，也就是0.25。</p>
<p>而且还允许我们用 <code>_</code>来分隔数字，比如说 <code>v := 123_456</code>，表示 v 的值等于123456。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//十进制</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a) <span class="comment">//10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, a) <span class="comment">//1010 占位符%b表示二进制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//八进制 以0开头</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">077</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, b) <span class="comment">//77</span></span><br><span class="line">    <span class="comment">// 十六进制 以0x开头</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="type">int</span> = <span class="number">0xff</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, c) <span class="comment">//ff</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, c) <span class="comment">//FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go 语言支持两种浮点型数：<code>float32</code>和 <code>float64</code>。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%f\n&quot;</span>,math.Pi)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>,math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>complex64和complex128</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="type">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br></pre></td></tr></table></figure>
<p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Go 语言中以 <code>bool</code> 类型进行声明布尔型数据，布尔型数据只有 <code>true</code>和 <code>false</code> 两个值。</p>
<ul>
<li><p>注意事项：</p>
<ol>
<li><p>布尔类型变量的默认值为false。</p>
</li>
<li><p>Go语言中不允许将整型强制转换为布尔型。</p>
</li>
<li><p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
</li>
</ol>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go 语言中的字符串的内部实现使用 <code>UTF-8</code>编码。字符串的值为双引号中的内容。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;你好&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><table>
<thead>
<tr>
<th>转义符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\r</td>
<td>回车符(返回行首)</td>
</tr>
<tr>
<td>\n</td>
<td>换行符(直接跳到下一行的同列位置)</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>Go语言中要定义一个多行字符串时，就必须使用 <code>反引号</code>字符:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串中的常用操作"><a href="#字符串中的常用操作" class="headerlink" title="字符串中的常用操作"></a>字符串中的常用操作</h4><table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>len(str)</td>
<td>求长度</td>
</tr>
<tr>
<td>+或fmt.Sprintf</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>strings.Split</td>
<td>分割</td>
</tr>
<tr>
<td>strings.contains</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>strings.HasPrefix，strings.HasSuffix</td>
<td>前缀&#x2F;后缀判断</td>
</tr>
<tr>
<td>strings.Index()，strings.LastIndex()</td>
<td>子串出现的位置</td>
</tr>
<tr>
<td>strings.Jon(a[]string,sep string)</td>
<td>join操作</td>
</tr>
</tbody></table>
<h3 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h3><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。字符用单引号（‘’）包裹起来，如</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;中&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>GO 语言的字符有两种类型：</p>
<ol>
<li><p>uint8类型，或者叫做byte型，代表一个ASCII码值</p>
</li>
<li><p>rune类型，代表一个UTF-8字符。</p>
</li>
</ol>
</li>
</ul>
<h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>要修改字符串，需要先将其转成<code>[]rune</code>或<code>[]byte</code>，完成后在转换为 <code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line">    <span class="comment">// 强制类型转换</span></span><br><span class="line">    byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">    byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">    s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line">    runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">    runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go 语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure>
<p>其中T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>相加</td>
</tr>
<tr>
<td>-</td>
<td>相减</td>
</tr>
<tr>
<td>*</td>
<td>相乘</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>相除</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
</tr>
</tbody></table>
<p><strong>注意：++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符</strong></p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查两个值是否相等，如果相等返回 true否则返回false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查两个值是否不相等，如果不相等返回true否则返回false</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左边值是否大于右边值，如果是返回true，否则返回false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>检查左边值是否大于等于右边值，如果是返回true，否则返回false</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左边值是否小于右边值，如果是返回true，否则返回false</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>检查左边值是否小于等于右边值，如果是返回true，否则返回false</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑 AND 运算符。如果两边的操作都是True，则为True，否则为False</td>
</tr>
<tr>
<td>||</td>
<td>逻辑OR运算符。如果两边的操作有一个是True，则为True，否则为False</td>
</tr>
<tr>
<td>！</td>
<td>逻辑NOT运算符。如果条件为True，则为False，否则为True。</td>
</tr>
</tbody></table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>参与运算的两数各对应的二进位相与(两位均为1才为1)</td>
</tr>
<tr>
<td>|</td>
<td>参与运算的两数各对应的二进位相或(两位有一个为1就为1)</td>
</tr>
<tr>
<td>^</td>
<td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1（两位不一样则为1）</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移n位就是乘以2的n次方(“a&lt;&lt;b”就是把a的各二进位全部左移b位，高位丢弃，低位补零)</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移n位就是除以2的n次方(“a&gt;&gt;b”是把a的各二进位全部右移b位。)</td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>相加后再赋值</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>相减后再赋值</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>相乘后再赋值</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>相除后再赋值</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求余后再赋值</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移后赋值</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移后赋值</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与后赋值</td>
</tr>
<tr>
<td>|&#x3D;</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或后赋值</td>
</tr>
</tbody></table>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Go语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<h3 id="if-else-分支"><a href="#if-else-分支" class="headerlink" title="if-else 分支"></a>if-else 分支</h3><h4 id="if条件判断基本条件"><a href="#if条件判断基本条件" class="headerlink" title="if条件判断基本条件"></a>if条件判断基本条件</h4><p>Go 语言中 <code>if</code> 条件判断的格式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。</p>
<p>Go 语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。</p>
<h4 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h4><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for（循环结构）"><a href="#for（循环结构）" class="headerlink" title="for（循环结构）"></a>for（循环结构）</h3><p>for 循环的基本格式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for 循环的初始语句可以省略，但是初始语句后的分号必须要写。</span></span><br><span class="line"><span class="keyword">for</span> forDemo2() &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for 循环的初始语句和结束语句都可以省略</span></span><br><span class="line"><span class="keyword">for</span> forDemo3() &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环可以通过 break、goto、return、panic 语句强制退出循环</p>
<h3 id="for-range（键值循环）"><a href="#for-range（键值循环）" class="headerlink" title="for range（键值循环）"></a>for range（键值循环）</h3><p>Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 </p>
<p>通过for range遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用switch语句可以方便地对大量的值进行条件判断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">3</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个分支还可以有多个值，多个值中间使用英文逗号隔开</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;11&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分支还可以使用表达式，这个时候swtich后面不需要跟判断变量</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">age := <span class="number">111</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> age &gt; <span class="number">70</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;享受人生&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;活着真好&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> s == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure>

<h3 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h3><p>goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> breaking</span><br><span class="line"></span><br><span class="line">breaking:</span><br><span class="line">    fmt.Println(<span class="string">&quot;退出&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="break（跳出循环）"><a href="#break（跳出循环）" class="headerlink" title="break（跳出循环）"></a>break（跳出循环）</h3><p>break语句可以结束for、switch和select的代码块。</p>
<p>break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。</p>
<h3 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h3><p>continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h3><p>数组是同一种数据类型元素的集合。</p>
<h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义:"></a>数组定义:</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure>
<p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。</p>
<p>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1。</p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> numArray [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numArray [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [...]<span class="type">int</span>&#123;下标:数值&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cityArray [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 使用 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(cityArray); i++ &#123;</span><br><span class="line">        fmt.Println(cityArray[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用for range</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">range</span> cityArray &#123;</span><br><span class="line">        fmt.Println(index,value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h4 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">        &#123;<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;北京&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;西安&quot;</span>,<span class="string">&quot;成都&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v1 <span class="keyword">range</span> a &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v2 <span class="keyword">range</span> v1 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;%s\t&quot;</span>,v2)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意： 多维数组只有第一层可以使用…来让编译器推导数组长度。例如：</strong></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">    &#123;<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;北京&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;西安&quot;</span>,<span class="string">&quot;成都&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h3><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<ul>
<li>注意:<ol>
<li>数组支持 “&#x3D;&#x3D;“、”!&#x3D;” 操作符，因为内存总是被初始化过的。</li>
<li>[n]<em>T表示指针数组，</em>[n]T表示数组指针 。</li>
</ol>
</li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p>声明切片类型的基本语法如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 []切片中的元素类型</span><br></pre></td></tr></table></figure>

<h4 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h4><p>使用 <code>len()</code> 函数求长度，使用内置的 <code>cap()</code> 函数求切片的容量。</p>
<h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式中的 <code>low</code> 和 <code>high</code> 表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1&lt;&#x3D;索引值&lt;4的元素组成切片s，得到的 <code>切片长度=high-low</code> ，容量等于得到的切片的底层数组的容量。</p>
<p>为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:</p>
<h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">a[low: high: max]</span><br></pre></td></tr></table></figure>
<p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>
<h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    T: 切片的元素类型</span></span><br><span class="line"><span class="comment">    size: 切片中元素的数量</span></span><br><span class="line"><span class="comment">    cap: 切片的容量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h4><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<h4 id="判断切片是否为空值"><a href="#判断切片是否为空值" class="headerlink" title="判断切片是否为空值"></a>判断切片是否为空值</h4><p>使用 len(s) &#x3D;&#x3D; 0判断，不使用 s &#x3D;&#x3D; nil来判断。</p>
<h3 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h3><p>切片之间是不能比较的，我们不能使用&#x3D;&#x3D;操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 </p>
<h3 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h3><p>了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    s2 := s1</span><br><span class="line">    s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h3><p>切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Println(i,s[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Println(index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h3><p>Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1 2 3 4]</span></span><br><span class="line">    s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">    s = <span class="built_in">append</span>(s, s2...) <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<h3 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h3><p>切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。</p>
<h3 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h3><p>Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T)</span><br><span class="line"></span><br><span class="line"><span class="comment">// srcSlice：数据来源切片</span></span><br><span class="line"><span class="comment">// destSlice：目标切片</span></span><br></pre></td></tr></table></figure>

<h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>&#125;</span><br><span class="line">    <span class="comment">// 删除索引为2的元素</span></span><br><span class="line">    a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要从切片a中删除索引为 index 的元素，操作方法是 a &#x3D; append(a[:index]<br>, [index+1:]…)</p>
]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>近代史</title>
    <url>/2023/06/15/%E8%BF%91%E4%BB%A3%E5%8F%B2/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
