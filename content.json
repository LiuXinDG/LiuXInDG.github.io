{"meta":{"title":"琉心的博客","subtitle":"学以致用，方能翱翔","description":"学海无涯，回头是岸","author":"琉心","url":"https://LiuXinDG.gitbub.io","root":"/"},"pages":[{"title":"关于","date":"2023-06-14T08:40:19.000Z","updated":"2023-06-14T08:49:18.970Z","comments":true,"path":"about/index.html","permalink":"https://liuxindg.gitbub.io/about/index.html","excerpt":"","text":"本科在读，计算机科学与技术专业，热爱思考，接收新知，吾日三省吾身。 写博客的目的: 一、总结学习的内容，强迫自己以更加系统和严谨的态度梳理知识体系； 二、记录学习过程中遇到的问题，以及解决问题的经验 联系方式 邮箱：&#x41;&#x31;&#53;&#x35;&#x39;&#x35;&#x34;&#x30;&#57;&#49;&#x37;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109; Github: https://github.com/LiuXinDG"},{"title":"标签","date":"2023-06-14T08:17:09.000Z","updated":"2023-06-14T08:49:09.051Z","comments":true,"path":"tags/index.html","permalink":"https://liuxindg.gitbub.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-06-14T08:15:44.000Z","updated":"2023-06-14T08:48:57.477Z","comments":true,"path":"categories/index.html","permalink":"https://liuxindg.gitbub.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang学习_包","slug":"Golang学习-包","date":"2023-06-15T05:07:20.000Z","updated":"2023-06-15T05:10:18.414Z","comments":true,"path":"2023/06/15/Golang学习-包/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%8C%85/","excerpt":"Go语言基础之包一、包与依赖管理1.1 包(package)1）包介绍Go语言中支持模块化的开发理念，在Go语言中 包 package来支持代码模块化和代码复用。Go语言为我们提供了很多内置包，如fmt、os、io等。","text":"Go语言基础之包一、包与依赖管理1.1 包(package)1）包介绍Go语言中支持模块化的开发理念，在Go语言中 包 package来支持代码模块化和代码复用。Go语言为我们提供了很多内置包，如fmt、os、io等。 2）定义包我们可以根据自己的需要创建定义包。一个包可以简单理解成一个存放.go文件的文件夹。该文件夹下的所有文件都需要在非注释的第一行进行声明，声明该文件所属的包 1package packagename package: 声明包的关键字 pakagename: 包名，可以不与文件夹的名称一致，不能包含-符号，最好与其实现的功能相互对应 一个文件夹下面直接包含的文件只能归属一个包，同一个包的文件不能在多个文件夹下。 3）标识符可见性在同一个包内部声明的标识符都位于同一个命名空间下，在不同的包内部声明的标识符就属于不同的命名空间。想要在包的外部使用包内部的标识符就需要添加包名前缀，例如fmt.Println(&quot;Hello world!&quot;)，就是指调用fmt包中的Println函数。 Go语言中通过标识符的首字母大&#x2F;小写来控制标识符的对外可见(public)&#x2F;不可见(private)的。在一个包内部只有首字母大写的标识符才是对外可见的。 1234567891011121314151617181920212223242526272829package demoimport &quot;fmt&quot;// num定义一个全局整型变量// 首字母小写，对外不可见var num = 100// Mode 定义一个常量// 首字母大写，对外可见const Mode = 1// person定义一个代表人的结构体// 首字母小写，对外不可见type person struct &#123; name string Age int&#125;// Add 返回两个整数和的函数// 首字母大写，对外可见func Add(x, y int) int &#123; return x + y&#125;// sayHi 打招呼的函数// 首字母小写，对外不可见func sayHi() &#123; var myName = &quot;七米&quot; fmt.Println(myName)&#125; 结构体中可导出字段的字段名称必须首字母大写 1234type Student struct &#123; Name string //可在包外访问 class string //仅在包内访问&#125; 4）包的引入要在当前包中使用另外一个包的内容就需要使用import关键字引入这个包，并且import语句通常放在文件的开头，package声明语句的下方。完整的引入声明语句格式如下: 1import importname &quot;path/to/package&quot; importname: 引入的包名，通常都省略。默认值为引入包的包名。 path&#x2F;to&#x2F;package: 引入包的路径名称，必须使用双引号包裹起来。 Go语言中禁止循环导入包 一个Go源码文件可以同时引入多个包 123import &quot;fmt&quot;import &quot;net/http&quot;import &quot;os&quot; 当然也可以采用批量引入的方式 12345import ( &quot;fmt&quot; &quot;net/http&quot; &quot;os&quot;) 当引入的多个包中存在相同的包名或者想自行为某个引入的包设置一个新包名时，都需要通过importname指定一个在当前文件中使用的新包名。例如，在引入fmt包时为其指定一个新包名f。 1import f &quot;fmt&quot; 如果引入一个包的时候为其设置了一个特殊_作为包名，那么这个包的引入方式就称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的init函数将被执行并且仅执行一遍。 1import _ &quot;github.com/go-sql-driver/mysql&quot; 5）init初始化函数在每一个Go源文件中，都可以定义任意个如下格式的特殊函数: 123func init() &#123; // ...&#125; 这种特殊的函数不接收任何参数也没有任何返回值，我们也不能在代码中主动调用它。当程序启动的时候，init函数会按照它们声明的顺序自动执行。 一个包的初始化过程是按照代码中引入的顺序来进行的，所有在该包中声明的init函数都将被串行调用并且仅调用执行一次。每一个包初始化的时候都是先执行依赖的包中声明的init函数再执行当前包中声明的init函数。 1.2 go module1）go module介绍go module相关指令 命令 介绍 go mod init 初始化项目依赖，生成go.mod文件 go mod download 根据go.mod文件下载依赖 go mod tidy 对比项目文件中引入的依赖与go.mod进行对比 go mod graph 输出依赖关系图 go mod edit 编辑go.mod文件 go mod vendor 将项目的所有依赖导出至vendor目录 go mod verify 检验一个依赖包是否被篡改过 go mod why 解释为什么需要这个依赖 GOPROXY这个环境变量主要是用于设置Go模块代理(Go module proxy)，其作用是用于使Go在后续拉取模块版本时能够脱离传统的VCS方式，直接通过镜像站点来快速拉取。 设置GOPROXY的命令如下： 1go env -v GOPROXY=https://goproxy.cn,dirct GOPRIVATE设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。 1go env -w GOPRIVATE=&quot;git.mycompany.com&quot; 这样在拉取以git.mycompany.com为路径前缀的依赖包时就能正常拉取了。 此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 GONOPROXY&#x3D;none，允许通内部代理拉取私有仓库的包。 2）使用go module引入包初始化项目：我们在本地新建一个名为 holiday 项目，按如下方式创建一个名为 holiday 的文件夹并切换到该目录下; 12$ mkdir holiday$ cd holiday 接下来初始化项目 12go mod init holidaygo: creating new go.mod: module holiday 该命令会自动在项目目录下创建一个 go.mod 文件，其内容如下: 123module holidaygo 1.16 module holiday: 定义当前项目的导入路径 go 1.16: 标识当前项目使用的Go版本 下载依赖包的两种方法一: 在项目目录下执行 go get 命令手动下载依赖的包，默认下载最新的发布版本。 12go get -u github.com/q1mi/hellogo get: added github.com/q1mi/hello v0.1.1 也可以指定想要下载指定的版本号。 123go get -u github.com/q1mi/hello@v0.1.0go: downloading github.com/q1mi/hello v0.1.0go get: downgraded github.com/q1mi/hello v0.1.1 =&gt; v0.1.0 如果想指定下载某个 commit 对应的代码，可以直接指定commit hash，一般写出前7位即可。 123go get github.com/q1mi/hello@2ccfaddgo: downloading github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3go get: added github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3 二: 直接编辑go.mod文件 12345module holidaygo 1.16require github.com/q1mi/hello latest 表示当前项目需要使用 github.com/q1mi/hello 库的最新版本，然后在项目目录下执行 go mod download 下载依赖包 可以在 go.mod 文件中指定需要的版本进行下载，只用指定commit hash的前7位就好了。 1require github.com/q1mi/hello 2ccfadda Go语言支持在一个项目（project）下定义多个包（package）。 例如，我们在holiday项目内部创建一个新的package-summer，此时新的项目目录结构如下: 123456holidy├── go.mod├── go.sum├── main.go└── summer └── summer.go 其中 holiday/summer/summer.go 文件内容如下: 12345678package summerimport &quot;fmt&quot;//Diving潜水func Diving() &#123; fmt.Println(&quot;夏天去诗巴丹潜水...&quot;)&#125; 当我们需要调用的时候 1234567891011package mainimport ( &quot;fmt&quot; &quot;holiday/summer&quot;)func main() &#123; summer.Diving()&#125; 我们可以在holidy&#x2F;go.mod文件中正常引入liwenzhou.com&#x2F;overtime包，然后像下面的示例那样使用replace语句将这个依赖替换为使用相对路径表示的本地包。 12345678module holidaygo 1.16require github.com/q1mi/hello v0.1.1replace liwenzhou.com/overtime =&gt; ../overtime go.mod文件 go.mod文件中记录了当前项目中所有依赖包的相关信息，声明依赖的格式如下: 1require module/path v1.2.3 其中: require: 声明依赖的关键字 module&#x2F;path: 依赖包的引入路径 v1.2.3: 依赖包的版本号。支持以下几种格式: latest: 最新版本 v1.0.0: 详细版本号 commit hash: 指定某次commit hash go.sum文件 go.sum这个文件中详细记录了当前项目中引入的依赖包的信息及其hash 值。文件内容通常是以类似下面的格式出现。 1&lt;module&gt;&lt;version&gt;/go.mod &lt;hash&gt; 或者 12&lt;module&gt; &lt;version&gt; &lt;hash&gt;&lt;module&gt; &lt;version&gt;/go.mod &lt;hash&gt; 依赖保存位置 Go module 会把下载到本地的依赖包会以类似下面的形式保存在 $GOPATH/pkg/mod 目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。 12345678mod├── cache├── cloud.google.com├── github.com └──q1mi ├── hello@v0.0.0-20210218074646-139b0bcd549d ├── hello@v0.1.1 └── hello@v0.1.0 如果想清除所有本地已缓存的依赖包数据，可以执行go clean -modcache命令。 3）使用go module发布包我们首先在自己的 github 账号下新建一个项目，并把它下载到本地。我这里就以创建和发布一个名为hello的项目为例进行演示。这个hello包将对外提供一个名为SayHi的函数，它的作用非常简单就是向调用者发去问候。 12$ git clone https://github.com/q1mi/hello$ cd hello 我们当前位于hello项目目录下，执行下面的命令初始化项目，创建go.mod文件。 12$ go mod init github.com/q1mi/hellogo: creating new go.mod: module github.com/q1mi/hello 接下来在该项目根目录下创建hello.go文件，添加下面的内容: 1234567package helloimport &quot;fmt&quot;func SayHi() &#123; fmt.Println(&quot;你好，我是七米。很高兴认识你。&quot;)&#125; 然后将该项目的代码push到仓库的远端分支，这样就对外发布了一个Go包。 一个设计完善的包应该包含开源许可证及文档等内容，并且我们还应该尽心维护并适时发布适当的版本。github 上发布版本号使用git tag为代码包打上标签即可。 12$ git tag -a v0.1.0 -m &quot;release version v0.1.0&quot;$ git push origin v0.1.0 1v1.2.3 主版本号：发布了不兼容的版本迭代时递增(brakinng changes)。 次版本号：发布了功能性更新时递增。 修订号: 发布了bug修复类更新时递增。 发布新的主版本 现在我们的hello项目要进行与之前版本不兼容的更新，我们计划让SayHi函数支持向指定人发出问候。更新后的SayHi函数内容以下: 12345678package helloimport &quot;fmt&quot;// SayHi 向指定人打招呼的函数func SayHi(name string) &#123; fmt.Println(&quot;你好%s，我是七米。我很高兴认识你。\\n&quot;,name)&#125; 由于这次改动巨大（修改了函数之前的调用规则），对之前使用该包作为依赖的用户影响巨大。因此我们需要发布一个主版本号递增的v2版本。在这种情况下，我们通常会修改当前包的引入路径，像下面的示例一样为引入路径添加版本后缀。 123module github.com/q1mi/hello/v2go 1.16 把修改后的代码提交: 123$ git add .$ git commit -m &quot;feat: sayHi现在支持给指定人打招呼&quot;$ git push 打好tag推送到远程仓库。 12$ git tag -a v2.0.0 -m &quot;release version v2.0.0&quot;$ git push origin v2.0.0 这样在不影响使用旧版本的用户的前提下，我们新的版本也发布出去了。想要使用v2版本的代码包的用户只需按修改后的引入路径下载即可。 1go get github.com/q1mi/hello/v2@2.0.0 在代码中使用的过程与之前类似，只是需要注意引入路径要添加 v2 版本后缀。 12345678910111213package mainimport ( &quot;fmt&quot; &quot;github.com/q1mi/hello/v2&quot; // 引入v2版本)func main() &#123; fmt.Println(&quot;现在是假期时间...&quot;) hello.SayHi(&quot;张三&quot;) // v2版本的SayHi函数需要传入字符串参数&#125; 废弃已发布的版本 如果某个发布的版本存在致命缺陷不再想让用户使用时，我们可以使用retract声明废弃的版本。例如我们在hello&#x2F;go.mod文件中按如下方式声明即可对外废弃v0.1.2版本。 12345module github.com/q1mi/hellogo 1.16retract v0.1.2 用户使用go get下载 v0.1.2 版本时就会收到提示，催促其升级到其他版本。","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"包","slug":"包","permalink":"https://liuxindg.gitbub.io/tags/%E5%8C%85/"},{"name":"package","slug":"package","permalink":"https://liuxindg.gitbub.io/tags/package/"}],"author":"琉心"},{"title":"Golang学习_结构体","slug":"Golang学习-结构体","date":"2023-06-15T05:07:10.000Z","updated":"2023-06-15T05:08:31.578Z","comments":true,"path":"2023/06/15/Golang学习-结构体/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"Go语言基础之结构体一、类型别名和自定义类型1.1 自定义类型在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型。","text":"Go语言基础之结构体一、类型别名和自定义类型1.1 自定义类型在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型。 12// 将MyInt定义为int类型type MyInt int 通过type关键字，MyInt就是一种新的类型，它具有 int 的特性。 1.2 类型别名类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。 1type TypeAlias = Type 1.3 类型定义和类型别名的区别12345678910111213// 类型定义type NewInt int// 类型别名type MyInt = intfunc main() &#123; var a NewInt var b MyInt fmt.Printf(&quot;type of a:%T\\n&quot;, a) //type of a: main.NewInt fmt.Printf(&quot;type of b:%T\\n&quot;, b) //type of b: int&#125; 二、结构体Go语言中通过struct来实现面向对象。 2.1 结构体的定义使用type和struct关键字来定义结构体 12345type 类型名 struct &#123; 字段名 字段类型 字段名 字段类型 ...&#125; 类型名：标识自定义结构体的名称，在同一个包内不能重复。 字段名：表示结构体字段名。结构体中的字段名必须唯一。 字段类型：表示结构体字段的具体类型。 2.2 结构体实例化结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。 1var 结构体实例 结构体类型 1) 基本实例化123456789101112type person struct &#123; name string city string age int8&#125;func main() &#123; var p1 person p1.name = &quot;结构体&quot; p1.age = 23 p1.city = &quot;网络&quot;&#125; 我们可以通过.来访问结构体的字段（成员变量），例如 p1.name和p1.age等。 2) 匿名结构体在定义一些临时数据结构等场景下还可以使用匿名结构体。 123456789101112package mainimport ( &quot;fmt&quot;)func main() &#123; var usr struct&#123;Name string; Age int&#125; usr.Name = &quot;小王子&quot; usr.Age = 18 fmt.Printf(&quot;%#v\\n&quot;, usr)&#125; 3) 创建指针类型结构体12345var p2 = new(person)p2.name = &quot;小王子&quot;p2.age = 18p2.city = &quot;上海&quot;fmt.Printf(&quot;%#v\\n&quot;, p2) 4) 取结构体的地址实例化使用 &amp; 对结构体进行取地址操作相当于对该结构体类型进行了一次 new 实例化操作。 1234567p3 := &amp;person&#123;&#125;fmt.Printf(&quot;%T\\n&quot;, p3) // *main.personfmt.Printf(&quot;p3=%#v\\n&quot;, p3) // p3=&amp;main.person&#123;name:&quot;&quot;,city:&quot;&quot;,age:0&#125;p3.name = &quot;demo&quot;p3.city = &quot;awa&quot;p3.age = 10fmt.Printf(&quot;p3=%#v\\n&quot;, p3) // p3=&amp;main.person&#123;name:&quot;demo&quot;,city:&quot;awa&quot;,age:10&#125; 2.3 结构体初始化1) 使用键值对初始化12345p3 := person&#123; name: &quot;小王子&quot;, city: &quot;北京&quot;, age: 18&#125; 也可以对结构体指针进行键值对初始化 12345p6 := &amp;person&#123; name: &quot;小王子&quot;, city: &quot;北京&quot;, age: 18&#125; 当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。 123p7 := &amp;person&#123; city: &quot;北京&quot;&#125; 2) 使用值的列表初始化初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值： 12345678910p8 := &amp;person&#123; &quot;沙河娜扎&quot;, &quot;北京&quot;, 28&#125;使用这种格式初始化时，需要注意：1. 必须初始化结构体的所有字段。2. 初始值的填充顺序必须与字段在结构体中的声明顺序一致。3. 该方式不能和键值初始化方式混用。 2.4 结构体内存布局结构体占用一块连续的内存 12345678910111213141516type test struct &#123; a int8 b int8 c int8 d int8&#125;n := test&#123; 1, 2, 3, 4&#125;fmt.Printf(&quot;n.a %p\\n&quot;, &amp;n.a)fmt.Printf(&quot;n.b %p\\n&quot;, &amp;n.b)fmt.Printf(&quot;n.c %p\\n&quot;, &amp;n.c)fmt.Printf(&quot;n.d %p\\n&quot;, &amp;n.d) 输出结果如下 1234n.a 0x0000a0060n.b 0x0000a0061n.c 0x0000a0062n.d 0x0000a0063 1) 空结构体空结构体不占用空间。 12var v struct&#123;&#125;fmt.Println(unsafe.Sizeof(v)) //0 2.5 构造函数Go语言的结构体没有构造函数，我们可以自己实现。 12345678910func newPerson(name, city string, age int8) *person &#123; return &amp;person&#123; name: name, city: city, age: age &#125;&#125;//调用构造函数p9 := newPerson(&quot;张三&quot;, &quot;沙河&quot;, 20) 2.6 方法和接收者Go语言中的方法(Method)是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者(Receiver)。 123func(接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123; 函数体&#125; 接收者变量：接收者中的参数变量在命名时，官方建议使用接收者类型名称首字母小写，而不是self、this之类的命名。 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：具体格式与函数定义相同。 1234567891011121314151617181920//结构体type Person struct&#123; name string age int&#125;// NewPerson 构造函数func NewPerson(name stirng, age int8) *Person &#123; return &amp;Person&#123; name: name, age: age &#125;&#125;// Dream Person 做梦的方法func(p Person) Dream() &#123; fmt.Printf(&quot;%s的梦想是学好Go语言\\n&quot;,&amp;p.name)&#125;func main() &#123; p1 := NewPerson(&quot;小王子&quot;, 20) p1.Dream()&#125; 方法与函数不同的是，函数不属于任何类型，方法属于特定的类型。 1）指针类型的接收者指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。 12345//SetAge 设置p的年龄// 使用指针接收者func (p *Person) SetAge(newAge int8) &#123; p.age = newAge&#125; 调用该方法 123456func main() &#123; p1 := NewPerson(&quot;小王子&quot;, 25) fmt.Println(p1.age) // 25 p1.SetAge(20) fmt.Pritnln(p1.age) // 20&#125; 2）值类型的接收者当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。 123456789101112// SetAge2 设置p的年龄// 使用值接收者func (p Person) SetAge2(newAge int8) &#123; p.age = newAge&#125;func main() &#123; p1 := NewPerson(&quot;小王子&quot;, 25) p1.Dream() fmt.Println(p1.age) // 25 p1.SetAge2(20) // (*p1).SetAge2(20) fmt.Println(p1.age) // 25&#125; 3）什么时候需要使用指针类型接收者 需要修改接收者中的值 接收者是拷贝代价较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他方法夜应该使用指针接收者。 2.7 任意类型添加方法在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 12345678910111213//MyInt 将int定义为自定义MyInt类型type MyInt int//SayHello 为MyInt添加一个SayHello的方法func (m MyInt) SayHello() &#123; fmt.Println(&quot;Hello, 我是一个int&quot;)&#125;func main() &#123; var m1 MyInt m1.SayHello() m1 = 100 fmt.Printf(&quot;%v %T\\n&quot;, m1, m1)&#125; 2.8 结构体的匿名字段结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段被称为匿名字段。 123456789101112//Person 结构体Person类型type Person struct &#123; string int&#125;func main() &#123; p1 := Person&#123; &quot;小王&quot;, 20, &#125; fmt.Println(p1.string, p1.int)&#125; 由于结构体要求字段名称必须唯一，因此一个结构体中同类型的匿名字段只能有一个。 2.9 嵌套结构体一个结构体中可以嵌套包含另一个结构体或结构体指针 1234567891011121314151617181920212223// Address 地址结构体type Address struct &#123; Province string City string&#125;// User 用户结构体type User struct &#123; Name string Gender string Address Address&#125;func main() &#123; user1 := User&#123; Name: &quot;小王子&quot;, Gender: &quot;男&quot;, Address: Address&#123; Province: &quot;山东&quot;, City: &quot;威海&quot; &#125;, &#125; fmt.Printf(&quot;user1=%#v\\n&quot;, user1)//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;&#125; 1）嵌套匿名字段1234567891011121314151617181920//Address 地址结构体type Address struct &#123; Province string City string&#125;// User 用户结构体type User struct &#123; Name string Gender string Address //匿名字段&#125;func main() &#123; var user2 User user2.Name = &quot;张三&quot; user2.Gender = &quot;男&quot; user2.Address.Province = &quot;山东&quot; /// 匿名字段默认使用类型名作为字段名 user2.City = &quot;威海&quot; // 匿名字段可以省略 fmt.Println(&quot;user2=%v\\n&quot;, user2)&#125; 2） 嵌套结构体的字段名冲突嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。 12345678910111213141516171819202122232425// Address 地址结构体type Address struct &#123; Province string City string CreateTime string&#125;// Email 邮箱结构体type Email struct &#123; Account string CreateTime string&#125;// User 用户结构体type User struct &#123; Name string Gender string Address Email&#125;func main() &#123; var user3 User user3.Name = &quot;李四&quot; user3.Gender = &quot;男&quot; user3.Address.CreateTime = &quot;2000&quot; // 指定Address结构体中的CreateTIme user3.Email.CreateTime = &quot;2010&quot; // 指定Email结构体中的CreateTime&#125; 2.10 结构体的”继承”Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。 1234567891011121314151617181920212223242526//Animal 动物type Animal struct &#123; name string&#125;func (a *Animal) move() &#123; fmt.Printf(&quot;%s会动 \\n&quot;, a.name)&#125;//Dog 狗type Dog struct &#123; Feet int8 *Animal //通过嵌套匿名结构体实现继承&#125;func (d *Dog) wang() &#123; fmt.Printf(&quot;%s会汪汪汪~\\n&quot;, d.name)&#125;func main() &#123; d1 := &amp;Dog&#123; Feet: 4, Animal: &amp;Animal&#123; //注意嵌套的是结构体指针 name: &quot;乐乐&quot; &#125;, &#125; d1.wang() d1.move()&#125; 2.11 结构体字段的可见性结构体中字段大写开头表示可公开访问，小写表示私有(仅在定义当前结构体的包中可以访问) 2.12 结构体与JSON序列化JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键&#x2F;值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。 1234567891011121314151617181920212223242526272829303132333435363738394041//Student 学生type Student struct &#123; ID int Gender string Name string&#125;//Class 班级type Class struct &#123; Title string Students []*Student&#125;func main() &#123; c := &amp;Class&#123; Title: &quot;101&quot;, Students: make([]*Student, 0, 200), &#125; for i := 0; i &lt; 10; i++ &#123; stu := &amp;Student&#123; Name: fmt.Sprintf(&quot;stu%02d&quot;, i), Gender: &quot;男&quot;, ID: i, &#125; c.Students = append(c.Students, stu) &#125; // JSON序列化: 结构体--&gt;JSON格式的字符串 data, err := json.Marshal(c) if err != nil &#123; fmt.Println(&quot;json marshal failed&quot;) return &#125; fmt.Printf(&quot;json:%s\\n&quot;, data) // JSON反序列化: JSON格式的字符串 --&gt; 结构体 str := `&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;` c1 := &amp;Class&#123;&#125; err = json.Unmarshal([]byte(str), c1) if err != nil &#123; fmt.Println(&quot;json unmarshal failed!&quot;) return &#125; fmt.Printf(&quot;%#v\\n&quot;, c1)&#125; 2.13 结构体标签(Tag)Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下： 1`key1:&quot;value1&quot; key2:&quot;value2&quot;` 结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。 注意事项: 为结构体编写Tag时，必须严格遵循键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。 1234567891011121314151617181920//Student 学生type Student struct &#123; ID int `json:&quot;id&quot;` //通过指定tag实现json序列化该字段时的key Gender string //json序列化是默认使用字段名作为key name string //私有不能被json包访问&#125;func main() &#123; s1 := Student&#123; ID: 1, Gender: &quot;男&quot;, name: &quot;沙河娜扎&quot;, &#125; data, err := json.Marshal(s1) if err != nil &#123; fmt.Println(&quot;json marshal failed!&quot;) return &#125; fmt.Printf(&quot;json str:%s\\n&quot;, data) //json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;&#125; 结构体和方法补充知识点因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。 1234567891011121314151617type Person struct &#123; name string age int8 dreams []string&#125;func (p *Person) SetDreams(dreams []string) &#123; p.dreams = dreams&#125;func main()&#123; p1 := Person&#123;name: &quot;小王子&quot;, age: 18&#125; data := []string&#123;&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;&#125; p1.SetDreams(data) // 你真的想要修改 p1.dreams吗 data[1] = &quot;不睡觉&quot; fmt.Println(p1.dreams) // ?&#125; 正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。 1234func (p *Person) SetDreams(dreams []string) &#123; p.dreams = make([] string, len(dreams)) copy(p.dreams, dreams)&#125;","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"结构体","slug":"结构体","permalink":"https://liuxindg.gitbub.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"struct","slug":"struct","permalink":"https://liuxindg.gitbub.io/tags/struct/"}],"author":"琉心"},{"title":"Golang学习_指针","slug":"Golang学习-指针","date":"2023-06-15T05:07:04.000Z","updated":"2023-06-15T05:09:07.966Z","comments":true,"path":"2023/06/15/Golang学习-指针/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/","excerpt":"Go语言基础之指针一、Go语言中的指针任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。 Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：&amp;（取地址）和*（根据地址取值）。","text":"Go语言基础之指针一、Go语言中的指针任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。 Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：&amp;（取地址）和*（根据地址取值）。 1.1 指针地址和指针类型个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如:*int、*int64、*string等。 取变量指针的语法如下： 1ptr := &amp;v 其中: v: 代表被取地址的变量，类型为 T ptr: 用于接收地址的变量，ptr的类型为 *T，称作T的指针类型。*表示指针。 1.2 指针取值在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。 12345678func main() &#123; a := 10 b := &amp;a //取变量a的地址，将指针保存在b中 fmt.Printf(&quot;type of b:%T\\n&quot;, b) c := *b //指针取值 fmt.Printf(&quot;type of c:%T\\n&quot;, c) fmt.Printf(&quot;value of c:%v\\n&quot;,c)&#125; 总结： 取地址操作符&amp;和取值操作符是一对互补操作符，&amp;取出地址，根据地址取出地址指向的值。 变量、指针地址、指针变量、取地址、取值的相互关系和特性如下： 对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。 指针变量的值是指针地址。 对指针变量进行取值(*)操作，可以获得指针变量指向的原变量的值。 1.3 new和make1) newnew是一个内置的函数，它的函数签名如下: 1func new(Type) *Type Type表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针。 指针作为引用类型需要初始化后才会拥有内存空间，才可以给它复制。 123456func main() &#123; var a *int a = new(int) *a = 10 fmt.Println(*a)&#125; 2) makemake也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。 1func make(t Type,size ...IntegerType) Type make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。 3) new与make的区别1.二者都是用来做内存分配的。2.make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身;3.而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"指针","slug":"指针","permalink":"https://liuxindg.gitbub.io/tags/%E6%8C%87%E9%92%88/"},{"name":"point","slug":"point","permalink":"https://liuxindg.gitbub.io/tags/point/"}],"author":"琉心"},{"title":"Golang学习_函数","slug":"Golang学习-函数","date":"2023-06-15T05:06:58.000Z","updated":"2023-06-15T05:09:43.014Z","comments":true,"path":"2023/06/15/Golang学习-函数/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/","excerpt":"GO语言基础之函数一、 函数1.1 函数定义Go语言中定义函数使用 func 关键字。 1234567func 函数(参数)(返回值)&#123; 函数体&#125;// 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名称不能同名。// 参数：参数由参数变量和参数变量的类型组成，多个参数之间用，分隔。// 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用（）包裹，并用，分隔。// 函数体：实现指定功能的代码块。","text":"GO语言基础之函数一、 函数1.1 函数定义Go语言中定义函数使用 func 关键字。 1234567func 函数(参数)(返回值)&#123; 函数体&#125;// 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名称不能同名。// 参数：参数由参数变量和参数变量的类型组成，多个参数之间用，分隔。// 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用（）包裹，并用，分隔。// 函数体：实现指定功能的代码块。 求两个数之和的函数: 123func intSum(x int, y int) int &#123; return x + y&#125; 函数的参数和返回值都是可选的，所以我们可以实现一个不需要参数也没有返回值的函数： 123func sayHello() &#123; fmt.Println(&quot;Hello world&quot;)&#125; 1.2 函数的调用定义了函数之后，通过函数名()方法来进行调用函数。比如: 123func main() &#123; sayHello()&#125; 1.3 参数1) 类型简写函数的参数中如果相邻变量的类型相同，则可以省略类型: 123func intSum(x, y int) int &#123; return x + y&#125; 2) 可变参数可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加 ... 来标识。 12345678func intSum2(x ...int) int &#123; fmt.Println(x) //x是一个切片 sum := 0 for _, v := range x &#123; sum = sum + v &#125; return sum&#125; 固定参数搭配可变参数的时候，可变参数要放在固定参数的后面。 12345678func intSum3(x int, y ...int) int &#123; fmt.Println(x, y) sum := x for _, v := range y &#123; sum = sum + v &#125; return sum&#125; 1.3 返回值函数采取 return 关键字向外输出返回值。 1) 多返回值如果采取多个返回值的时候，必须使用 () 将返回值包裹起来。 12345func calc(x, y int) (int, int) &#123; sum := x + y sub := x - y return sum, sub&#125; 2) 返回值命名函数定义时可以给返回值命名，并在函数体中直接使用这些变量。最后通过 return 关键字返回。 12345func calc(x, y int) (sum, sub int)&#123; sum := x + y sub := x - y return&#125; 3) 返回值补充当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。 123456func someFunc(x string) []int &#123; if x == &quot;&quot; &#123; return nil // 没必要返回[]int&#123;&#125; &#125; ...&#125; 二、函数进阶2.1 变量作用域1) 全局变量全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。在函数中可以访问到全局变量。 123456789101112package mainimport &quot;fmt&quot;var sag int64 = 10func testGlobalVar() &#123; fmt.Println(&quot;num=%d\\n&quot;, sag);&#125;func main() &#123; testGlobalVar()&#125; 2) 局部变量函数内定义的变量无法在函数外进行访问。 12345678func testLocalVar() &#123; var x int64 = 100 fmt.Println(x)&#125;func main() &#123; // 访问不到在 testLocalVar() 函数中定义的代码 x fmt.Println(x)&#125; 如果局部变量和全局变量重名，优先访问局部变量。 12345678910package mainimport &quot;fmt&quot;var num int64 = 10func testNum() &#123; num := 100 fmt.Println(num) //优先使用局部变量 num的值为100&#125; 通常在if条件循环、for循环、switch语句上使用这种定义变量的方式。 12345678910111213func testLocalVar2(x, y int) &#123; fmt.Println(x, y) // 函数的参数只会在本函数内生效 if x &gt; 0 &#123; z := 100 //变量z只在if语句块中生效 fmt.Println(z) &#125;&#125;func testLocalVar3() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) //变量i只在当前for语句块中生效 &#125; //fmt.Println(i) //此处无法使用变量i&#125; 2.2 函数类型与变量1) 定义函数类型我们可以使用 type 关键字来定义一个函数类型。 1type calculation func(int, int) int 上面语句定义了一个 calculation 类型，他是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。 简单来说，凡是满足这个条件的函数都是 calculation 类型的函数 123456func add(x, y int) int &#123; return x + y&#125;func sub(x, y int) int &#123; return x - y&#125; add和sub都可以赋值给calculation类型的变量 12var c calculationc = add 2) 函数类型变量12345678910func main() &#123; var c calculation // 声明一个calculation类型的变量c c = add // 把add赋值给c fmt.Printf(&quot;type of c:%T\\n&quot;, c) // type of c:main.calculation fmt.Println(c(1, 2)) // 像调用add一样调用c f := add // 将函数add赋值给变量f fmt.Printf(&quot;type of f:%T\\n&quot;, f) // type of f:func(int, int) int fmt.Println(f(10, 20)) // 像调用add一样调用f&#125; 2.3 高阶函数1)函数作为参数12345678910func add(x, y int) int &#123; return x + y&#125;func calc(x, y int, op func(int, int) int) int &#123; return op(x, y)&#125;func main() &#123; ret2 := calc(10, 20, add) fmt.Println(ret2) //30&#125; 2)函数作为返回值1234567891011func do(s string) (func(int, int) int, error) &#123; switch s &#123; case &quot;+&quot;: return add, nil case &quot;-&quot;: return sub, nil default: err := errors.New(&quot;无法识别的操作符&quot;) return nil, err &#125;&#125; 2.4 匿名函数和闭包1) 匿名函数函数可以作为返回值。但是在Go语言中函数内部不能像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数。 123func(参数)(返回值)&#123; 函数体&#125; 匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数 123456789101112func main() &#123; //将匿名函数保存到变量 add := func(x, y int) &#123; fmt.Println(x + y) &#125; add(10, 20) // 自执行函数: 匿名函数定义完成后加()直接执行 func(x, y int) &#123; fmt.Println(x + y) &#125;(10, 20)&#125; 2)闭包闭包=函数+引用环境 12345678910111213141516func adder() func(int) int &#123; var x int return func(y int) int &#123; x += y return x &#125;&#125;func main()&#123; var f = adder() fmt.Println(f(10)) //10 fmt.Println(f(20)) //30 f1 := adder() fmt.Println(f1(40)) //40 fmt.Println(f1(40)) //50&#125; 变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效。 2.5 defer语句Go 语言中的 defer 语句会将其后面跟随的语句进行延时处理。先被 defer的语句最后被执行，最后被defer的语句，最先被执行。 由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。 内置函数 内置函数 介绍 close 主要用来关闭channel len 用来求长度，比如string、array、slice、map、channel new 用来分配内存，主要用来分配类型，比如int、struct。返回的是指针 make 用来分配内存，主要用来分配引用类型,比如chan、map、slice append 用来追加元素到数组、slice中 panic和recover 用来做错误处理 3.1 panic&#x2F;recoverGo语言中目前（Go1.12）是没有异常机制，但是使用panic/recover模式来处理错误。 panic可以在任何地方引发，但recover只有在defer调用的函数中有效。 121.reover()必须搭配defer使用2.defer一定要在可能引发panic的语句之前定义。","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"函数","slug":"函数","permalink":"https://liuxindg.gitbub.io/tags/%E5%87%BD%E6%95%B0/"},{"name":"func","slug":"func","permalink":"https://liuxindg.gitbub.io/tags/func/"}],"author":"琉心"},{"title":"Golang学习_Map","slug":"Golang学习-Map","date":"2023-06-15T05:05:59.000Z","updated":"2023-06-15T05:06:41.093Z","comments":true,"path":"2023/06/15/Golang学习-Map/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-Map/","excerpt":"Go语言基础之 mapGo 语言中提供的映射关系容器为 map，其内部使用 散列表(hash) 实现。","text":"Go语言基础之 mapGo 语言中提供的映射关系容器为 map，其内部使用 散列表(hash) 实现。 1. mapmap 是一种无序的 key-value 的数据结构，Go 语言中的 map 是引用类型，必须初始化才能使用 1.1 map定义123map[keyType]ValueType// KeyType: 表示键的类型// ValueType: 表示值的类型 map 类型的变量默认初始值为 nil ，需要使用 make()函数来分配内存 1make(map[keyType]ValueType, [cap]) 1.2 map基本使用map的数据都是成对出现的，基本使用如下 12345678func main() &#123; scoreMap := make(map[string]int, 10) scoreMap[&quot;张三&quot;] = 20 scoreMap[&quot;李四&quot;] = 22 fmt.Println(scoreMap) fmt.Println(scoreMap[&quot;张三&quot;]) fmt.Println(&quot;type of a:%T\\n&quot;, scoreMap)&#125; 输出结果 123map[小明:20 张三:22]100type of a:map[string]int map 支持在声明的时候填充元素 123456func main() &#123; userInfo := map[string]string&#123; &quot;username&quot;: &quot;琉心&quot;, &quot;password&quot;: &quot;123456&quot;, &#125;&#125; 1.3 判断某个值是否存在Go 语言中有个判断 map 中键是否存在的特殊写法 1value, ok := map[key] 1.4 map的遍历Go 语言中使用 for range 遍历 map 123456789func main() &#123; scoreMap := make(map[string]int) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 scoreMap[&quot;娜扎&quot;] = 60 for k, v := range scroeMap &#123; fmt.Println(k, v) &#125;&#125; 但当我们只想着遍历 key 的时候，可以采用 123456789func main() &#123; scoreMap := make(map[string]int) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 scoreMap[&quot;娜扎&quot;] = 60 for k := range scoreMap &#123; fmt.Println(k) &#125;&#125; 1.5 使用 delete() 函数删除键值对使用delete() 函数从 map中删除一组键值对。 1234delete(map, key)// map：表示要删除键值对的 map// key：表示要删除键值对的键 1.6 按照指定顺序遍历 map12345678910111213141516171819202122func main() &#123; var scoreMap = make(map[string]int, 100) for i := 0; i &lt; 50; i++ &#123; key := fmt.Sprintf(&quot;stu%02d&quot;, i) value := rand.Intn(100) scoreMap[key] = value &#125; // for k, v := range scoreMap &#123; // fmt.Println(k, v) // &#125; // 取出所有的 key 存放到切片中 keys := make([]string, 0, 100) for k := range scoreMap &#123; keys = append(keys, k) &#125; // 对key做排序 sort.Strings(keys) // 按照排序后的 key 对 scoreMap 排序 for _, key := range keys &#123; fmt.Println(key,scoreMap[key]) &#125;&#125; 1.7 元素为 map 类型的切片1234567891011121314func main() &#123; var mapSlice = make([]map[string]string, 3) // 只完成了切片的初始化 for index, key := range mapSlice &#123; fmt.Printf(&quot;index:%d value:%v\\n&quot;, index, value) &#125; // 对切片中的 map元素进行初始化 mapSlice[0] = make(map[string]string, 10) // 完成了 map 的初始化 mapSlice[0][&quot;name&quot;] = &quot;小王子&quot; mapSlice[0][&quot;password&quot;] = &quot;123456&quot; mapSlice[0][&quot;address&quot;] = &quot;沙河&quot; for index, value := range mapSlice &#123; fmt.Printf(&quot;index:%d value:%v\\n&quot;, index, value) &#125;&#125; 1.8 值为切片类型的 map12345678910111213141516func main() &#123; var sliceMap = make(map[string][]int, 8) //只完成了map的初始化 v, ok := sliceMap[&quot;中国&quot;] if ok &#123; fmt.Println(v) &#125;else &#123; sliceMap[&quot;中国&quot;] = make([]int, 8) // 完成了对切片的初始化 sliceMap[&quot;中国&quot;][0] = 100 sliceMap[&quot;中国&quot;][1] = 200 sliceMap[&quot;中国&quot;][2] = 300 &#125; // 遍历 sliceMap for k, v := range sliceMap &#123; fmt.Println(k, v) &#125;&#125; 练习题2.1写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how&#x3D;1 do&#x3D;2 you&#x3D;1。 123456789101112131415161718192021func main() &#123; // 定义一个 map[string]int var s = &quot;how do you do&quot; var wordCount = make(map[string]int, 10) // 字符串中有哪些单词 words := strings.Split(s, &quot; &quot;) // 遍历单词做统计 for _, word := range words &#123; v, ok := wordCount[word] if ok &#123; // map中有这个单词的统计记录 wordCount[word] = v + 1 &#125;else &#123; // map 中没有这个单词的记录 wordCount[word] = 1 &#125; &#125; for k, v := range wordCount &#123; fmt.Println(k, v) &#125;&#125; 2.2123456789101112func main() &#123; type Map map[string][]int m := make(Map) s := []int&#123;1, 2&#125; s = append(s, 3) fmt.Printf(&quot;%+v\\n&quot;, s) m[&quot;q1mi&quot;] = s s = append(s[:1], s[2:]...) fmt.Printf(&quot;%+v\\n&quot;, s) fmt.Printf(&quot;%+v\\n&quot;, m[&quot;q1mi&quot;])&#125;查看上述代码的输出结果 123[1 2 3][1 3][1 3 3]","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"map","slug":"map","permalink":"https://liuxindg.gitbub.io/tags/map/"}],"author":"琉心"},{"title":"Golang学习_基础语法","slug":"Golang学习-基础语法","date":"2023-06-15T04:58:01.000Z","updated":"2023-06-15T04:59:24.684Z","comments":true,"path":"2023/06/15/Golang学习-基础语法/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"Go语言Go语言（Google开源、编译型语言、21世纪的C语言） Go 语言的特点(简单易学习、开发效率高、执行性能好)","text":"Go语言Go语言（Google开源、编译型语言、21世纪的C语言） Go 语言的特点(简单易学习、开发效率高、执行性能好) 开发环境准备Go 语言代码结构下面这个是一个简单的 Go 语言的代码结构 12345678910// 代码中，非注释的第一行，一定要是包的声明，声明我们写的Go文件到底属于哪一个包，每一个Go程序都应该包含一个 main 包package main// “import”是导入的意思，这一行就是告诉 Go 编译器，我写的代码需要 fmt 这个包。import &quot;fmt&quot;// “func”关键字，定义函数。&quot;main&quot;函数是程序开始执行的函数，每一个可执行程序都会有一个 &quot;main&quot;函数。func main() &#123; // 这一行表示访问 &quot;fmt&quot; 包中的 &quot;Println&quot; 函数 fmt.Println(&quot;hello,world!&quot;)&#125; 注意: GO语言的花括号，不能单独放在一行，必须跟在函数或者其他语句的结尾；Go 语言一行代码就代表一个语句，不需要加分号；带有逻辑的一些语句，必须放在函数内部 变量以及常量标识符与关键字标识符在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等。Go 语言中标识符只能由字母数字和下划线组成。 关键字Go 语言中有25个关键字: 12345break default func interface select case defer go map struct chan else goto packageswitch const fallthrough if range typecontinue for import return var Go语言中还有37个保留字: 12345678Constants: true false iota nilTypes: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string errorFunctions: make len cap new append copy close delete complex real imag panic recover 变量变量类型变量(Variable) 的功能是存储数据。常见变量的数据类型有：整形、浮点型、布尔型等。 变量声明Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明，并且Go语言的变量声明后必须使用。 Go 语言中的变量声明格式为： 12345var 变量名 变量类型// 举个例子var name stringvar age int Go 语言中还支持批量声明，因为每次声明一个变量就需要写一个 var 关键字会比较繁琐。 123456var ( a string b int c bool d float32) 变量的初始化Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。 Go 语言变量初始化的标准格式如下: 12345678var 变量 类型 = 表达式// 举个例子var name string = &quot;小张&quot;var age int = 20// 或者一次初始化多个变量var name, age = &quot;小张&quot;, 20 有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。 1var name = &quot;小张&quot; //name 为 string 在函数内部，可以使用更加简略的 := 方式声明并且初始化变量 123456789101112package mainimport ( &quot;fmt&quot;)// 全局变量mvar m = 100func main() &#123; n := 10 fmt.Println(m,n)&#125; 在使用多重赋值时，如果想要忽略某个值，可以使用 匿名变量(annoymous variable)。匿名变量用一个下划线_表示 123456789func foo() (int, string) &#123; return 10, &quot;qqq&quot;&#125;func main() &#123; x, _ := foo() _, y := foo() fmt.Println(&quot;x=&quot;, x) // x= 10 fmt.Println(&quot;y=&quot;, y) // y= qqq&#125; 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 注意事项： 函数外的每个语句都必须以关键字开始 (var, const, func 等) :&#x3D; 不能使用在函数外 _多用于占位，表示忽略值 常量相对于变量，常量是恒定不变的量，多用于定义程序运行期间不会改变的那些值。常量在定义的时候必须赋值 常量的声明: 12const pi = 3.1415926const e = 2.7182 多个常量可以一起声明: 1234const ( pi = 3.1415926 e = 2.7182) const 同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 12345const ( n1 = 100 n2 // n2 = 100 n3 // n3 = 100) iota 是 go 语言的常量计数器，只能在常量的表达式中使用 iota 在 const 关键字出现时将被重置为0。const中每新增一行常量声明将使iota 计数一次 123456const ( n1 = iota //0 n2 //1 n3 //2 n4 //3) 基础数据类型Go 语言中有丰富的数据类型，除了基础的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道(channel)等。 整型按长度分为: int8，int16，int32，int64对应的无符号整型：uint8，uint16，uint32，uint64 uint8 就是 byte 型，int16对应C语言的short型，int64对应C语言中的long型。 特殊整型: 类型 描述 uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 数字字面量语法（Number literals syntax）v := 0b00101101，代表二进制的 101101，相当于十进制的 45。v := 0o377，代表八进制的 377，相当于十进制的255。v := 0x1p-2，代表十六进制的 1除以2^2，也就是0.25。 而且还允许我们用 _来分隔数字，比如说 v := 123_456，表示 v 的值等于123456。 1234567891011121314func main() &#123; //十进制 var a int = 10 fmt.Printf(&quot;%d\\n&quot;, a) //10 fmt.Printf(&quot;%b\\n&quot;, a) //1010 占位符%b表示二进制 //八进制 以0开头 var b int = 077 fmt.Printf(&quot;%o\\n&quot;, b) //77 // 十六进制 以0x开头 var c int = 0xff fmt.Printf(&quot;%x\\n&quot;, c) //ff fmt.Printf(&quot;%X\\n&quot;, c) //FF&#125; 浮点型Go 语言支持两种浮点型数：float32和 float64。 1234func main() &#123; fmt.Printf(&quot;%f\\n&quot;,math.Pi) fmt.Printf(&quot;%.2f\\n&quot;,math.Pi)&#125; 复数complex64和complex128 1234var c1 complex64c1 = 1 + 2ivar c2 complex128c2 = 2 + 3i 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。 布尔值Go 语言中以 bool 类型进行声明布尔型数据，布尔型数据只有 true和 false 两个值。 注意事项： 布尔类型变量的默认值为false。 Go语言中不允许将整型强制转换为布尔型。 布尔型无法参与数值运算，也无法与其他类型进行转换。 字符串Go 语言中的字符串的内部实现使用 UTF-8编码。字符串的值为双引号中的内容。 12s1 = &quot;hello&quot;s2 = &quot;你好&quot; 字符串转义符 转义符 含义 \\r 回车符(返回行首) \\n 换行符(直接跳到下一行的同列位置) \\t 制表符 &#39; 单引号 &quot; 双引号 \\ 反斜杠 多行字符串Go语言中要定义一个多行字符串时，就必须使用 反引号字符: 1234s1 := `第一行第二行第三行` 字符串中的常用操作 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix，strings.HasSuffix 前缀&#x2F;后缀判断 strings.Index()，strings.LastIndex() 子串出现的位置 strings.Jon(a[]string,sep string) join操作 byte和rune类型组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。字符用单引号（‘’）包裹起来，如 12var a = &#x27;中&#x27;var b = &#x27;x&#x27; GO 语言的字符有两种类型： uint8类型，或者叫做byte型，代表一个ASCII码值 rune类型，代表一个UTF-8字符。 修改字符串要修改字符串，需要先将其转成[]rune或[]byte，完成后在转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。 123456789101112func changeString() &#123; s1 := &quot;big&quot; // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = &#x27;p&#x27; fmt.Println(string(byteS1)) s2 := &quot;白萝卜&quot; runeS2 := []rune(s2) runeS2[0] = &#x27;红&#x27; fmt.Println(string(runeS2))&#125; 类型转换Go 语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。 强制类型转换的基本语法如下: 1T(表达式) 其中T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等。 运算符算数运算符 运算符 描述 + 相加 - 相减 * 相乘 &#x2F; 相除 % 求余 注意：++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符 关系运算符 运算符 描述 &#x3D;&#x3D; 检查两个值是否相等，如果相等返回 true否则返回false !&#x3D; 检查两个值是否不相等，如果不相等返回true否则返回false &gt; 检查左边值是否大于右边值，如果是返回true，否则返回false &gt;&#x3D; 检查左边值是否大于等于右边值，如果是返回true，否则返回false &lt; 检查左边值是否小于右边值，如果是返回true，否则返回false &lt;&#x3D; 检查左边值是否小于等于右边值，如果是返回true，否则返回false 逻辑运算符 运算符 描述 &amp;&amp; 逻辑 AND 运算符。如果两边的操作都是True，则为True，否则为False || 逻辑OR运算符。如果两边的操作有一个是True，则为True，否则为False ！ 逻辑NOT运算符。如果条件为True，则为False，否则为True。 位运算符位运算符对整数在内存中的二进制位进行操作。 运算符 描述 &amp; 参与运算的两数各对应的二进位相与(两位均为1才为1) | 参与运算的两数各对应的二进位相或(两位有一个为1就为1) ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1（两位不一样则为1） &lt;&lt; 左移n位就是乘以2的n次方(“a&lt;&lt;b”就是把a的各二进位全部左移b位，高位丢弃，低位补零) &gt;&gt; 右移n位就是除以2的n次方(“a&gt;&gt;b”是把a的各二进位全部右移b位。) 赋值运算符 运算符 描述 &#x3D; 简单的赋值运算符，将一个表达式的值赋给一个左值 +&#x3D; 相加后再赋值 -&#x3D; 相减后再赋值 *&#x3D; 相乘后再赋值 &#x2F;&#x3D; 相除后再赋值 %&#x3D; 求余后再赋值 &lt;&lt;&#x3D; 左移后赋值 &gt;&gt;&#x3D; 右移后赋值 &amp;&#x3D; 按位与后赋值 |&#x3D; 按位或后赋值 ^&#x3D; 按位异或后赋值 流程控制Go语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。 if-else 分支if条件判断基本条件Go 语言中 if 条件判断的格式如下: 1234567if 表达式1 &#123; 分支1&#125; else if 表达式2 &#123; 分支2&#125; else &#123; 分支3&#125; 当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 Go 语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 if条件判断特殊写法if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子： 123456789func ifDemo() &#123; if score := 65; score &gt;= 90 &#123; fmt.Println(&quot;A&quot;) &#125; else if score &gt; 75 &#123; fmt.Println(&quot;B&quot;) &#125; else &#123; fmt.Println(&quot;C&quot;) &#125;&#125; for（循环结构）for 循环的基本格式如下: 123for 初始语句;条件表达式;结束语句&#123; 循环体语句&#125; 123456789101112131415//for 循环的初始语句可以省略，但是初始语句后的分号必须要写。for forDemo2() &#123; i := 0 for ; i &lt; 10; i++ &#123; fmt.Println(i) &#125;&#125;// for 循环的初始语句和结束语句都可以省略for forDemo3() &#123; i := 0 for i &lt; 10 &#123; fmt.Println(i) i++ &#125;&#125; 无限循环123for &#123; 循环体结构&#125; for 循环可以通过 break、goto、return、panic 语句强制退出循环 for range（键值循环）Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律： 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。 switch case12345678910111213// 使用switch语句可以方便地对大量的值进行条件判断func switchDemo1() &#123; finger := 3 switch finger &#123; case 1: fmt.Println(&quot;1&quot;) case 2: fmt.Println(&quot;2&quot;) default: fmt.Println(&quot;None&quot;) &#125;&#125; 一个分支还可以有多个值，多个值中间使用英文逗号隔开 1234switch n := 7; n&#123; case 1, 3, 5, 7: fmt.Println(&quot;11&quot;)&#125; 分支还可以使用表达式，这个时候swtich后面不需要跟判断变量 1234567age := 111switch &#123; case age &gt; 70: fmt.Println(&quot;享受人生&quot;) default: fmt.Println(&quot;活着真好&quot;)&#125; fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。 12345678s := &quot;a&quot;switch &#123; case s == &quot;a&quot;: fmt.Println(&quot;A&quot;) fallthrough case s == &quot;b&quot;: fmt.Println(&quot;B&quot;)&#125; 输出结果 1AB goto(跳转到指定标签)goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。 1234goto breakingbreaking: fmt.Println(&quot;退出&quot;) break（跳出循环）break语句可以结束for、switch和select的代码块。 break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 continue(继续下次循环)continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。 数组Array(数组)数组是同一种数据类型元素的集合。 数组定义:1var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1。 数组的初始化方法一初始化数组时可以使用初始化列表来设置数组元素的值。 123var testArray [3]intvar numArray [3]int&#123;1,2&#125;var cityArray [3]string&#123;&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;&#125; 方法二按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度。 12var numArray [...]int&#123;1,2&#125;var cityArray [...]string&#123;&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;&#125; 方法三我们还可以使用指定索引值的方式来初始化数组，例如: 1var 数组变量名 [...]int&#123;下标:数值&#125; 数组的遍历1234567891011func main() &#123; var cityArray [...]string&#123;&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;&#125; // 使用 for 循环 for i := 0; i &lt; len(cityArray); i++ &#123; fmt.Println(cityArray[i]) &#125; // 使用for range for index, value range cityArray &#123; fmt.Println(index,value) &#125;&#125; 多维数组二维数组的定义1234567func main() &#123; a := [3][2]string&#123; &#123;&quot;上海&quot;,&quot;北京&quot;&#125;, &#123;&quot;广州&quot;,&quot;深圳&quot;&#125;, &#123;&quot;西安&quot;,&quot;成都&quot;&#125; &#125;&#125; 二维数组的遍历123456for _, v1 range a &#123; for _, v2 range v1 &#123; fmt.Println(&quot;%s\\t&quot;,v2) &#125; fmt.Println()&#125; 注意： 多维数组只有第一层可以使用…来让编译器推导数组长度。例如： 12345a := [...][2]string&#123; &#123;&quot;上海&quot;,&quot;北京&quot;&#125;, &#123;&quot;广州&quot;,&quot;深圳&quot;&#125;, &#123;&quot;西安&quot;,&quot;成都&quot;&#125;&#125; 数组是值类型数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。 注意: 数组支持 “&#x3D;&#x3D;“、”!&#x3D;” 操作符，因为内存总是被初始化过的。 [n]T表示指针数组，[n]T表示数组指针 。 切片切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。 切片的定义声明切片类型的基本语法如下: 1var 变量名 []切片中的元素类型 切片的长度和容量使用 len() 函数求长度，使用内置的 cap() 函数求切片的容量。 切片表达式切片表达式中的 low 和 high 表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1&lt;&#x3D;索引值&lt;4的元素组成切片s，得到的 切片长度=high-low ，容量等于得到的切片的底层数组的容量。 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度: 完整切片表达式1a[low: high: max] 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。 使用make()函数构造切片123456make([]T, size, cap)/* T: 切片的元素类型 size: 切片中元素的数量 cap: 切片的容量*/ 切片的本质切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。 判断切片是否为空值使用 len(s) &#x3D;&#x3D; 0判断，不使用 s &#x3D;&#x3D; nil来判断。 切片不能直接比较切片之间是不能比较的，我们不能使用&#x3D;&#x3D;操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 切片的赋值拷贝了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容。 1234567func main() &#123; s1 := make([]int, 3) s2 := s1 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0]&#125; 切片遍历切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。 1234567891011func main() &#123; s := []int&#123;1, 3, 5&#125; for i := 0; i &lt; len(s); i++ &#123; fmt.Println(i,s[i]) &#125; for index, value := range s &#123; fmt.Println(index, value) &#125;&#125; append()方法为切片添加元素Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。 1234567func main() &#123; var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int&#123;5, 6, 7&#125; s = append(s, s2...) // [1 2 3 4 5 6 7]&#125; 注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。 12var a []inta = append(a, 1, 2, 3) 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。 切片的扩容策略切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。 使用copy()函数复制切片Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下： 1234copy(destSlice, srcSlice []T)// srcSlice：数据来源切片// destSlice：目标切片 从切片中删除元素Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下： 12345func main() &#123; a := []int&#123;30, 31, 32, 33, 34, 35&#125; // 删除索引为2的元素 a = append(a[:2], a[3:]...)&#125; 要从切片a中删除索引为 index 的元素，操作方法是 a &#x3D; append(a[:index], [index+1:]…)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"基础语法","slug":"基础语法","permalink":"https://liuxindg.gitbub.io/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"author":"琉心"},{"title":"近代史","slug":"近代史","date":"2023-06-15T03:12:58.000Z","updated":"2023-06-15T03:12:58.130Z","comments":true,"path":"2023/06/15/近代史/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/%E8%BF%91%E4%BB%A3%E5%8F%B2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"嵌入式笔记","slug":"嵌入式笔记","date":"2023-06-13T12:10:45.000Z","updated":"2023-06-14T12:05:43.478Z","comments":true,"path":"2023/06/13/嵌入式笔记/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"嵌入式笔记整理第一章 嵌入式系统设计基础1.1 嵌入式系统概述1.1.1 什么是嵌入式系统嵌入式系统是以应用为中心，以计算机技术为基础，软件、硬件可剪裁，以适用于应用系统对功能、可靠性、成本、体积、功耗等要求严格的专用计算机系统。","text":"嵌入式笔记整理第一章 嵌入式系统设计基础1.1 嵌入式系统概述1.1.1 什么是嵌入式系统嵌入式系统是以应用为中心，以计算机技术为基础，软件、硬件可剪裁，以适用于应用系统对功能、可靠性、成本、体积、功耗等要求严格的专用计算机系统。 1.1.2 嵌入式系统的技术特点四大特性：专用性、低成本、可裁剪性、可靠性 1.1.3 嵌入式系统的组成分为硬件设备和软件设备，嵌入式处理器-&gt;硬件核心。 1）嵌入式处理器类型微控制器(MCU)；嵌入式微处理器(MPU)；数字信号处理器(DSP)；片上系统(Soc) 2）嵌入式操作系统谷歌的Android系统和苹果的iOS系统。实时操作系统常用免费的uC&#x2F;OS-II或者商业化的VxWorks等。 1.2 嵌入式系统的开发1.2.1 嵌入式系统的开发模式宿主机-目标机(开发模式) 第二章 ARM Cortex-M3 处理器2.2 Cortex-M3 处理器 CM3的功能模块高性能32位RISC处理器；大量寄存器，都可用于多种用途；采用Thumb指令集结构；3级流水线（取指-译码-执行）；采用哈佛存储结构；高级微控制器总线结构 CM3的两个状态两个级别两种模式 两个状态：Thumb状态、调试状态 两个级别：特权级、非特权级 两种模式：异常处理模式、线程模式 2.3 寄存器1.通用寄存器 CM3设计有16个32位通用寄存器，R0~R12是真正意义上的通用寄存器。 2.专用寄存器 专用寄存器不通过存储器地址访问，而是使用专用寄存器访问指令 程序状态寄存器(Program Status Register,PSR) 异常屏蔽位寄存器(Exception Mask Register) 2.4 存储器组织1.位带区 别名地址&#x3D;位带基地址+字节偏移量×32+位号×4 位带基地址通常情况下为:0x22000以及0x42000 字节偏移量根据要访问的位带地址距离基地址0x2000和0x4000的偏移值 位号：题目会给 2.字节存储顺序 低位低，高位高（小端存储）；高位低，低位高（大端存储） 第四章 STM32 微控制器4.1 STM32微控制器结构4.1.2 STM32系统结构 通用输入&#x2F;输出端口(GPIO)以及复用功能的输入&#x2F;输出端口(AFIO) 通用同步&#x2F;异步接收发送器(USART)；通用异步接收发送器(UART) 串行外设接口(SPI) 内部集成电路I2C接口(I2C) 看门狗(Watch Dog)，独立看门狗(IWDG)和窗口看门狗(WWDG) 实时时钟(RTC) 通用定时器(TIMx) 模拟&#x2F;数字转换器ADC 缩写 外设名称 缩写 外设名称 adc A&#x2F;D转换器 bkp 备份寄存器 can CAN控制器局域网 cec 消费电子单元 crc CRC计算单元 dac D&#x2F;A转换器 dbgmc MCU调试模块 dma DMA控制器 exti 外部中断寄存器 flash 闪存 fsmc 灵活的静态存储器控制器 gpio 通用I&#x2F;O接口 i2c I²C总线接口 iwdg 独立看门狗 pwr 电源控制 rcc 复位和时钟控制器 rtc 实时时钟 sdio SD存储卡接口 spi SPI串行外设接口 tim 定时器 usart 通用同步异步收发器 wwdg 窗口看门狗 4.2 STM32微控制器开发4.2.3 C语言应用2. C语言的位操作123a &amp;= ~(1&lt;&lt;6) //位与实现复位:将整形变量a的D6位清零，其他位不变。a |= (1&lt;&lt;6) // 位或实现置位:将整形变量a的D6位置位，其他位不变。a ^= (1&lt;&lt;6) // 位异或实现求反：将整形变量a的D6位取反，其他位不变 4.3 复位与时钟控制(RCC)1. 电源控制3种低功耗模式 睡眠模式(Sleep Mode) 停止模式(Stop Mode) 备用模式(Standby Mode) 2. 复位三种复位：系统复位、电源复位和备份复位 3. 时钟树系统时钟 SYSCLK 内部高速时钟HIS、高速外部时钟HSE和锁相环PLL 第五章 STM32的通用I&#x2F;O端口5.1 GPIO的结构和功能GPIO一共112个引脚，用GPIOx(x是A、B、C、D、E、F、G)表示，即GPIOA GPIOB … GPIOG。每组端口有16个外设引脚，分别用Px0,Px1,…Px15(x是A~G)表示。 1.输入模式4种输入模式： 模拟输入模式(Analog): 不上拉也不下拉 浮空输入模式(Input Floating): 不上拉也不下拉 上拉输入模式(Input Pull-up): 接上拉电阻 下拉输入模式(Input Pull-down): 接下拉电阻 2. 输出模式4中输出模式，但是常用以下两种输出模式: 推挽输出(Output Push-Pull) 开漏输出(Output Open-Drain) 5.3 GPIO 案例5.3.2 应用程序分析1. 开启外设时钟2. 初始化外设3. 控制外设工作5.3.3 实例代码1234567891011HAL_GPIO_WritePin(GPIOB，GPIO_PIN_5，GPIO_PIN_RESET)；// PB5引脚输出低电平，LED0灯亮HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5,GPIO_PIN_SET);// PE5 引脚输出高电平，LED1灯灭HAL_Delay(1000) //持续1秒HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5);// 读取PC5引脚的电平状态HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_3);// 反转 PE3 引脚的电平状态 第六章 CM3异常和STM32中断6.1 Cortex-M3 的异常2.异常优先级优先级的数值越小，优先级越高 组优先级（Group Priority）和子优先级(Sub-Priority)。组优先级被称为抢占优先级。 组优先级确定是否可以打断正在执行的中断，实现嵌套。子优先级只用于在相同组优先级时多个子优先级同时出现的情况，高优先级别（优先级数值小）的异常首先被处理。 3. 嵌套向量中断控制器NVICNVIC 集成在 ARM Cortex-M3 内核中 6.2 STM32的中断应用6.2.1 NVIC 初始化配置1. 配置组优先级 6.2.2 外部中断EXTISTM32 芯片外设的中断请求直接连接到 NVIC，来自芯片之外的外设中断请求需要通过EXTI（外部中断&#x2F;事件控制器）连接到NVIC。 2. EXTI 寄存器 第七章 STM32 的串行通信接口7.1 串行异步通信串行通信有两类：一类是速度较快的同步串行通信，以数据块为基本传输单位，主要应用于网络连接；另一类是速度较慢的异步通信，以字符为单位传输，主要应用于近距离通信。通常所说的串行通信一般是指串行同步通信 7.1.1 串行异步通信字符格式 起始位(Start Bit): 采取逻辑 0 电平 数据位(Data Bit): 一般是8位 校验位(Parity Bit): 可有可无，一般是奇偶校验位 停止位(Stop Bit): 字符最后必须有停止位，采取逻辑1电平 通信传输速率要相同，如9600bps表示一秒传输9600位 7.1.2 串行异步通信接口1. RS-232标准的引脚定义 TxD(Transmitted Data,发送数据) RxD(Received Data, 接收数据) RTS(Request To Send，请求发送) CTS(Clear To Send，清除发送) DTR(Data Terminal Ready，数据终端准备好) DSR(Data Set Ready，数据装置准备好) GND(Ground，信号地) CD(Carrier Detected，载波检测) RI(RIng Indicator，振铃指示) 2. RS-232接口的连接三线相连 7.2 通用同步&#x2F;异步接收&#x2F;发送器通用同步&#x2F;异步接收&#x2F;发送器（USART）和通用异步接收&#x2F;发送器(UART)","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://liuxindg.gitbub.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式复习","slug":"嵌入式复习","permalink":"https://liuxindg.gitbub.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0/"}],"author":"琉心"},{"title":"text1","slug":"text1","date":"2023-06-13T11:18:32.000Z","updated":"2023-06-13T11:23:55.046Z","comments":true,"path":"2023/06/13/text1/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/13/text1/","excerpt":"","text":"111 . 低字节位数据存放在内存低地址处，高字节位数据存放在内存高地址处，这就是小端字节序。 202.96.128.128 D 节省 银行 对10 无缓冲是同步的11。 13212 func f(a,b int) (value int, error) 13 int 和体系架构 14 其他三个 15 主键是唯一、不为空 16 direct 17 直接插入 18 堆 19 在100000 20 不选进程是动态的过程 21 不选 HTTP返回码 302 22 选 协程和线程都可以 以及 通过 channel 23 不选接口赋值 24 不选 数据库索引的存在 25 不选 POST比get安全 26 不选域名解析 27 只选快速 12 28","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-06-13T10:37:15.364Z","updated":"2023-06-13T10:37:15.364Z","comments":true,"path":"2023/06/13/hello-world/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://liuxindg.gitbub.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"包","slug":"包","permalink":"https://liuxindg.gitbub.io/tags/%E5%8C%85/"},{"name":"package","slug":"package","permalink":"https://liuxindg.gitbub.io/tags/package/"},{"name":"结构体","slug":"结构体","permalink":"https://liuxindg.gitbub.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"struct","slug":"struct","permalink":"https://liuxindg.gitbub.io/tags/struct/"},{"name":"指针","slug":"指针","permalink":"https://liuxindg.gitbub.io/tags/%E6%8C%87%E9%92%88/"},{"name":"point","slug":"point","permalink":"https://liuxindg.gitbub.io/tags/point/"},{"name":"函数","slug":"函数","permalink":"https://liuxindg.gitbub.io/tags/%E5%87%BD%E6%95%B0/"},{"name":"func","slug":"func","permalink":"https://liuxindg.gitbub.io/tags/func/"},{"name":"map","slug":"map","permalink":"https://liuxindg.gitbub.io/tags/map/"},{"name":"基础语法","slug":"基础语法","permalink":"https://liuxindg.gitbub.io/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"嵌入式复习","slug":"嵌入式复习","permalink":"https://liuxindg.gitbub.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0/"}]}