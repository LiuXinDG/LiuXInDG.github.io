{"meta":{"title":"琉心的博客","subtitle":"学以致用，方能翱翔","description":"学海无涯，回头是岸","author":"琉心","url":"https://LiuXinDG.gitbub.io","root":"/"},"pages":[{"title":"关于","date":"2023-06-14T08:40:19.000Z","updated":"2023-06-14T08:49:18.970Z","comments":true,"path":"about/index.html","permalink":"https://liuxindg.gitbub.io/about/index.html","excerpt":"","text":"本科在读，计算机科学与技术专业，热爱思考，接收新知，吾日三省吾身。 写博客的目的: 一、总结学习的内容，强迫自己以更加系统和严谨的态度梳理知识体系； 二、记录学习过程中遇到的问题，以及解决问题的经验 联系方式 邮箱：&#x41;&#x31;&#x35;&#x35;&#57;&#53;&#x34;&#48;&#57;&#49;&#x37;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109; Github: https://github.com/LiuXinDG"},{"title":"分类","date":"2023-06-14T08:15:44.000Z","updated":"2023-06-14T08:48:57.477Z","comments":true,"path":"categories/index.html","permalink":"https://liuxindg.gitbub.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-06-14T08:17:09.000Z","updated":"2023-06-14T08:49:09.051Z","comments":true,"path":"tags/index.html","permalink":"https://liuxindg.gitbub.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang学习_基础语法","slug":"Golang学习-基础语法","date":"2023-06-15T04:58:01.000Z","updated":"2023-06-15T04:59:24.684Z","comments":true,"path":"2023/06/15/Golang学习-基础语法/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/Golang%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"Go语言Go语言（Google开源、编译型语言、21世纪的C语言） Go 语言的特点(简单易学习、开发效率高、执行性能好)","text":"Go语言Go语言（Google开源、编译型语言、21世纪的C语言） Go 语言的特点(简单易学习、开发效率高、执行性能好) 开发环境准备Go 语言代码结构下面这个是一个简单的 Go 语言的代码结构 12345678910// 代码中，非注释的第一行，一定要是包的声明，声明我们写的Go文件到底属于哪一个包，每一个Go程序都应该包含一个 main 包package main// “import”是导入的意思，这一行就是告诉 Go 编译器，我写的代码需要 fmt 这个包。import &quot;fmt&quot;// “func”关键字，定义函数。&quot;main&quot;函数是程序开始执行的函数，每一个可执行程序都会有一个 &quot;main&quot;函数。func main() &#123; // 这一行表示访问 &quot;fmt&quot; 包中的 &quot;Println&quot; 函数 fmt.Println(&quot;hello,world!&quot;)&#125; 注意: GO语言的花括号，不能单独放在一行，必须跟在函数或者其他语句的结尾；Go 语言一行代码就代表一个语句，不需要加分号；带有逻辑的一些语句，必须放在函数内部 变量以及常量标识符与关键字标识符在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等。Go 语言中标识符只能由字母数字和下划线组成。 关键字Go 语言中有25个关键字: 12345break default func interface select case defer go map struct chan else goto packageswitch const fallthrough if range typecontinue for import return var Go语言中还有37个保留字: 12345678Constants: true false iota nilTypes: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string errorFunctions: make len cap new append copy close delete complex real imag panic recover 变量变量类型变量(Variable) 的功能是存储数据。常见变量的数据类型有：整形、浮点型、布尔型等。 变量声明Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明，并且Go语言的变量声明后必须使用。 Go 语言中的变量声明格式为： 12345var 变量名 变量类型// 举个例子var name stringvar age int Go 语言中还支持批量声明，因为每次声明一个变量就需要写一个 var 关键字会比较繁琐。 123456var ( a string b int c bool d float32) 变量的初始化Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。 Go 语言变量初始化的标准格式如下: 12345678var 变量 类型 = 表达式// 举个例子var name string = &quot;小张&quot;var age int = 20// 或者一次初始化多个变量var name, age = &quot;小张&quot;, 20 有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。 1var name = &quot;小张&quot; //name 为 string 在函数内部，可以使用更加简略的 := 方式声明并且初始化变量 123456789101112package mainimport ( &quot;fmt&quot;)// 全局变量mvar m = 100func main() &#123; n := 10 fmt.Println(m,n)&#125; 在使用多重赋值时，如果想要忽略某个值，可以使用 匿名变量(annoymous variable)。匿名变量用一个下划线_表示 123456789func foo() (int, string) &#123; return 10, &quot;qqq&quot;&#125;func main() &#123; x, _ := foo() _, y := foo() fmt.Println(&quot;x=&quot;, x) // x= 10 fmt.Println(&quot;y=&quot;, y) // y= qqq&#125; 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 注意事项： 函数外的每个语句都必须以关键字开始 (var, const, func 等) :&#x3D; 不能使用在函数外 _多用于占位，表示忽略值 常量相对于变量，常量是恒定不变的量，多用于定义程序运行期间不会改变的那些值。常量在定义的时候必须赋值 常量的声明: 12const pi = 3.1415926const e = 2.7182 多个常量可以一起声明: 1234const ( pi = 3.1415926 e = 2.7182) const 同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 12345const ( n1 = 100 n2 // n2 = 100 n3 // n3 = 100) iota 是 go 语言的常量计数器，只能在常量的表达式中使用 iota 在 const 关键字出现时将被重置为0。const中每新增一行常量声明将使iota 计数一次 123456const ( n1 = iota //0 n2 //1 n3 //2 n4 //3) 基础数据类型Go 语言中有丰富的数据类型，除了基础的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道(channel)等。 整型按长度分为: int8，int16，int32，int64对应的无符号整型：uint8，uint16，uint32，uint64 uint8 就是 byte 型，int16对应C语言的short型，int64对应C语言中的long型。 特殊整型: 类型 描述 uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 数字字面量语法（Number literals syntax）v := 0b00101101，代表二进制的 101101，相当于十进制的 45。v := 0o377，代表八进制的 377，相当于十进制的255。v := 0x1p-2，代表十六进制的 1除以2^2，也就是0.25。 而且还允许我们用 _来分隔数字，比如说 v := 123_456，表示 v 的值等于123456。 1234567891011121314func main() &#123; //十进制 var a int = 10 fmt.Printf(&quot;%d\\n&quot;, a) //10 fmt.Printf(&quot;%b\\n&quot;, a) //1010 占位符%b表示二进制 //八进制 以0开头 var b int = 077 fmt.Printf(&quot;%o\\n&quot;, b) //77 // 十六进制 以0x开头 var c int = 0xff fmt.Printf(&quot;%x\\n&quot;, c) //ff fmt.Printf(&quot;%X\\n&quot;, c) //FF&#125; 浮点型Go 语言支持两种浮点型数：float32和 float64。 1234func main() &#123; fmt.Printf(&quot;%f\\n&quot;,math.Pi) fmt.Printf(&quot;%.2f\\n&quot;,math.Pi)&#125; 复数complex64和complex128 1234var c1 complex64c1 = 1 + 2ivar c2 complex128c2 = 2 + 3i 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。 布尔值Go 语言中以 bool 类型进行声明布尔型数据，布尔型数据只有 true和 false 两个值。 注意事项： 布尔类型变量的默认值为false。 Go语言中不允许将整型强制转换为布尔型。 布尔型无法参与数值运算，也无法与其他类型进行转换。 字符串Go 语言中的字符串的内部实现使用 UTF-8编码。字符串的值为双引号中的内容。 12s1 = &quot;hello&quot;s2 = &quot;你好&quot; 字符串转义符 转义符 含义 \\r 回车符(返回行首) \\n 换行符(直接跳到下一行的同列位置) \\t 制表符 &#39; 单引号 &quot; 双引号 \\ 反斜杠 多行字符串Go语言中要定义一个多行字符串时，就必须使用 反引号字符: 1234s1 := `第一行第二行第三行` 字符串中的常用操作 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix，strings.HasSuffix 前缀&#x2F;后缀判断 strings.Index()，strings.LastIndex() 子串出现的位置 strings.Jon(a[]string,sep string) join操作 byte和rune类型组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。字符用单引号（‘’）包裹起来，如 12var a = &#x27;中&#x27;var b = &#x27;x&#x27; GO 语言的字符有两种类型： uint8类型，或者叫做byte型，代表一个ASCII码值 rune类型，代表一个UTF-8字符。 修改字符串要修改字符串，需要先将其转成[]rune或[]byte，完成后在转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。 123456789101112func changeString() &#123; s1 := &quot;big&quot; // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = &#x27;p&#x27; fmt.Println(string(byteS1)) s2 := &quot;白萝卜&quot; runeS2 := []rune(s2) runeS2[0] = &#x27;红&#x27; fmt.Println(string(runeS2))&#125; 类型转换Go 语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。 强制类型转换的基本语法如下: 1T(表达式) 其中T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等。 运算符算数运算符 运算符 描述 + 相加 - 相减 * 相乘 &#x2F; 相除 % 求余 注意：++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符 关系运算符 运算符 描述 &#x3D;&#x3D; 检查两个值是否相等，如果相等返回 true否则返回false !&#x3D; 检查两个值是否不相等，如果不相等返回true否则返回false &gt; 检查左边值是否大于右边值，如果是返回true，否则返回false &gt;&#x3D; 检查左边值是否大于等于右边值，如果是返回true，否则返回false &lt; 检查左边值是否小于右边值，如果是返回true，否则返回false &lt;&#x3D; 检查左边值是否小于等于右边值，如果是返回true，否则返回false 逻辑运算符 运算符 描述 &amp;&amp; 逻辑 AND 运算符。如果两边的操作都是True，则为True，否则为False || 逻辑OR运算符。如果两边的操作有一个是True，则为True，否则为False ！ 逻辑NOT运算符。如果条件为True，则为False，否则为True。 位运算符位运算符对整数在内存中的二进制位进行操作。 运算符 描述 &amp; 参与运算的两数各对应的二进位相与(两位均为1才为1) | 参与运算的两数各对应的二进位相或(两位有一个为1就为1) ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1（两位不一样则为1） &lt;&lt; 左移n位就是乘以2的n次方(“a&lt;&lt;b”就是把a的各二进位全部左移b位，高位丢弃，低位补零) &gt;&gt; 右移n位就是除以2的n次方(“a&gt;&gt;b”是把a的各二进位全部右移b位。) 赋值运算符 运算符 描述 &#x3D; 简单的赋值运算符，将一个表达式的值赋给一个左值 +&#x3D; 相加后再赋值 -&#x3D; 相减后再赋值 *&#x3D; 相乘后再赋值 &#x2F;&#x3D; 相除后再赋值 %&#x3D; 求余后再赋值 &lt;&lt;&#x3D; 左移后赋值 &gt;&gt;&#x3D; 右移后赋值 &amp;&#x3D; 按位与后赋值 |&#x3D; 按位或后赋值 ^&#x3D; 按位异或后赋值 流程控制Go语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。 if-else 分支if条件判断基本条件Go 语言中 if 条件判断的格式如下: 1234567if 表达式1 &#123; 分支1&#125; else if 表达式2 &#123; 分支2&#125; else &#123; 分支3&#125; 当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 Go 语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 if条件判断特殊写法if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子： 123456789func ifDemo() &#123; if score := 65; score &gt;= 90 &#123; fmt.Println(&quot;A&quot;) &#125; else if score &gt; 75 &#123; fmt.Println(&quot;B&quot;) &#125; else &#123; fmt.Println(&quot;C&quot;) &#125;&#125; for（循环结构）for 循环的基本格式如下: 123for 初始语句;条件表达式;结束语句&#123; 循环体语句&#125; 123456789101112131415//for 循环的初始语句可以省略，但是初始语句后的分号必须要写。for forDemo2() &#123; i := 0 for ; i &lt; 10; i++ &#123; fmt.Println(i) &#125;&#125;// for 循环的初始语句和结束语句都可以省略for forDemo3() &#123; i := 0 for i &lt; 10 &#123; fmt.Println(i) i++ &#125;&#125; 无限循环123for &#123; 循环体结构&#125; for 循环可以通过 break、goto、return、panic 语句强制退出循环 for range（键值循环）Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律： 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。 switch case12345678910111213// 使用switch语句可以方便地对大量的值进行条件判断func switchDemo1() &#123; finger := 3 switch finger &#123; case 1: fmt.Println(&quot;1&quot;) case 2: fmt.Println(&quot;2&quot;) default: fmt.Println(&quot;None&quot;) &#125;&#125; 一个分支还可以有多个值，多个值中间使用英文逗号隔开 1234switch n := 7; n&#123; case 1, 3, 5, 7: fmt.Println(&quot;11&quot;)&#125; 分支还可以使用表达式，这个时候swtich后面不需要跟判断变量 1234567age := 111switch &#123; case age &gt; 70: fmt.Println(&quot;享受人生&quot;) default: fmt.Println(&quot;活着真好&quot;)&#125; fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。 12345678s := &quot;a&quot;switch &#123; case s == &quot;a&quot;: fmt.Println(&quot;A&quot;) fallthrough case s == &quot;b&quot;: fmt.Println(&quot;B&quot;)&#125; 输出结果 1AB goto(跳转到指定标签)goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。 1234goto breakingbreaking: fmt.Println(&quot;退出&quot;) break（跳出循环）break语句可以结束for、switch和select的代码块。 break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 continue(继续下次循环)continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。 数组Array(数组)数组是同一种数据类型元素的集合。 数组定义:1var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1。 数组的初始化方法一初始化数组时可以使用初始化列表来设置数组元素的值。 123var testArray [3]intvar numArray [3]int&#123;1,2&#125;var cityArray [3]string&#123;&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;&#125; 方法二按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度。 12var numArray [...]int&#123;1,2&#125;var cityArray [...]string&#123;&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;&#125; 方法三我们还可以使用指定索引值的方式来初始化数组，例如: 1var 数组变量名 [...]int&#123;下标:数值&#125; 数组的遍历1234567891011func main() &#123; var cityArray [...]string&#123;&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;&#125; // 使用 for 循环 for i := 0; i &lt; len(cityArray); i++ &#123; fmt.Println(cityArray[i]) &#125; // 使用for range for index, value range cityArray &#123; fmt.Println(index,value) &#125;&#125; 多维数组二维数组的定义1234567func main() &#123; a := [3][2]string&#123; &#123;&quot;上海&quot;,&quot;北京&quot;&#125;, &#123;&quot;广州&quot;,&quot;深圳&quot;&#125;, &#123;&quot;西安&quot;,&quot;成都&quot;&#125; &#125;&#125; 二维数组的遍历123456for _, v1 range a &#123; for _, v2 range v1 &#123; fmt.Println(&quot;%s\\t&quot;,v2) &#125; fmt.Println()&#125; 注意： 多维数组只有第一层可以使用…来让编译器推导数组长度。例如： 12345a := [...][2]string&#123; &#123;&quot;上海&quot;,&quot;北京&quot;&#125;, &#123;&quot;广州&quot;,&quot;深圳&quot;&#125;, &#123;&quot;西安&quot;,&quot;成都&quot;&#125;&#125; 数组是值类型数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。 注意: 数组支持 “&#x3D;&#x3D;“、”!&#x3D;” 操作符，因为内存总是被初始化过的。 [n]T表示指针数组，[n]T表示数组指针 。 切片切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。 切片的定义声明切片类型的基本语法如下: 1var 变量名 []切片中的元素类型 切片的长度和容量使用 len() 函数求长度，使用内置的 cap() 函数求切片的容量。 切片表达式切片表达式中的 low 和 high 表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1&lt;&#x3D;索引值&lt;4的元素组成切片s，得到的 切片长度=high-low ，容量等于得到的切片的底层数组的容量。 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度: 完整切片表达式1a[low: high: max] 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。 使用make()函数构造切片123456make([]T, size, cap)/* T: 切片的元素类型 size: 切片中元素的数量 cap: 切片的容量*/ 切片的本质切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。 判断切片是否为空值使用 len(s) &#x3D;&#x3D; 0判断，不使用 s &#x3D;&#x3D; nil来判断。 切片不能直接比较切片之间是不能比较的，我们不能使用&#x3D;&#x3D;操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 切片的赋值拷贝了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容。 1234567func main() &#123; s1 := make([]int, 3) s2 := s1 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0]&#125; 切片遍历切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。 1234567891011func main() &#123; s := []int&#123;1, 3, 5&#125; for i := 0; i &lt; len(s); i++ &#123; fmt.Println(i,s[i]) &#125; for index, value := range s &#123; fmt.Println(index, value) &#125;&#125; append()方法为切片添加元素Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。 1234567func main() &#123; var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int&#123;5, 6, 7&#125; s = append(s, s2...) // [1 2 3 4 5 6 7]&#125; 注意：通过var声明的零值切片可以在append()函数直接使用，无需初始化。 12var a []inta = append(a, 1, 2, 3) 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。 切片的扩容策略切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。 使用copy()函数复制切片Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下： 1234copy(destSlice, srcSlice []T)// srcSlice：数据来源切片// destSlice：目标切片 从切片中删除元素Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下： 12345func main() &#123; a := []int&#123;30, 31, 32, 33, 34, 35&#125; // 删除索引为2的元素 a = append(a[:2], a[3:]...)&#125; 要从切片a中删除索引为 index 的元素，操作方法是 a &#x3D; append(a[:index], [index+1:]…)","categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"基础语法","slug":"基础语法","permalink":"https://liuxindg.gitbub.io/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"author":"琉心"},{"title":"近代史","slug":"近代史","date":"2023-06-15T03:12:58.000Z","updated":"2023-06-15T03:12:58.130Z","comments":true,"path":"2023/06/15/近代史/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/15/%E8%BF%91%E4%BB%A3%E5%8F%B2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"嵌入式笔记","slug":"嵌入式笔记","date":"2023-06-13T12:10:45.000Z","updated":"2023-06-14T12:05:43.478Z","comments":true,"path":"2023/06/13/嵌入式笔记/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"嵌入式笔记整理第一章 嵌入式系统设计基础1.1 嵌入式系统概述1.1.1 什么是嵌入式系统嵌入式系统是以应用为中心，以计算机技术为基础，软件、硬件可剪裁，以适用于应用系统对功能、可靠性、成本、体积、功耗等要求严格的专用计算机系统。","text":"嵌入式笔记整理第一章 嵌入式系统设计基础1.1 嵌入式系统概述1.1.1 什么是嵌入式系统嵌入式系统是以应用为中心，以计算机技术为基础，软件、硬件可剪裁，以适用于应用系统对功能、可靠性、成本、体积、功耗等要求严格的专用计算机系统。 1.1.2 嵌入式系统的技术特点四大特性：专用性、低成本、可裁剪性、可靠性 1.1.3 嵌入式系统的组成分为硬件设备和软件设备，嵌入式处理器-&gt;硬件核心。 1）嵌入式处理器类型微控制器(MCU)；嵌入式微处理器(MPU)；数字信号处理器(DSP)；片上系统(Soc) 2）嵌入式操作系统谷歌的Android系统和苹果的iOS系统。实时操作系统常用免费的uC&#x2F;OS-II或者商业化的VxWorks等。 1.2 嵌入式系统的开发1.2.1 嵌入式系统的开发模式宿主机-目标机(开发模式) 第二章 ARM Cortex-M3 处理器2.2 Cortex-M3 处理器 CM3的功能模块高性能32位RISC处理器；大量寄存器，都可用于多种用途；采用Thumb指令集结构；3级流水线（取指-译码-执行）；采用哈佛存储结构；高级微控制器总线结构 CM3的两个状态两个级别两种模式 两个状态：Thumb状态、调试状态 两个级别：特权级、非特权级 两种模式：异常处理模式、线程模式 2.3 寄存器1.通用寄存器 CM3设计有16个32位通用寄存器，R0~R12是真正意义上的通用寄存器。 2.专用寄存器 专用寄存器不通过存储器地址访问，而是使用专用寄存器访问指令 程序状态寄存器(Program Status Register,PSR) 异常屏蔽位寄存器(Exception Mask Register) 2.4 存储器组织1.位带区 别名地址&#x3D;位带基地址+字节偏移量×32+位号×4 位带基地址通常情况下为:0x22000以及0x42000 字节偏移量根据要访问的位带地址距离基地址0x2000和0x4000的偏移值 位号：题目会给 2.字节存储顺序 低位低，高位高（小端存储）；高位低，低位高（大端存储） 第四章 STM32 微控制器4.1 STM32微控制器结构4.1.2 STM32系统结构 通用输入&#x2F;输出端口(GPIO)以及复用功能的输入&#x2F;输出端口(AFIO) 通用同步&#x2F;异步接收发送器(USART)；通用异步接收发送器(UART) 串行外设接口(SPI) 内部集成电路I2C接口(I2C) 看门狗(Watch Dog)，独立看门狗(IWDG)和窗口看门狗(WWDG) 实时时钟(RTC) 通用定时器(TIMx) 模拟&#x2F;数字转换器ADC 缩写 外设名称 缩写 外设名称 adc A&#x2F;D转换器 bkp 备份寄存器 can CAN控制器局域网 cec 消费电子单元 crc CRC计算单元 dac D&#x2F;A转换器 dbgmc MCU调试模块 dma DMA控制器 exti 外部中断寄存器 flash 闪存 fsmc 灵活的静态存储器控制器 gpio 通用I&#x2F;O接口 i2c I²C总线接口 iwdg 独立看门狗 pwr 电源控制 rcc 复位和时钟控制器 rtc 实时时钟 sdio SD存储卡接口 spi SPI串行外设接口 tim 定时器 usart 通用同步异步收发器 wwdg 窗口看门狗 4.2 STM32微控制器开发4.2.3 C语言应用2. C语言的位操作123a &amp;= ~(1&lt;&lt;6) //位与实现复位:将整形变量a的D6位清零，其他位不变。a |= (1&lt;&lt;6) // 位或实现置位:将整形变量a的D6位置位，其他位不变。a ^= (1&lt;&lt;6) // 位异或实现求反：将整形变量a的D6位取反，其他位不变 4.3 复位与时钟控制(RCC)1. 电源控制3种低功耗模式 睡眠模式(Sleep Mode) 停止模式(Stop Mode) 备用模式(Standby Mode) 2. 复位三种复位：系统复位、电源复位和备份复位 3. 时钟树系统时钟 SYSCLK 内部高速时钟HIS、高速外部时钟HSE和锁相环PLL 第五章 STM32的通用I&#x2F;O端口5.1 GPIO的结构和功能GPIO一共112个引脚，用GPIOx(x是A、B、C、D、E、F、G)表示，即GPIOA GPIOB … GPIOG。每组端口有16个外设引脚，分别用Px0,Px1,…Px15(x是A~G)表示。 1.输入模式4种输入模式： 模拟输入模式(Analog): 不上拉也不下拉 浮空输入模式(Input Floating): 不上拉也不下拉 上拉输入模式(Input Pull-up): 接上拉电阻 下拉输入模式(Input Pull-down): 接下拉电阻 2. 输出模式4中输出模式，但是常用以下两种输出模式: 推挽输出(Output Push-Pull) 开漏输出(Output Open-Drain) 5.3 GPIO 案例5.3.2 应用程序分析1. 开启外设时钟2. 初始化外设3. 控制外设工作5.3.3 实例代码1234567891011HAL_GPIO_WritePin(GPIOB，GPIO_PIN_5，GPIO_PIN_RESET)；// PB5引脚输出低电平，LED0灯亮HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5,GPIO_PIN_SET);// PE5 引脚输出高电平，LED1灯灭HAL_Delay(1000) //持续1秒HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5);// 读取PC5引脚的电平状态HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_3);// 反转 PE3 引脚的电平状态 第六章 CM3异常和STM32中断6.1 Cortex-M3 的异常2.异常优先级优先级的数值越小，优先级越高 组优先级（Group Priority）和子优先级(Sub-Priority)。组优先级被称为抢占优先级。 组优先级确定是否可以打断正在执行的中断，实现嵌套。子优先级只用于在相同组优先级时多个子优先级同时出现的情况，高优先级别（优先级数值小）的异常首先被处理。 3. 嵌套向量中断控制器NVICNVIC 集成在 ARM Cortex-M3 内核中 6.2 STM32的中断应用6.2.1 NVIC 初始化配置1. 配置组优先级 6.2.2 外部中断EXTISTM32 芯片外设的中断请求直接连接到 NVIC，来自芯片之外的外设中断请求需要通过EXTI（外部中断&#x2F;事件控制器）连接到NVIC。 2. EXTI 寄存器 第七章 STM32 的串行通信接口7.1 串行异步通信串行通信有两类：一类是速度较快的同步串行通信，以数据块为基本传输单位，主要应用于网络连接；另一类是速度较慢的异步通信，以字符为单位传输，主要应用于近距离通信。通常所说的串行通信一般是指串行同步通信 7.1.1 串行异步通信字符格式 起始位(Start Bit): 采取逻辑 0 电平 数据位(Data Bit): 一般是8位 校验位(Parity Bit): 可有可无，一般是奇偶校验位 停止位(Stop Bit): 字符最后必须有停止位，采取逻辑1电平 通信传输速率要相同，如9600bps表示一秒传输9600位 7.1.2 串行异步通信接口1. RS-232标准的引脚定义 TxD(Transmitted Data,发送数据) RxD(Received Data, 接收数据) RTS(Request To Send，请求发送) CTS(Clear To Send，清除发送) DTR(Data Terminal Ready，数据终端准备好) DSR(Data Set Ready，数据装置准备好) GND(Ground，信号地) CD(Carrier Detected，载波检测) RI(RIng Indicator，振铃指示) 2. RS-232接口的连接三线相连 7.2 通用同步&#x2F;异步接收&#x2F;发送器通用同步&#x2F;异步接收&#x2F;发送器（USART）和通用异步接收&#x2F;发送器(UART)","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://liuxindg.gitbub.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"嵌入式复习","slug":"嵌入式复习","permalink":"https://liuxindg.gitbub.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0/"}],"author":"琉心"},{"title":"text1","slug":"text1","date":"2023-06-13T11:18:32.000Z","updated":"2023-06-13T11:23:55.046Z","comments":true,"path":"2023/06/13/text1/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/13/text1/","excerpt":"","text":"111 . 低字节位数据存放在内存低地址处，高字节位数据存放在内存高地址处，这就是小端字节序。 202.96.128.128 D 节省 银行 对10 无缓冲是同步的11。 13212 func f(a,b int) (value int, error) 13 int 和体系架构 14 其他三个 15 主键是唯一、不为空 16 direct 17 直接插入 18 堆 19 在100000 20 不选进程是动态的过程 21 不选 HTTP返回码 302 22 选 协程和线程都可以 以及 通过 channel 23 不选接口赋值 24 不选 数据库索引的存在 25 不选 POST比get安全 26 不选域名解析 27 只选快速 12 28","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-06-13T10:37:15.364Z","updated":"2023-06-13T10:37:15.364Z","comments":true,"path":"2023/06/13/hello-world/","link":"","permalink":"https://liuxindg.gitbub.io/2023/06/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Go语言","slug":"Go语言","permalink":"https://liuxindg.gitbub.io/categories/Go%E8%AF%AD%E8%A8%80/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://liuxindg.gitbub.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liuxindg.gitbub.io/tags/golang/"},{"name":"基础语法","slug":"基础语法","permalink":"https://liuxindg.gitbub.io/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"嵌入式复习","slug":"嵌入式复习","permalink":"https://liuxindg.gitbub.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0/"}]}